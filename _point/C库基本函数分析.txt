string.h里的函数
mem系列
总共5个。除了memcmp返回int外，其余的都是返回void *。
	memcpy
		简单，没有特别的。
	memset
		简单。
	memmove
		这个要注意了。要特殊情况：
		dest和src内存区域可能完全重叠，部分重叠，不重叠。
		要处理全面。画图理解一下，就很好懂。
	memcmp
		简单。
	memchr
		简单。
		
str系列
有比较多，常用的是下面这些。
	strcpy
		简单。
	strncpy
		简单。注意把最后面的清零。
	strcat
		strcpy(d + strlen(d), s);
		一行代码就搞定。
	strcmp
		简单。
	strchr
		简单。
	strrchr
		简单。
	strstr
		值得看看。
		我自己写。
		s1 s2 。
		s1假设为abcd。
		s2的可能情况：
			abcde 比s1要长。
			abcd 一样长，且相同。
			bcde 一样长，不相等。
			bc 短一些，且可以找到。
			de 短一些，找不到。但是有相同字母。
			ef 完全找不到。
			""空字符串。这个我测试一下标准的，是可以算找到的。
				但是返回的是s1的开头位置。
		不难，两层循环就搞定了。
	strtok
		这个其实是很有用的一个函数，但是我平时用得少。
		strtok("abc,def,ghi",",")，最后可以分割成为abc def ghi.
		尤其在点分十进制的IP中提取应用较多。
		这个函数的实现有点麻烦。暂时不管了。
		
字符串和整数的相互转换
这个也值得看一下。
atoi
	123a，这样会得到123 。
	abc，得到0
	a123，得到0
	那么推测算法应该是：
		从头开始，碰到不是0到9的数字则结束。
	很简单。
	自己写出来了。
atol
	跟atoi没有什么区别。
atof
	跟atof的表现比较像。
	不过注意一点，".123"这个是合法的写法。
	"1.1.1"这种，得到的是1.1，那么就是只认第一个点号。
	小数点前面的没有什么问题。
	问题在于小数点后面的。
	也可以按照小数点前面的那样来处理。记下来有多少为小数。
	把小数点后面的部分，再用循环除以小数的位数次。
	把整数部分和小数部分加起来返回就好了。
	
