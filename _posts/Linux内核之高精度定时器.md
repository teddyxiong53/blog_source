---
title: Linux内核之高精度定时器
date: 2018-05-06 18:32:20
tags:
	- Linux内核

---



linux高精度定时器，叫hrtimer。可以精确到ns级别。

我们先看看在驱动里怎么使用。



# 低精度定时器

讨论高精度定时器之前，我们先看看低精度定时器。

利用定时器，我们可以设定在未来某一个时刻，触发一个特定事件的发生。

所谓的低精度定时器，就是这种定时是基于jiffies值的。

如果内核配置的HZ宏为1000的话，那么系统的低分辨率定时器的精度就是1ms。

早期的内核版本里，并不支持高精度定时器。所以只能用这种低精度的定时器。

后面出现了高精度定时器，但是也只是内核里的一个可选项。

所以现在内核里仍然是有大量低精度定时器的使用。

定义一个低精度定时器，方法又两种，第一种是静态的，第二种是动态的。

静态方式：

```
使用DEFINE_TIMER这个宏来定义。
```

动态方式：

```
struct timer_list timer;
init_timer(&timer);
timer.function = func,
timer.expires = expr;
timer.data = data;
```

激活一个定时器：

```
add_timer(&timer);
```

修改定时器的到期时间：

```
modify_timer(&timer, jiffies+50);
```

删除定时器：

```
del_timer(&timer);
```



在tick定时器的每次中断，都可能有大量的定时器到期。

难道每个tick中断都遍历一下所有的定时器吗？

这种方法太笨了。内核用了更聪明的方法。

内核把定时器按照到期时间进行分组。

因为目前多核处理器的大量应用。内核在定时器也充分利用了多核特性。

为了较好地利用cache line，也为了避免cpu之间的互锁。

内核使用了per-cpu资源来管理定时器。



内核的低精度定时器实现非常精妙，既实现了大量定时器的管理，又实现了快速的O(1)查找到期定时器的能力。

利用巧妙的数组结构，使得只需在间隔256个tick时间才处理一次迁移操作。5个数组就好比是5个齿轮级联起来，低一级的齿轮转动一圈，高一级的齿轮转动一个齿。

所以低精度定时器也叫time wheel。

它是一个很好的空间换时间的算法。



# 高精度定时器

随着内核的不断演进，硬件的不断发展，产生了对高精度定时器的需求。

内核从2.6.16开始加入高精度定时器。下面简称hrtimer

在实现方式上，hrtimer没有借用低精度定时器的数据结构和代码，原因有这些：

1、低精度定时器跟jiffies关系过于紧密。并且默认按32位设计。代码已经稳定。如果基于它来高精度定时器，可能破坏原有的代码稳定性。

2、低精度定时器主要是为超时而设计的，精确定时并不是它的设计目的。



因此，hrtimer是另起炉灶，重新设计了一套软件架构。

它可以为我们提供ns级别的定时精度。

用来满足对于精确时间又迫切需求的应用或者驱动。例如多媒体应用，音频设备的驱动。



如何设计hrtimer？

我们期望用来组织hrtimer的数据结构，它由如下的特性：

1、查找稳定、快速。

2、插入删除快速。

3、支持排序。

内核开发者在考量了内核里的各种数据结构后，最终选择了红黑树。

红黑树已经存在内核里，并且在内存管理子系统和文件系统里大量使用了。

随着系统的运行，hrtimer不断创建和销毁，新的hrtimer被插入到红黑树里，树的最左边的节点，就是下一个到期的定时器。



# 参考资料

1、Linux下的hrtimer高精度定时器

https://blog.csdn.net/waverider2012/article/details/38305785

2、Linux时间子系统之五：低分辨率定时器的原理和实现

https://blog.csdn.net/droidphone/article/details/8051405

3、Linux时间子系统之六：高精度定时器（HRTIMER）的原理和实现

https://blog.csdn.net/droidphone/article/details/8074892