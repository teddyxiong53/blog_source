---
title: 64位内核加32位应用有什么好处
date: 2022-10-10 16:08:33
tags:
	- 内核

---

--

内核中找到了是否支持32位应用的选项，将该选项打开



64bit计算主要有两大优点：

可以进行更大范围的整数运算；

可以支持更大的内存。



要实现真正意义上的64位计算，光有64位的处理器是不行的，

还必须得有64位的操作系统以及64位的应用软件才行，三者缺一不可，

缺少其中任何一种要素都是无法实现64位计算的。



目前主流CPU使用的64位技术主要有AMD公司的AMD64位技术、Intel公司的EM64T技术、和Intel公司的IA-64技术。

其中IA-64是Intel独立开发，不兼容现在的传统的32位计算机，仅用于Itanium（安腾）以及后续产品Itanium 2，一般用户不会涉及到，主要用于服务器。



64位处理器之失

※硬件———缺乏驱动程序，很多现有硬件无法使用

※软件———操作系统不是问题，但是软件出现不兼容难题

 

64位处理器之得

※硬件———更快的执行速度，更大的内存管理

※软件———最新的尖端软件首先出现在64位平台



在64位系统上，可以执行64位和32位应用程序。在32位系统上，只能执行32位应用程序，不能执行64位应用程序。



在64位系统上，gcc默认编译成64位程序，但可以编译32位程序，需要安装32位库。

安装32位库 ：sudo apt-get install lib32readline-gplv2-dev 
编译32位程序：gcc -m32 t1.c



# kernel是怎样兼容32位和64位的

Linux 内核在兼容 32 位和 64 位系统方面采取了一些策略和技术。这种兼容性是为了确保旧的 32 位软件能够运行在 64 位系统上，同时还支持新的 64 位软件。以下是一些关键的方面：

1. **多架构支持**：Linux 内核是多架构的，支持多种处理器架构，包括 x86、x86-64、ARM、MIPS、PowerPC 等。这意味着内核可以根据系统的架构进行编译，因此可以在不同架构的系统上运行。

2. **32 位兼容性**：==64 位 Linux 内核包含一个子系统，允许在 64 位系统上运行 32 位应用程序。==这通过 32 位兼容库和运行时环境的支持来实现。这意味着 32 位应用程序可以在 64 位系统上运行，而无需进行重编译。

3. **ABI 兼容性**：Linux 内核维护了与用户空间的应用程序二进制接口 (ABI) 兼容性。这意味着旧的 32 位应用程序仍然可以在 64 位系统上运行，只要它们依赖的系统调用和库的 ABI 保持兼容。

4. **多架构支持的系统调用**：Linux 内核支持多种架构的系统调用，这些系统调用会根据正在运行的应用程序的架构来进行处理。这有助于确保应用程序可以在不同架构的系统上运行。

5. **64 位性能和特性**：64 位系统提供了更大的内存地址空间和更高的性能，因此一些应用程序可以受益于 64 位的特性。新的 64 位应用程序可以利用这些特性，而不仅仅是在 32 位兼容模式下运行。

6. **模块兼容性**：内核模块通常需要特定版本的内核头文件和编译选项。在 64 位系统上，可以编译 32 位模块以与内核兼容，以便它们能够加载并运行。

总的来说，Linux 内核通过多架构支持、32 位兼容性、ABI 兼容性和其他技术策略，确保了 32 位和 64 位软件可以在同一系统上运行，并利用不同架构的性能和特性。这种兼容性使得 Linux 内核在不同类型的硬件和应用程序之间具有广泛的可移植性。

# 内核的ioctl 32bit兼容

在 Linux 内核中，32位应用程序与64位内核的兼容性是一个重要的问题，特别是在处理设备驱动程序和`ioctl`系统调用时。为了确保32位应用程序能够与64位内核正常通信，需要考虑以下几个方面：

1. **数据结构的大小和布局**：
   - 32位和64位系统的数据结构大小和布局可能会不同。为了确保ioctl调用能够正确解释和处理数据，驱动程序必须进行适当的数据结构转换。

2. **ioctl命令编码**：
   - ioctl 命令通常是32位整数，因此在64位内核上处理32位应用程序的ioctl命令时，需要确保命令编码被正确解释。内核通常提供宏来生成适当的ioctl命令编码，以考虑位宽和架构的差异。

3. **参数验证**：
   - 驱动程序应该对传递给ioctl的参数进行适当的验证，以确保它们在32位和64位环境中都能够正常工作。这可能涉及到检查指针的有效性、数据的大小和合法性等。

4. **32位兼容层**：
   - Linux 内核通常提供了32位兼容层，以支持在64位内核上运行32位应用程序。这个兼容层可以处理许多兼容性问题，包括ioctl调用。

5. **适当的转换**：
   - 在驱动程序中，通常需要执行适当的数据类型转换，以确保数据正确传递和解释。这可能涉及使用`copy_to_user`和`copy_from_user`等函数。

6. **64位扩展**：
   - 考虑到64位系统的优势，一些驱动程序可能会使用64位数据类型或功能来提供更大的地址空间和性能。在32位兼容性方面，需要小心处理这些情况。

总之，确保32位应用程序与64位内核的ioctl调用兼容性需要仔细考虑和实施。Linux 内核提供了一些工具和机制来简化这个过程，但驱动程序的开发者需要了解并遵循这些最佳实践，以确保应用程序能够在不同架构和位宽的系统上正常运行。



ioctl() 是应用程序与设备驱动程序交互的最常见方法。

它非常灵活，可以通过添加新命令轻松扩展，

并且可以通过字符设备、块设备以及套接字和其他特殊文件描述符进行传递。



**然而，ioctl 命令定义也很容易出错，而且以后很难在不破坏现有应用程序的情况下修复它们，**

因此本文档试图帮助开发人员正确解决它。



ioctl 命令可以返回负错误代码，如 errno(3) 中所述；

这些被转化为用户空间中的 errno 值。

成功时，返回代码应为零。也可以但不建议返回正的“long”值。



当使用未知命令号调用 ioctl 回调时，处理程序返回 -ENOTTY 或 -ENOIOCTLCMD，这也会导致从系统调用返回 -ENOTTY。

由于历史原因，某些子系统在此处返回 -ENOSYS 或 -EINVAL，但这是错误的。



在 Linux 5.5 之前，compat_ioctl 处理程序需要返回 -ENOIOCTLCMD 才能使用回退转换为本机命令。

由于所有子系统现在都负责处理兼容模式本身，因此不再需要这样做，但在将错误修复向后移植到旧内核时考虑可能很重要。



传统上，时间戳和超时值作为 struct timespec 或 struct timeval 传递，

但这些是有问题的，因为在迁移到 64 位 time_t 后，用户空间中这些结构的定义不兼容。



当需要单独的秒/纳秒值时，

可以使用 struct __kernel_timespec 类型嵌入其他数据结构中，

或者直接传递到用户空间。



但这仍然不理想，因为该结构既不与内核的 timespec64 也不与用户空间的 timespec 完全匹配。 

get_timespec64() 和 put_timespec64() 辅助函数可用于确保布局与用户空间保持兼容，并且填充得到正确处理。

由于将秒转换为纳秒很便宜，但相反需要昂贵的 64 位除法，

因此简单的 __u64 纳秒值可以更简单、更高效。

==超时值和时间戳最好使用 CLOCK_MONOTONIC 时间，由 ktime_get_ns() 或 ktime_get_ts64() 返回。==

==与 CLOCK_REALTIME 不同，这使得时间戳不会因闰秒调整和 Clock_settime() 调用而向后或向前跳跃。==

ktime_get_real_ns() 可用于需要在重新启动后或多台计算机之间保持持久性的 CLOCK_REALTIME 时间戳。



32位兼容模式
为了支持在 64 位机器上运行的 32 位用户空间，实现 ioctl 回调处理程序的每个子系统或驱动程序也必须实现相应的 compat_ioctl 处理程序。

只要遵循数据结构的所有规则，这就像将 .compat_ioctl 指针设置为辅助函数（例如 compat_ptr_ioctl() 或 blkdev_compat_ptr_ioctl() ）一样简单。

# yocto下面64位和32位应用同时支持

就是multilib机制。



随着 64 位处理器在嵌入式系统中变得越来越普遍，对运行本机 64 位的软件的需求非常大。

然而，首先面临的挑战是确保应用程序正确移植，这是一项耗时的任务，==并且在某些情况下，将遗留应用程序移植到 64 位可能没有意义。==

然而，这对于完整的解决方案至关重要。



新的 SBC 和 SOM 越来越多地使用 64 位 ARM (aarch64) CPU 架构进行设计。

示例包括 RaspberryPI3 (cortext-a53)、RaspberryPI4 (cortex-a72) 和基于 iMX8 的 SOM – 这些均使用 armv8+ 架构。

这些平台的板卡支持包都支持原生64位并且相当稳定。

然而，由于各种原因，某些应用程序堆栈可能仍然需要 32 位模式支持。

==此外，64 位应用程序通常使用更多 DRAM，并且可能比在 32 位模式下编译的相同应用程序执行速度更慢。==



因此，我们有多种选择可以在 64 位平台上运行 32 位应用程序：

* 使用完整的32位模式，这将完全限制64位ISA的使用（也就是内核和应用都是32位的）
* 以 64 位模式运行内核，但让整个用户空间以 32 位模式运行（这个工作量小，应用不需要任何移植）
* 在 64 位用户空间下以 64 位模式运行内核，并额外支持 32 位运行时（这个是我们想要的）



这些选项都有自己的一套权衡。

在 32 位模式下执行所有操作（#1）可以为我们提供向后兼容性，但是我们无法使用 64 位模式 ISA，并且虚拟内存空间仅限于 4GB。

第二个选项允许使用 BSP 默认值以 64 位模式运行内核，但保持用户空间为 32 位。这是使用现有用户空间软件阻力最小的途径，无需任何重大的移植工作。

第三个选项提供 32 位和 64 位用户空间的混合，这会增加运行时的重复，增加固件的静态占用空间，这可能是许多嵌入式系统的设计因素。应用程序的运行时 DRAM 要求也较高，这可能不适合手头的嵌入式系统，因为 DRAM 是宝贵的资源。



Enable Yocto multilib configuration settings in `conf/local.conf`

```bash
    # multilib arm
    require conf/multilib.conf
    MULTILIBS = "multilib:lib32"
    DEFAULTTUNE_virtclass-multilib-lib32 = "armv7athf-neon-vfpv4"
```

如果需要，这些设置将指示构建启用在 32 位模式下构建应用程序，

DEFAULTTUNE 是一个重要设置，它可以设置为与纯 32 位构建中使用的值相同的值，也许在较旧的机器设计中。

构建仅 32 位的用户空间映像

```
source ./raspberrypi3-64-envsetup.sh
bitbake lib32-yoe-kiosk-imgae
```

这应该构建一个 64 位内核和==纯 32 位 kiosk 映像，并使用所有 multilib 设置==，以便 64 位内核可以启动到 32 位用户空间

这应该构建一个 64 位内核和纯 32 位 kiosk 映像，并使用所有 multilib 设置，以便 64 位内核可以启动到 32 位用户空间



也可以混合64位和32位应用。

通过 local.conf 中的 IMAGE_INSTALL 将所需的 32 位应用程序添加到映像中

```
IMAGE_INSTALL_append = ' lib32-python3-core lib32-htop'
```

这会将 32 位版本的 htop 应用程序和 32 位 python 添加到其他 64 位image中



https://www.yoedistro.org/posts/2020-04-09_64-bit-kernels-with-32-bit-userspace/

# Linux 64位的内核是如何支持32位的应用的？

Linux 64位内核支持32位应用程序是通过一系列兼容性机制实现的。这些机制主要包括以下几个方面：

| 机制           | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| **系统调用**   | 内核提供了一组32位系统调用接口，允许32位应用程序在64位内核上运行。这些接口通过特定的中断号和寄存器参数传递机制实现。 |
| **兼容库**     | 需要安装32位版本的C库（如glibc），这些库为32位应用程序提供必需的运行时环境。64位系统通常会包含一个`/lib32`目录，用于存放这些32位库。 |
| **ELF格式**    | 64位内核支持32位和64位的ELF（Executable and Linkable Format）二进制文件。内核可以识别和加载32位的ELF文件，并为其提供适当的执行环境。 |
| **多架构支持** | 64位内核编译时会启用`CONFIG_IA32_EMULATION`选项，这使得内核能够识别和处理32位的指令和地址空间。这种支持在内核层面处理了32位和64位应用的差异。 |
| **信号处理**   | 内核提供了信号处理机制的兼容性，以确保32位应用程序可以正确处理和响应信号。 |
| **动态链接器** | 需要一个32位的动态链接器（如ld-linux.so.2）来处理32位应用程序的动态库加载。64位系统通常会包含这个链接器。 |
| **文件系统**   | 文件系统层面没有太大区别，但某些系统目录（如`/lib`和`/lib32`）会分别存放64位和32位的库文件，以确保应用程序可以找到适合的库。 |

这些机制协同工作，使得32位应用程序可以无缝地在64位Linux内核上运行。



# arm处理器对32/64位的支持

在ARM架构（ARM和AArch64）下，64位内核支持32位应用程序的方法和机制与x86架构类似，但有一些ARM特有的实现细节。

| 机制                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| **系统调用入口**       | 32位应用程序通过`svc`（Supervisor Call）指令进入内核。64位应用程序使用`svc`或`hvc`（Hypervisor Call）指令。 |
| **参数传递**           | 系统调用参数通过寄存器（如`r0`, `r1`, `r2`, `r3`等）传递，和x86类似。 |
| **系统调用号**         | 寄存器`r7`中包含系统调用号，内核根据该号确定具体调用的服务。 |
| **兼容性代码**         | 内核包含专门的兼容性代码路径，这些代码路径处理32位系统调用。 |
| **用户空间到内核空间** | 内核从32位用户空间复制参数到64位内核空间，并执行相应的系统调用逻辑。 |
| **返回值**             | 系统调用完成后，返回值存储在寄存器中（如`r0`），返回到32位应用。 |
| **信号处理**           | 兼容32位的信号处理机制，确保信号能够正确地传递和处理。       |

### 具体实现细节

#### 系统调用入口

在ARM架构中，32位应用程序通常通过`svc`指令进入内核。64位内核在捕获到`svc`指令后，会检查当前任务的模式（32位或64位），并相应地进入不同的系统调用处理路径。

#### 参数传递和处理

- 32位应用程序在调用系统调用时，会将参数存储在`r0`, `r1`, `r2`, `r3`等寄存器中。
- `r7`寄存器中包含系统调用号。内核通过读取这些寄存器获取系统调用号和参数，然后将参数从32位用户空间复制到64位内核空间。

#### 系统调用实现

- 在内核代码中，有一组专门的函数用于处理32位系统调用。对于ARM架构，这些函数通常在`arch/arm/`或`arch/arm64/`目录中实现。
- 内核通过一个系统调用表（syscall table）管理系统调用号和对应的处理函数。在32位兼容模式下，内核会查找32位系统调用表中的处理函数。

#### 兼容性处理

- 内核需要处理32位和64位数据结构之间的差异。例如，指针和一些数据类型在32位和64位系统中大小不同。
- 需要转换一些特定的结构和参数，以确保系统调用可以正确执行。

这些机制和实现细节使得ARM架构上的64位内核能够为32位应用程序提供兼容的系统调用接口，确保这些应用程序可以在64位内核上正确运行。

# buildroot怎样支持64位内核+32位应用的模式

目前默认应该只有MIPS64n32

其他的芯片都没有。

https://lore.kernel.org/all/20220115200306.14037-1-patrickdepinguin@gmail.com/T/

我们是通过简单的方法增加了支持，但是做法不是很优雅。

其实是希望buildroot官方就支持这个规格的。



# 参考资料

1、

https://blog.csdn.net/sunao2002002/article/details/51917917

2、

https://blog.csdn.net/jiuxin/article/details/107559416

3、

https://blog.csdn.net/qq1263575666/article/details/79381217