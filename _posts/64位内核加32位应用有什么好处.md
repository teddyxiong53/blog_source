---
title: 64位内核加32位应用有什么好处
date: 2022-10-10 16:08:33
tags:
	- 内核

---

--

内核中找到了是否支持32位应用的选项，将该选项打开



64bit计算主要有两大优点：

可以进行更大范围的整数运算；

可以支持更大的内存。



要实现真正意义上的64位计算，光有64位的处理器是不行的，

还必须得有64位的操作系统以及64位的应用软件才行，三者缺一不可，

缺少其中任何一种要素都是无法实现64位计算的。



目前主流CPU使用的64位技术主要有AMD公司的AMD64位技术、Intel公司的EM64T技术、和Intel公司的IA-64技术。

其中IA-64是Intel独立开发，不兼容现在的传统的32位计算机，仅用于Itanium（安腾）以及后续产品Itanium 2，一般用户不会涉及到，主要用于服务器。



64位处理器之失

※硬件———缺乏驱动程序，很多现有硬件无法使用

※软件———操作系统不是问题，但是软件出现不兼容难题

 

64位处理器之得

※硬件———更快的执行速度，更大的内存管理

※软件———最新的尖端软件首先出现在64位平台



在64位系统上，可以执行64位和32位应用程序。在32位系统上，只能执行32位应用程序，不能执行64位应用程序。



在64位系统上，gcc默认编译成64位程序，但可以编译32位程序，需要安装32位库。

安装32位库 ：sudo apt-get install lib32readline-gplv2-dev 
编译32位程序：gcc -m32 t1.c



# kernel是怎样兼容32位和64位的

Linux 内核在兼容 32 位和 64 位系统方面采取了一些策略和技术。这种兼容性是为了确保旧的 32 位软件能够运行在 64 位系统上，同时还支持新的 64 位软件。以下是一些关键的方面：

1. **多架构支持**：Linux 内核是多架构的，支持多种处理器架构，包括 x86、x86-64、ARM、MIPS、PowerPC 等。这意味着内核可以根据系统的架构进行编译，因此可以在不同架构的系统上运行。

2. **32 位兼容性**：64 位 Linux 内核包含一个子系统，允许在 64 位系统上运行 32 位应用程序。这通过 32 位兼容库和运行时环境的支持来实现。这意味着 32 位应用程序可以在 64 位系统上运行，而无需进行重编译。

3. **ABI 兼容性**：Linux 内核维护了与用户空间的应用程序二进制接口 (ABI) 兼容性。这意味着旧的 32 位应用程序仍然可以在 64 位系统上运行，只要它们依赖的系统调用和库的 ABI 保持兼容。

4. **多架构支持的系统调用**：Linux 内核支持多种架构的系统调用，这些系统调用会根据正在运行的应用程序的架构来进行处理。这有助于确保应用程序可以在不同架构的系统上运行。

5. **64 位性能和特性**：64 位系统提供了更大的内存地址空间和更高的性能，因此一些应用程序可以受益于 64 位的特性。新的 64 位应用程序可以利用这些特性，而不仅仅是在 32 位兼容模式下运行。

6. **模块兼容性**：内核模块通常需要特定版本的内核头文件和编译选项。在 64 位系统上，可以编译 32 位模块以与内核兼容，以便它们能够加载并运行。

总的来说，Linux 内核通过多架构支持、32 位兼容性、ABI 兼容性和其他技术策略，确保了 32 位和 64 位软件可以在同一系统上运行，并利用不同架构的性能和特性。这种兼容性使得 Linux 内核在不同类型的硬件和应用程序之间具有广泛的可移植性。

# 内核的ioctl 32bit兼容

在 Linux 内核中，32位应用程序与64位内核的兼容性是一个重要的问题，特别是在处理设备驱动程序和`ioctl`系统调用时。为了确保32位应用程序能够与64位内核正常通信，需要考虑以下几个方面：

1. **数据结构的大小和布局**：
   - 32位和64位系统的数据结构大小和布局可能会不同。为了确保ioctl调用能够正确解释和处理数据，驱动程序必须进行适当的数据结构转换。

2. **ioctl命令编码**：
   - ioctl 命令通常是32位整数，因此在64位内核上处理32位应用程序的ioctl命令时，需要确保命令编码被正确解释。内核通常提供宏来生成适当的ioctl命令编码，以考虑位宽和架构的差异。

3. **参数验证**：
   - 驱动程序应该对传递给ioctl的参数进行适当的验证，以确保它们在32位和64位环境中都能够正常工作。这可能涉及到检查指针的有效性、数据的大小和合法性等。

4. **32位兼容层**：
   - Linux 内核通常提供了32位兼容层，以支持在64位内核上运行32位应用程序。这个兼容层可以处理许多兼容性问题，包括ioctl调用。

5. **适当的转换**：
   - 在驱动程序中，通常需要执行适当的数据类型转换，以确保数据正确传递和解释。这可能涉及使用`copy_to_user`和`copy_from_user`等函数。

6. **64位扩展**：
   - 考虑到64位系统的优势，一些驱动程序可能会使用64位数据类型或功能来提供更大的地址空间和性能。在32位兼容性方面，需要小心处理这些情况。

总之，确保32位应用程序与64位内核的ioctl调用兼容性需要仔细考虑和实施。Linux 内核提供了一些工具和机制来简化这个过程，但驱动程序的开发者需要了解并遵循这些最佳实践，以确保应用程序能够在不同架构和位宽的系统上正常运行。



ioctl() 是应用程序与设备驱动程序交互的最常见方法。

它非常灵活，可以通过添加新命令轻松扩展，

并且可以通过字符设备、块设备以及套接字和其他特殊文件描述符进行传递。



**然而，ioctl 命令定义也很容易出错，而且以后很难在不破坏现有应用程序的情况下修复它们，**

因此本文档试图帮助开发人员正确解决它。



ioctl 命令可以返回负错误代码，如 errno(3) 中所述；

这些被转化为用户空间中的 errno 值。

成功时，返回代码应为零。也可以但不建议返回正的“long”值。



当使用未知命令号调用 ioctl 回调时，处理程序返回 -ENOTTY 或 -ENOIOCTLCMD，这也会导致从系统调用返回 -ENOTTY。

由于历史原因，某些子系统在此处返回 -ENOSYS 或 -EINVAL，但这是错误的。



在 Linux 5.5 之前，compat_ioctl 处理程序需要返回 -ENOIOCTLCMD 才能使用回退转换为本机命令。

由于所有子系统现在都负责处理兼容模式本身，因此不再需要这样做，但在将错误修复向后移植到旧内核时考虑可能很重要。



传统上，时间戳和超时值作为 struct timespec 或 struct timeval 传递，

但这些是有问题的，因为在迁移到 64 位 time_t 后，用户空间中这些结构的定义不兼容。



当需要单独的秒/纳秒值时，

可以使用 struct __kernel_timespec 类型嵌入其他数据结构中，

或者直接传递到用户空间。



但这仍然不理想，因为该结构既不与内核的 timespec64 也不与用户空间的 timespec 完全匹配。 

get_timespec64() 和 put_timespec64() 辅助函数可用于确保布局与用户空间保持兼容，并且填充得到正确处理。

由于将秒转换为纳秒很便宜，但相反需要昂贵的 64 位除法，

因此简单的 __u64 纳秒值可以更简单、更高效。

==超时值和时间戳最好使用 CLOCK_MONOTONIC 时间，由 ktime_get_ns() 或 ktime_get_ts64() 返回。==

==与 CLOCK_REALTIME 不同，这使得时间戳不会因闰秒调整和 Clock_settime() 调用而向后或向前跳跃。==

ktime_get_real_ns() 可用于需要在重新启动后或多台计算机之间保持持久性的 CLOCK_REALTIME 时间戳。



32位兼容模式
为了支持在 64 位机器上运行的 32 位用户空间，实现 ioctl 回调处理程序的每个子系统或驱动程序也必须实现相应的 compat_ioctl 处理程序。

只要遵循数据结构的所有规则，这就像将 .compat_ioctl 指针设置为辅助函数（例如 compat_ptr_ioctl() 或 blkdev_compat_ptr_ioctl() ）一样简单。

# yocto下面64位和32位应用同时支持

就是multilib机制。



随着 64 位处理器在嵌入式系统中变得越来越普遍，对运行本机 64 位的软件的需求非常大。

然而，首先面临的挑战是确保应用程序正确移植，这是一项耗时的任务，==并且在某些情况下，将遗留应用程序移植到 64 位可能没有意义。==

然而，这对于完整的解决方案至关重要。



新的 SBC 和 SOM 越来越多地使用 64 位 ARM (aarch64) CPU 架构进行设计。

示例包括 RaspberryPI3 (cortext-a53)、RaspberryPI4 (cortex-a72) 和基于 iMX8 的 SOM – 这些均使用 armv8+ 架构。

这些平台的板卡支持包都支持原生64位并且相当稳定。

然而，由于各种原因，某些应用程序堆栈可能仍然需要 32 位模式支持。

==此外，64 位应用程序通常使用更多 DRAM，并且可能比在 32 位模式下编译的相同应用程序执行速度更慢。==



因此，我们有多种选择可以在 64 位平台上运行 32 位应用程序：

* 使用完整的32位模式，这将完全限制64位ISA的使用（也就是内核和应用都是32位的）
* 以 64 位模式运行内核，但让整个用户空间以 32 位模式运行（这个工作量小，应用不需要任何移植）
* 在 64 位用户空间下以 64 位模式运行内核，并额外支持 32 位运行时（这个是我们想要的）



这些选项都有自己的一套权衡。

在 32 位模式下执行所有操作（#1）可以为我们提供向后兼容性，但是我们无法使用 64 位模式 ISA，并且虚拟内存空间仅限于 4GB。

第二个选项允许使用 BSP 默认值以 64 位模式运行内核，但保持用户空间为 32 位。这是使用现有用户空间软件阻力最小的途径，无需任何重大的移植工作。

第三个选项提供 32 位和 64 位用户空间的混合，这会增加运行时的重复，增加固件的静态占用空间，这可能是许多嵌入式系统的设计因素。应用程序的运行时 DRAM 要求也较高，这可能不适合手头的嵌入式系统，因为 DRAM 是宝贵的资源。



Enable Yocto multilib configuration settings in `conf/local.conf`

```bash
    # multilib arm
    require conf/multilib.conf
    MULTILIBS = "multilib:lib32"
    DEFAULTTUNE_virtclass-multilib-lib32 = "armv7athf-neon-vfpv4"
```

如果需要，这些设置将指示构建启用在 32 位模式下构建应用程序，

DEFAULTTUNE 是一个重要设置，它可以设置为与纯 32 位构建中使用的值相同的值，也许在较旧的机器设计中。

构建仅 32 位的用户空间映像

```
source ./raspberrypi3-64-envsetup.sh
bitbake lib32-yoe-kiosk-imgae
```

这应该构建一个 64 位内核和==纯 32 位 kiosk 映像，并使用所有 multilib 设置==，以便 64 位内核可以启动到 32 位用户空间

这应该构建一个 64 位内核和纯 32 位 kiosk 映像，并使用所有 multilib 设置，以便 64 位内核可以启动到 32 位用户空间



也可以混合64位和32位应用。

通过 local.conf 中的 IMAGE_INSTALL 将所需的 32 位应用程序添加到映像中

```
IMAGE_INSTALL_append = ' lib32-python3-core lib32-htop'
```

这会将 32 位版本的 htop 应用程序和 32 位 python 添加到其他 64 位image中



https://www.yoedistro.org/posts/2020-04-09_64-bit-kernels-with-32-bit-userspace/

# 参考资料

1、

https://blog.csdn.net/sunao2002002/article/details/51917917

2、

https://blog.csdn.net/jiuxin/article/details/107559416

3、

https://blog.csdn.net/qq1263575666/article/details/79381217