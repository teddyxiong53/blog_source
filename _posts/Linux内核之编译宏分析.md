---
title: Linux内核之编译宏分析
date: 2020-08-29 11:46:47
tags:
	- Linux

---

--

所有的内核代码，基本都包含了include/linux/compile.h这个文件，所以它是基础，涵盖了分析内核所需要的一些列编译知识，

```
__ASSEMBLY__
	因为内核的头文件也会被汇编文件使用。
	而很多的宏在汇编里是用不了登陆。
	所以用这个，把汇编里某些宏定义为空的。
__CHECKER__
	这些都是给检查工具分析用的。不写没有关系。
	make C=1或者make C=2，就会用到这些检查
	__user
	__kernel
	__iomem
	__safe  
    	这个是为了检查不必要的NULL检查。
```

这里Sparse工具把程序空间分成了3个部分，

0表示normal space，即普通地址空间，对内核代码来说，当然就是内核空间地址了。

1表示用户地址空间，这个不用多讲，

还有一个2，表示是设备地址映射空间，例如硬件设备的寄存器在内核里所映射的地址空间。

不过到目前为止，在现在的代码里没有发现有使用`__safe`这个定义的地方，不知道是不是编译器现在已经支持这种特殊的情况了，所以就不用再加这样的代码了。

```
#define likely(x) __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
```

这两句是一对对应关系。__builtin_expect(expr, c)这个函数是新版gcc支持的，

**它是用来作代码优化的，**用来告诉编译器，expr的期，非常有可能是c，

这样在gcc生成对应的汇编代码的时候，会把相应的可能执行的代码都放在一起，**这样能少执行代码的跳转**

为什么这样能提高CPU的执行效率呢？

因为CPU在执行的时候，都是有**预先取指令的机制的**，

把将要执行的指令取出一部分出来准备执行。

CPU不知道程序的逻辑，所以都是从可程序程序里挨着取的，如果这个时候，能不做跳转，则CPU预先取出的指令都可以接着使用，反之，则预先取出来的指令都是没有用的。

还有个问题是需要注意的，在__builtin_expect的定义中，以前的版本是没有!!这个符号的，这个符号的作用其实就是负负得正，为什么要这样做呢？就是为了保证非零的x的值，后来都为1，如果为零的0值，后来都为0，仅此而已。



参考资料

1、Linux内核入门（七）—— 必要的编译知识

https://blog.csdn.net/yunsongice/article/details/5538416