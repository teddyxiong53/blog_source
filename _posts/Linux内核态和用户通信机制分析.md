---
title: Linux内核态和用户通信机制分析
date: 2017-02-18 14:20:28
tags:
	- Linux
---


总的来说，Linux系统运行时，其CPU状态一定处于下面4种状态中的一种：
1、中断处理。
2、软中断处理。
3、内核态。
4、用户态。

讨论内核态和用户态的通信之前，我们先回顾一下Linux的进程间通信机制的发展历史。
UNIX的两大分支AT&T和BSD分别发展出自己的一套通信机制，AT&T的叫做SystemV，BSD的则发展出基于socket的通信机制。后来，IEEE制定了posix的IPC标准，Linux也进行了实现。所以有了Linux进程间通信现在的样子。
为了完成内核态和用户态的通信，Linux基于socket实现了netlink机制。

总的来说，到目前为止，Linux提供了9种机制来实现内核空间和用户空间的数据交换。分别是：
1、内核启动参数。
2、模块参数。
3、sysfs。
4、sysctl。
5、系统调用。
6、netlink。
7、procfs。
8、seq_file。
9、debugfs和relayfs。
**以fs结尾的方式都是基于文件系统的的通信机制，实现内核空间向用户空间的输出。**
**sysctl和系统调用则由用户空间发起的通信机制。**
**这些都是单向的通信方式。**
而netlink基于socket实现，因为socket本身的双向性、突发性和不阻塞的特定，适合用来满足快速少量数据的交互。netlink在linux2.6里得到了广泛应用。

很高效的一种方式就是利用mmap映射，把内核地址空间映射到用户态，很适合进行大量的数据传输。缺点是没有一种可靠的机制来保证内核和用户的同步。一种解决方法是，在驱动层实现特殊的ioctl命令，用于控制。

netlink是一种比较好的方式。



分类：

```
1、内核到用户。
	各种fs
2、用户到内核。
	sysctl
	系统调用。
3、双向。
	netlink
```

