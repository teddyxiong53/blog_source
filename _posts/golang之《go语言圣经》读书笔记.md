---
title: golang之《go语言圣经》读书笔记
date: 2023-10-22 10:39:17
tags:
	- go语言

---

--

在线书籍在这里：

https://golang-china.github.io/gopl-zh/preface.html

# 序言

Go语言有时候被描述为“类C语言”，或者是“21世纪的C语言”。

Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，

还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。

但是在Go语言的家族树中还有其它的祖先。`Pascal`语言。

Go语言的另一支祖先，带来了Go语言区别其他语言的重要特性，灵感来自于贝尔实验室的[Tony Hoare](https://en.wikipedia.org/wiki/Tony_Hoare)于1978年发表的鲜为外界所知的关于并发研究的基础文献 *顺序通信进程* （ *communicating sequential processes* ，缩写为`CSP`。在`CSP`中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。

在`Plan9`操作系统中，这些优秀的想法被吸收到了一个叫`Alef`的编程语言中。`Alef`试图将`Newsqueak`语言改造为系统编程语言，但是因为缺少垃圾回收机制而导致并发编程很痛苦。

Go语言的其他的一些特性零散地来自于其他一些编程语言；比如`iota`语法是从`APL`语言借鉴，词法作用域与嵌套函数来自于`Scheme`语言（和其他很多语言）。当然，我们也可以从Go中发现很多创新的设计。比如Go语言的切片为动态数组提供了有效的随机存取的性能，这可能会让人联想到链表的底层的共享机制。还有Go语言新发明的`defer`语句。



所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。Go项目是在Google公司维护超级复杂的几个软件系统遇到的一些问题的反思（但是这类问题绝不是Google公司所特有的）。



Go项目包括编程语言本身，附带了相关的工具和标准库，

最后但并非代表不重要的是，关于简洁编程哲学的宣言。

就事后诸葛的角度来看，Go语言的这些地方都做的还不错：

拥有自动垃圾回收、

一个包系统、

函数作为一等公民、

词法作用域、

系统调用接口、

只读的UTF8字符串等。

但是Go语言本身只有很少的特性，也不太可能添加太多的特性。

例如，它没有隐式的数值转换，没有构造函数和析构函数，

没有运算符重载，没有默认参数，

也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。

但是，语言本身是成熟和稳定的，而且承诺保证向后兼容：

用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码。



Go语言有足够的类型系统以避免动态语言中那些粗心的类型错误，

但是，Go语言的类型系统相比传统的强类型语言又要简洁很多。

虽然，有时候这会导致一个“无类型”的抽象类型概念，

但是Go语言程序员并不需要像`C++`或`Haskell`程序员那样纠结于具体类型的安全属性。

在实践中，Go语言简洁的类型系统给程序员带来了更多的安全性和更好的运行时性能。



Go语言鼓励当代计算机系统设计的原则，特别是局部的重要性。

它的内置数据类型和大多数的准库数据结构都经过精心设计

而避免显式的初始化或隐式的构造函数，

因为很少的内存分配和内存初始化代码被隐藏在库代码中了。

Go语言的聚合类型（结构体和数组）可以直接操作它们的元素，

只需要更少的存储空间、更少的内存写操作，

而且指针操作比其他间接操作的语言也更有效率。

由于现代计算机是一个并行的机器，Go语言提供了基于`CSP`的并发特性支持。

**Go语言的动态栈使得轻量级线程`goroutine`的初始栈可以很小，**

因此，创建一个`goroutine`的代价很小，创建百万级的`goroutine`完全是可行的。



Go语言的标准库（通常被称为语言自带的电池），

提供了清晰的构建模块和公共接口，

包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，

并支持许多标准化的文件格式和编解码协议。

库和工具使用了大量的约定来减少额外的配置和解释，从而最终简化程序的逻辑，

而且，每个Go程序结构都是如此的相似，

因此，Go程序也很容易学习。

使用Go语言自带工具构建Go语言项目只需要使用文件名和标识符名称，

一个偶尔的特殊注释来确定所有的库、可执行文件、测试、基准测试、例子、以及特定于平台的变量、项目的文档等；

**Go语言源代码本身就包含了构建规范。**

# 入门

## helloworld

新建main.go文件，内容如下：

```
package main

import "fmt"

func main() {
	fmt.Println("hello world")
}
```

运行：

```
go run main.go
```

也可以编译为二进制运行：

```
go build main.go
./main
```

## 分析HelloWorld

来讨论下程序本身。

Go 语言的代码通过**包**（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。

一个包由位于单个目录下的一个或多个 `.go` 源代码文件组成，

目录定义包的作用。

每个源文件都以一条 `package` 声明语句开始，

这个例子里就是 `package main`，

表示该文件属于哪个包，

紧跟着一系列导入（import）的包，

之后是存储在这个文件里的程序语句。

Go 的标准库提供了 100 多个包，

以支持常见功能，如输入、输出、排序以及文本处理。

比如 `fmt` 包，就含有格式化输出、接收输入的函数。

`Println` 是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。

`**main` 包比较特殊。**

**它定义了一个独立可执行的程序，而不是一个库。**

在 `main` 里的 `main` *函数*也很特殊，它是整个程序执行时的入口（译注：C 系语言差不多都这样）。

`main` 函数所做的事情就是程序做的。

当然了，`main` 函数一般调用其它包里的函数完成很多工作（如：`fmt.Println`）。

`import` 声明必须跟在文件的 `package` 声明之后。

随后，则是组成程序的函数、变量、常量、类型的声明语句（分别由关键字 `func`、`var`、`const`、`type` 定义）。

**这些内容的声明顺序并不重要（译注：最好还是定一下规范）。**

这个例子的程序已经尽可能短了，只声明了一个函数，其中只调用了一个其他函数。

为了节省篇幅，有些时候示例程序会省略 `package` 和 `import` 声明，但是，这些声明在源代码里有，并且必须得有才能编译。

一个函数的声明由 `func` 关键字、函数名、参数列表、返回值列表（这个例子里的 `main` 函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。

第五章进一步考察函数。

Go 语言不需要在语句或者声明的末尾添加分号，

除非一行上有多条语句。

实际上，编译器会主动把特定符号后的换行符转换为分号，因此换行符添加的位置会影响 Go 代码的正确解析



Go 语言在代码格式上采取了很强硬的态度。

`gofmt`工具把代码格式化为标准格式（译注：这个格式化工具没有任何可以调整代码格式的参数，Go 语言就是这么任性），

并且 `go` 工具中的 `fmt` 子命令会对指定包，否则默认为当前目录中所有go 源文件应用 `gofmt` 命令。

本书中的所有代码都被 gofmt 过。

你也应该养成格式化自己的代码的习惯。

以法令方式规定标准的代码格式可以避免无尽的无意义的琐碎争执（译注：也导致了 Go 语言的 TIOBE 排名较低，因为缺少撕逼的话题）。

更重要的是，这样可以做多种自动源码转换，如果放任 Go 语言代码格式，这些转换就不大可能了。

## 命令行参数

`os` 包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从 `os` 包的 `Args` 变量获取；`os` 包外部使用 `os.Args` 访问该变量。

`os.Args` 变量是一个字符串（string）的 *切片*（slice）

实现一个echo程序：

```
package main

import (
	"fmt"
	"os"
)

func main() {
	var s, sep string
	for i:=1; i<len(os.Args); i++ {
		s += sep + os.Args[i]
		sep = " "
	}
	fmt.Println(s)
}
```

符号 `:=` 是 *短变量声明*（short variable declaration）的一部分，这是定义一个或多个变量并根据它们的初始值为这些变量赋予适当类型的语句。

Go 语言只有 `for` 循环这一种循环语句。`for` 循环有多种形式，其中一种如下所示：

```go
for initialization; condition; post {
    // zero or more statements
}
```

`for` 循环三个部分不需括号包围。大括号强制要求，左大括号必须和 *`post`* 语句在同一行。

for 循环的这三个部分每个都可以省略，如果省略 `initialization` 和 `post`，分号也可以省略：

```go
// a traditional "while" loop
for condition {
    // ...
}
```

如果连 `condition` 也省略了，像下面这样：

```go
// a traditional infinite loop
for {
    // ...
}
```

这就变成一个无限循环，尽管如此，还可以用其他方式终止循环，如一条 `break` 或 `return` 语句。

`for` 循环的另一种形式，在某种数据类型的区间（range）上遍历，如字符串或切片。

每次循环迭代，`range` 产生一对值；索引以及在该索引处的元素值。

Go 语言中这种情况的解决方法是用 *空标识符*（blank identifier），即 `_`（也就是下划线）。

声明一个变量有好几种方式，下面这些都等价：

```go
s := ""
var s string
var s = ""
var s string = ""
```

用哪种不用哪种，为什么呢？

第一种形式，是一条短变量声明，**最简洁，但只能用在函数内部**，而不能用于包变量。

第二种形式依赖于字符串的**默认初始化零值机制**，被初始化为 `""`。

第三种形式用得很少，除非同时声明多个变量。

第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。

实践中一般使用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。

如前文所述，每次循环迭代字符串 `s` 的内容都会更新。`+=` 连接原字符串、空格和下个参数，产生新字符串，并把它赋值给 `s`。`s` 原来的内容已经不再使用，将在适当时机对它进行垃圾回收。

如果连接涉及的数据量很大，这种方式代价高昂。

## 查找重复行

对文件做拷贝、打印、搜索、排序、统计或类似事情的程序都有一个差不多的程序结构：

一个处理输入的循环，在每个元素上执行计算处理，在处理的同时或最后产生输出。

我们会展示一个名为 `dup` 的程序的三个版本；

灵感来自于 Unix 的 `uniq` 命令，

其寻找相邻的重复行。

该程序使用的结构和包是个参考范例，可以方便地修改。



**map** 存储了键/值（key/value）的集合，对集合元素，提供常数时间的存、取或测试操作。

继续来看 `bufio` 包，它使处理输入和输出方便又高效。`Scanner` 类型是该包最有用的特性之一，它读取输入并将其拆成行或单词；通常是处理行形式的输入最简单的方法。



```
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	counts := make(map[string]int)
	files := os.Args[1:]
	if len(files) == 0 {
		countLines(os.Stdin, counts)
	} else {
		for _,arg := range files {
			f, err := os.Open(arg)
			if err != nil {
				fmt.Println(os.Stderr, "dup2: %v\n", err)
				continue
			}
			countLines(f, counts)
			f.Close()
		}
	}
	for line, n:= range counts {
		if n> 1 {
			fmt.Println("%d\t%s\n", n, line)
		}
	}
}

func countLines(f *os.File, counts map[string]int) {
	input := bufio.NewScanner(f)
	for input.Scan() {
		counts[input.Text()]++
	}
}
```

## gif动画生成

下面的程序会演示Go语言标准库里的image这个package的用法，我们会用这个包来生成一系列的bit-mapped图，然后将这些图片编码为一个GIF动画。

这段代码里我们用了一些新的结构，包括const声明，struct结构体类型，复合声明。和我们举的其它的例子不太一样，这一个例子包含了浮点数运算。这些概念我们只在这里简单地说明一下，之后的章节会更详细地讲解。

## 获取url

对于很多现代应用来说，访问互联网上的信息和访问本地文件系统一样重要。

Go语言在net这个强大package的帮助下提供了一系列的package来做这件事情，

使用这些包可以更简单地用网络收发信息，

还可以建立更底层的网络连接，编写服务器程序。

在这些情景下，Go语言原生的并发特性（在第八章中会介绍）显得尤其好用。

为了最简单地展示基于HTTP获取信息的方式，下面给出一个示例程序fetch，这个程序将获取对应的url，并将其源文本打印出来；这个例子的灵感来源于curl工具

## web服务

```
package main

import (
	"fmt"
	// "io/ioutil"
	"net/http"
	"sync"
	"log"
)
var mu sync.Mutex
var count int

func main () {
	http.HandleFunc("/", handler)
	http.HandleFunc("/count", counter)
	log.Fatal(http.ListenAndServe("192.168.56.102:8080",nil))
}
func handler(w http.ResponseWriter, r *http.Request) {
	mu.Lock()
	count++
	mu.Unlock()
	fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
}

func counter(w http.ResponseWriter, r *http.Request) {
	mu.Lock()
	fmt.Fprintf(w, "Count %d\n", count)
	mu.Unlock()
}
```

import了而没有使用的，也会导致编译不过。

# 程序结构

## 命名

25个关键字：

```
break      default       func     interface   select
case       defer         go       map         struct
chan       else          goto     package     switch
const      fallthrough   if       range       type
continue   for           import   return      var
```

30多个预定义的名字：

```
内建常量: true false iota nil

内建类型: int int8 int16 int32 int64
          uint uint8 uint16 uint32 uint64 uintptr
          float32 float64 complex128 complex64
          bool byte rune string error

内建函数: make len cap new append copy close delete
          complex real imag
          panic recover

```

在习惯上，Go语言程序员推荐使用 **驼峰式** 命名，

当名字由几个单词组成时优先使用大小写分隔，

而不是优先用下划线分隔。

因此，在标准库有QuoteRuneToASCII和parseRequestLine这样的函数命名，

但是一般不会用quote_rune_to_ASCII和parse_request_line这样的命名。

**而像ASCII和HTML这样的缩略词则避免使用大小写混合的写法**，它们可能被称为htmlEscape、HTMLEscape或escapeHTML，

但不会是escapeHtml。

## 声明

声明语句定义了程序的各种**实体对象**以及部分或全部**的属性**。

Go语言主要有四种类型的声明语句：

**var、const、type和func，**

**分别对应变量、常量、类型和函数实体对象的声明**

一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。

每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。

包声明语句之后是import语句导入依赖的其它包，

然后是包一级的类型、变量、常量、函数的声明语句，

包一级的各种类型的声明语句的顺序无关紧要

（译注：函数内部的名字则必须先声明之后才能使用）。



一个函数的声明由一个函数名字、

参数列表（由函数的调用者提供参数变量的具体值）、

一个可选的返回值列表和包含函数定义的函数体组成。

如果函数没有返回值，那么返回值列表是省略的。

执行函数从函数的第一个语句开始，

依次顺序执行直到遇到return返回语句，

如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。



var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：

```Go
var 变量名字 类型 = 表达式
```



零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，

因此在Go语言中不存在未初始化的变量。

这个特性可以简化很多代码，

而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。

例如：

```Go
var s string
fmt.Println(s) // ""
```

这段代码将打印一个空字符串，而不是导致错误或产生不可预知的行为。

Go语言程序员应该让一些聚合类型的零值也具有意义，

这样可以保证不管任何类型的变量总是有一个合理有效的零值状态。

也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：

```Go
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```

在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。

### 指针

一个变量对应一个保存了变量对应类型值的内存空间。

普通变量在声明语句创建时被绑定到一个变量名，

比如叫x的变量，

但是还有很多变量始终以表达式方式引入，

例如x[i]或x.f变量。

所有这些表达式一般都是读取一个变量的值，

除非它们是出现在赋值语句的左边，

这种时候是给对应变量赋予一个新的值。

一个指针的值是另一个变量的地址。

一个指针对应变量在内存中的存储位置。

并不是每一个值都会有一个内存地址，

但是对于每一个变量必然有对应的内存地址。

**通过指针，我们可以直接读或更新对应变量的值，**

**而不需要知道该变量的名字（如果变量有名字的话）。**



如果用“var x int”声明语句声明一个x变量，

那么&x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，

指针对应的数据类型是`*int`，

指针被称之为“指向int类型的指针”。

如果指针名字为p，那么可以说“p指针指向变量x”，

或者说“p指针保存了x变量的内存地址”。

同时`*p`表达式对应p指针指向的变量的值。

一般`*p`表达式读取指针指向的变量的值，

这里为int类型的值，同时因为`*p`对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。



```Go
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```

### new函数

另一个创建变量的方法是调用内建的new函数。

表达式new(T)将创建一个T类型的匿名变量，

初始化为T类型的零值，然后返回变量地址，

返回的指针类型为`*T`。

```Go
p := new(int)   // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // "0"
*p = 2          // 设置 int 匿名变量的值为 2
fmt.Println(*p) // "2"
```

用new创建变量和普通变量声明语句方式创建变量没有什么区别，

除了不需要声明一个临时变量的名字外，

我们还可以在表达式中使用new(T)。

**换言之，new函数类似是一种语法糖，而不是一个新的基础概念。**

每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：

```Go
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"
```

new函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活

由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。例如下面的例子：

```Go
func delta(old, new int) int { return new - old }
```

由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的。

## 类型

对于中文汉字，Unicode标志都作为小写字母处理，因此中文的命名默认不能导出；不过国内的用户针对该问题提出了不同的看法，根据RobPike的回复，在Go2中有可能会将中日韩等字符当作大写字母处理。

# 基础数据类型

虽然从底层而言，所有的数据都是由比特组成，

但计算机一般操作的是固定大小的数，如整数、浮点数、比特数组、内存地址等。

进一步将这些数组织在一起，就可表达更多的对象，

例如数据包、像素点、诗歌，甚至其他任何对象。

Go语言提供了丰富的数据组织形式，

这依赖于Go语言内置的数据类型。

这些内置的数据类型，兼顾了硬件的特性和表达复杂数据结构的便捷性。

**Go语言将数据类型分为四类：**

**基础类型、复合类型、引用类型和接口类型。**

本章介绍基础类型，包括：

数字、字符串和布尔型。

复合数据类型——数组（§4.1）和结构体（§4.2）——是通过组合简单类型，来表达更加复杂的数据结构。

引用类型包括指针（§2.3.2）、切片（§4.2)）、字典（§4.3）、函数（§5）、通道（§8），

虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用。

这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝。

我们将在第7章介绍接口类型。

# 复合数据类型

们主要讨论四种类型——数组、slice、map和结构体——

同时在本章的最后，

我们将演示如何使用结构体来解码和编码到对应JSON格式的数据，

并且通过结合使用模板来生成HTML页面。

数组和结构体是聚合类型；

它们的值由许多元素或成员字段的值组成。

数组是由同构的元素组成——每个数组元素都是完全相同的类型——结构体则是由异构的元素组成的。

数组和结构体都是有固定内存大小的数据结构。

相比之下，slice和map则是动态的数据结构，它们将根据需要动态增长。

## 数组

默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。我们也可以使用数组字面值语法用一组值来初始化数组：

```Go
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2]) // "0"
```

在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算。因此，上面q数组的定义可以简化为

```Go
q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"
```

## slice

Slice（切片）代表变长的序列，

序列中每个元素都有相同的类型。

一个slice类型一般写作[]T，

其中T代表slice中元素的类型；

**slice的语法和数组很像，只是没有固定长度而已。**

数组和slice之间有着紧密的联系。

一个slice是一个轻量级的数据结构，

提供了访问数组子序列（或者全部）元素的功能，

而且slice的底层确实引用一个数组对象。

**一个slice由三个部分构成：指针、长度和容量。**

指针指向第一个slice元素对应的底层数组元素的地址，

要注意的是slice的第一个元素并不一定就是数组的第一个元素。

长度对应slice中元素的数目；

长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。

内置的len和cap函数分别返回slice的长度和容量。

数组这样定义

```Go
months := [...]string{1: "January", /* ... */, 12: "December"}
```

```Go
Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2)     // ["April" "May" "June"]
fmt.Println(summer) // ["June" "July" "August"]
```

两个slice都包含了六月份

## map

哈希表是一种巧妙并且实用的数据结构。

它是一个无序的key/value对的集合，

其中所有的key都是不同的，

然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。

在Go语言中，一个map就是一个哈希表的引用，

map类型可以写为map[K]V，

其中K和V分别对应key和value。

map中所有的key都有相同的类型，

所有的value也有着相同的类型，

但是key和value之间可以是不同的数据类型。

其中K对应的key必须是支持==比较运算符的数据类型，

所以map可以通过测试key是否相等来判断是否已经存在。

虽然浮点数类型也是支持相等运算符比较的，

但是将浮点数用做key类型则是一个坏的想法，

正如第三章提到的，最坏的情况是可能出现的NaN和任何浮点数都不相等。

对于V对应的value数据类型则没有任何的限制。

内置的make函数可以创建一个map：

```Go
ages := make(map[string]int) // mapping from strings to ints
```

我们也可以用map字面值的语法创建map，同时还可以指定一些最初的key/value：

```Go
ages := map[string]int{
    "alice":   31,
    "charlie": 34,
}
```

这相当于

```Go
ages := make(map[string]int)
ages["alice"] = 31
ages["charlie"] = 34
```

因此，另一种创建空的map的表达式是`map[string]int{}`。

Map中的元素通过key对应的下标语法访问：

```Go
ages["alice"] = 32
fmt.Println(ages["alice"]) // "32"
```

使用内置的delete函数可以删除元素：

```Go
delete(ages, "alice") // remove element ages["alice"]
```

但是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：

```Go
_ = &ages["bob"] // compile error: cannot take address of map element
```

禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。

## 结构体

结构体是一种聚合的数据类型，

是由零个或多个任意类型的值聚合成的实体。

每个值称为结构体的成员。

用结构体的经典案例是处理公司的员工信息，

每个员工信息包含一个唯一的员工编号、员工的名字、家庭住址、出生日期、工作岗位、薪资、上级领导等等。

所有的这些信息都需要绑定到一个实体中，可以作为一个整体单元被复制，作为函数的参数或返回值，或者是被存储到数组中，等等。

下面两个语句声明了一个叫Employee的命名的结构体类型，并且声明了一个Employee类型的变量dilbert：

```Go
type Employee struct {
    ID        int
    Name      string
    Address   string
    DoB       time.Time
    Position  string
    Salary    int
    ManagerID int
}

var dilbert Employee
```

结构体类型往往是冗长的，因为它的每个成员可能都会占一行。

虽然我们每次都可以重写整个结构体成员，但是重复会令人厌烦。

因此，完整的结构体写法通常只在类型声明语句的地方出现，就像Employee类型声明语句那样。

一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适用于数组。）但是S类型的结构体可以包含`*S`指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。

## json

JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。

在类似的协议中，JSON并不是唯一的一个标准协议。 XML（§7.14）、ASN.1和Google的Protocol Buffers都是类似的协议，并且有各自的特色，

**但是由于简洁性、可读性和流行程度等原因，JSON是应用最广泛的一个。**

## 文本和html模板

一个模板是一个字符串或一个文件，

里面包含了一个或多个由双花括号包含的`{{action}}`对象。

大部分的字符串只是按字面值打印，

但是对于actions部分将触发其它的行为。

每个actions都包含了一个用模板语言书写的表达式，

一个action虽然简短但是可以输出复杂的打印值，

模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流if-else语句和range循环语句，

还有其它实例化模板等诸多特性。下面是一个简单的模板字符串：

```Go
const templ = `{{.TotalCount}} issues:
{{range .Items}}----------------------------------------
Number: {{.Number}}
User:   {{.User.Login}}
Title:  {{.Title | printf "%.64s"}}
Age:    {{.CreatedAt | daysAgo}} days
{{end}}`
```

# 函数

## 函数声明

函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。

```Go
func name(parameter-list) (result-list) {
    body
}
```

函数的类型被称为函数的签名。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。形参和返回值的变量名不影响函数签名，也不影响它们是否可以以省略参数类型的形式表示。

## 递归

函数可以是递归的，这意味着函数可以直接或间接的调用自身。对许多问题而言，递归是一种强有力的技术，例如处理递归的数据结构。

## 多返回值

在Go中，一个函数可以返回多个值。

我们已经在之前例子中看到，

许多标准库中的函数返回2个值，

一个是期望得到的返回值，另一个是函数出错时的错误信息。

下面的例子会展示如何编写多返回值的函数。

下面的程序是findlinks的改进版本。修改后的findlinks可以自己发起HTTP请求，这样我们就不必再运行fetch。因为HTTP请求和解析操作可能会失败，因此findlinks声明了2个返回值：链接列表和错误信息。一般而言，HTML的解析器可以处理HTML页面的错误结点，构造出HTML页面结构，所以解析HTML很少失败。这意味着如果findlinks函数失败了，很可能是由于I/O的错误导致的。

## 错误值

在Go中有一部分函数总是能成功的运行。

比如strings.Contains和strconv.FormatBool函数，

对各种可能的输入都做了良好的处理，使得运行时几乎不会失败，

除非遇到灾难性的、不可预料的情况，比如运行时的内存溢出。

导致这种错误的原因很复杂，难以处理，从错误中恢复的可能性也很低。

对于大部分函数而言，永远无法确保能否成功运行。

这是因为错误的原因超出了程序员的控制。

举个例子，任何进行I/O操作的函数都会面临出现错误的可能，只有没有经验的程序员才会相信读写操作不会失败，即使是简单的读写。

因此，当本该可信的操作出乎意料的失败后，我们必须弄清楚导致失败的原因。

## 函数值

在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。

## 匿名函数

## 可变参数

参数数量可变的函数称为可变参数函数。典型的例子就是fmt.Printf和类似函数。Printf首先接收一个必备的参数，之后接收任意个数的后续参数。

```Go
func sum(vals ...int) int {
    total := 0
    for _, val := range vals {
        total += val
    }
    return total
}
```

sum函数返回任意个int型参数的和。

## deferred函数

你只需要在调用普通函数或方法前加上关键字defer，

就完成了defer所需要的语法。

当执行到该条语句时，函数和参数表达式得到计算，

但直到包含该defer语句的函数执行完毕时，

defer后的函数才会被执行，

不论包含defer语句的函数是通过return正常结束，

还是由于panic导致的异常结束。

你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。

**defer语句经常被用于处理成对的操作，**

**如打开、关闭、连接、断开连接、加锁、释放锁。**

通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。

释放资源的defer应该直接跟在请求资源的语句后。

## panic异常

Go的类型系统会在编译时捕获很多错误，

但有些错误只能在运行时检查，

如数组访问越界、空指针引用等。

这些运行时错误会引起panic异常。

一般而言，当panic异常发生时，程序会中断运行，

并立即执行在该goroutine（可以先理解成线程，在第8章会详细介绍）中被延迟的函数（defer 机制）。

随后，程序崩溃并输出日志信息。

日志信息包括panic value和函数调用的堆栈跟踪信息。

panic value通常是某种错误信息。

对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。

通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据。

因此，在我们填写问题报告时，一般会将panic异常和日志信息一并记录。

不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用panic。比如，当程序到达了某条逻辑上不可能到达的路径：

## recover捕获异常

通常来说，不应该对panic异常做任何处理，

但有时，也许我们可以从异常中恢复，

至少我们可以在程序崩溃前，做一些操作。

举个例子，当web服务器遇到不可预料的严重问题时，

在崩溃前应该将所有的连接关闭；

如果不做任何处理，会使得客户端一直处于等待状态。

如果web服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。

# 方法

从90年代早期开始，面向对象编程（OOP）就成为了称霸工程界和教育界的编程范式，

所以之后几乎所有大规模被应用的语言都包含了对OOP的支持，

go语言也不例外。

尽管没有被大众所接受的明确的OOP的定义，

从我们的理解来讲，一个对象其实也就是一个简单的值或者一个变量，在这个对象中会包含一些方法，而一个方法则是一个和特殊类型关联的函数。

一个面向对象的程序会用方法来表达其属性和对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。

## 方法声明

**在函数声明时，在其名字之前放上一个变量，即是一个方法。**

这个附加的参数会将该函数附加到这种类型上，

即相当于为这种类型定义了一个独占的方法。

```
type Point struct{ X, Y float64 }
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
```

上面这个Distance就是属于Point的方法了。

**上面的代码里那个附加的参数p，叫做方法的接收器（receiver）**，早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。

**在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；****我们可以任意的选择接收器的名字。**

由于接收器的名字经常会被使用到，

所以保持其在方法间传递时的一致性和简短性是不错的主意。

**这里的建议是可以使用其类型的第一个字母，比如这里使用了Point的首字母p。**

## 基于指针对象的方法

当调用一个函数时，会对其每一个参数值进行拷贝，

如果一个函数需要更新一个变量，

或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，

这种情况下我们就需要用到指针了。

对应到我们这里用来更新接收器的对象的方法，当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法，如下：

```go
func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}
```

这个方法的名字是`(*Point).ScaleBy`。这里的括号是必须的；没有括号的话这个表达式可能会被理解为`*(Point.ScaleBy)`。

在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。我们在这里打破了这个约定只是为了展示一下两种方法的异同而已。

想要调用指针类型方法`(*Point).ScaleBy`，只要提供一个Point类型的指针即可，像下面这样。

```go
r := &Point{1, 2}
r.ScaleBy(2)
fmt.Println(*r) // "{2, 4}"
```

## 通过嵌入一个结构体来扩展类型

就是结构体包含结构体。

```go
import "image/color"

type Point struct{ X, Y float64 }

type ColoredPoint struct {
    Point
    Color color.RGBA
}
```

我们完全可以将ColoredPoint定义为一个有三个字段的struct，

但是我们却将Point这个类型嵌入到ColoredPoint来提供X和Y这两个字段。

Point类的方法也被引入了ColoredPoint。用这种方式，内嵌可以使我们定义字段特别多的复杂类型，我们可以将字段先按小类型分组，然后定义小类型的方法，之后再把它们组合起来。

# 接口

接口类型是对其它类型行为的抽象和概括；

因为接口类型不会和特定的实现细节绑定在一起，

通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。

很多面向对象的语言都有相似的接口概念，

但Go语言中接口类型的独特之处在于它是满足隐式实现的。

也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；

简单地拥有一些必需的方法就足够了。

这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；

当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。