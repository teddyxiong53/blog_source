---
title: XR872（1）
date: 2020-06-27 14:20:51
tags:
	- 嵌入式

---

1

芯片是芯之联的。成立于2015年，在深圳南山。是全志的子公司。

2019.10 - 发布高性能智能WiFi MCU XR872

这里是评估板的手册。

https://xradiotech-developer-guide.readthedocs.io/zh/latest/download/2.%E4%BA%A7%E5%93%81%E6%8C%87%E5%AF%BC/XR872_EVB_User_Guide_V1.0.pdf

这个芯片是专注音频和图传的。

芯片架构是Cortex M4架构。主频384MHz。内置无线。

52个引脚的封装。

416K的ram，160K的内置rom。

评估板带了SIP 4M的PSRAM

4M的spi flash。

**内置的audio codec，支持单路mic输入，和单路的line out输出。**

**支持line in输入，用来做回采通路。**

先下载xr872的官方sdk，下载工具链，编译看看过程。

对比这一套跟stm32的区别。

主要看是在哪里封装寄存器的操作。

对freertos的接口进行了封装，接口比freertos的要清晰一些。

官方sdk下载地址：

https://github.com/XradioTech/xradio-skylark-sdk

工具链使用gcc。在Linux下进行开发。也可以用cygwin的方式。

目录：

```
├── bin 这里放的是一些bin文件。例如boot。
├── ChangeLog.md
├── chip.mk
├── config.mk
├── configure.sh 这个生成.config文件，就2个选项，一个soc的类型，一个晶振的频率。
├── gcc.mk 
├── include
├── lib  一些静态库。芯片的寄存器操作都已经封装到这里面了。这些还是src里的内容编译出来的。没有必要放在git上。估计他们错误上传了。
├── project
├── README.md
├── src  
└── tools 一些windows图形界面工具，进行烧录等操作。
```

寄存器的地址定义在include/driver/chip/chip.h里。

```
#define PWM_BASE            (PERIPH_BASE + 0x00042800)
#define I2S_BASE            (PERIPH_BASE + 0x00042C00)
#define GPADC_BASE          (PERIPH_BASE + 0x00043000)
```

相当于是一个Cortex M4的核心，跟一些无线电路进行了封装成一个新的芯片。

比起自己用stm32的通用芯片加外围无线电路的方式，集成度更高一些。

成本应该也要低一些。

对芯片的魔改没有很多。

软件的整体运行方式，还是很常规的单片机的方式。

没有像炬力那么神奇的搞法。也好。这样比较通用。调试难度没有那么大。

以examples/audio_record_and_play这个例子来分析。

```
int main(void)
{
	platform_init();

	printf("audio play + record start.\n");

	check_sample_rate(SAMPLE_RATE_OF_RECORD, SAMPLE_RATE_OF_PLAY);

	audio_play_start();

	audio_record_start();

	return 0;
}
```

为什么main函数没有阻塞呢？正常来说，这样就直接退出了。

那么就可能是修改了main函数的行为。

找一下它的命令行的实现方式。

在demo/hello_demo里。

这里的main函数就阻塞死循环了。这个阻塞的死循环不是必须的。因为audio_demo里，就没有阻塞死循环。

```
int main(void)
{
	platform_init();

	while (1) {
		OS_Sleep(10);
		printf("Hello world! @ %u sec\n", OS_GetTicks());
	}
	return 0;
}
```

在project/common/startup/gcc/startup.s里。这里死循环了。

```
  bl   _start # 这里会调用到main

LoopForever:
  b LoopForever
```

我还是有一点疑问，这个操作为什么不是把cpu占满100%呢？

应该是这样：cpu的占用率，是系统的统计行为，它把这个空转统计为空闲行为。

本质上，cpu一直在干活。

在startup/gcc目录下，

```
retarget.c  
retarget_main.c  
retarget_stdout.c
startup.s
```

仔细看上面这几个文件，可以看到用gcc的--wrap特性，把main函数替换为了`__wrap_main`。

```
int __wrap_main(void)
{
	static const GPIO_GlobalInitParam gpio_param = {
		.portIRQUsed  = PRJCONF_GPIO_PORT_IRQ_USED,
		.portPmBackup = PRJCONF_GPIO_PORT_PM_BACKUP
	};

	SystemCoreClockUpdate();
	timeofday_restore();
	HAL_GlobalInit();
	HAL_GPIO_GlobalInit(&gpio_param);
#if PRJCONF_SWD_EN
	HAL_SWD_Init();
#endif
#if PRJCONF_UART_EN
	stdout_init();
#endif
	main_task_start();
	return -1;
}
```

然后靠main_task_start里创建一个线程，去调用真正的main函数（用户实现）。

```
static void main_task(void *arg)
{
	__real_main();//这个就调用到用户的main函数了。所以可以阻塞，也可以不阻塞。没有关系。
	OS_ThreadDelete(&g_main_thread);
}

void main_task_start(void)
{
	if (OS_ThreadCreate(&g_main_thread,
	                    "main",
	                    main_task,
	                    NULL,
	                    PRJCONF_MAIN_THREAD_PRIO,
	                    PRJCONF_MAIN_THREAD_STACK_SIZE) != OS_OK) {
		printf("[ERR] create main task failed\n");
	}

	OS_ThreadStartScheduler();//这里是死循环阻塞，就是freertos的任务调度。
```

看看用户的main函数，需要做的事情有哪些？看hello_demo的main.c就好

```
int main(void)
{
	platform_init();

	while (1) {
		OS_Sleep(10);
		printf("Hello world! @ %u sec\n", OS_GetTicks());
	}
	return 0;
}
```

只有一个必须调用的函数：platform_init里就完成了所有必要的初始化操作。

```
platform_init
	platform_init_level0
		pm_start 电源管理。
		HAL_Flash_Init(0) 初始化flash
```



除了xip执行，还可以怎么执行？ram执行吗？太占内存了吧。

分析一下编译Makefile的层次关系，以及配置方法。

还是以hello_demo作为分析对象。

在hello_demo/gcc目录下，只有2个文件：Makefile和localconfig.mk。

Makefile内容：

```
首先包含localconfig.mk
	这个里面默认就2个配置，配置以__CONFIG_XX这种格式。
	export __CONFIG_XIP := y
	export __CONFIG_OTA := y
	所以默认是xip方式的。这个够用了。
include $(ROOT_PATH)/gcc.mk
	定义工具链。
	include $(ROOT_PATH)/config.mk
		include $(ROOT_PATH)/chip.mk
			-include $(ROOT_PATH)/.config
				这个里面就配置了芯片类型和晶振频率。
				__CONFIG_CHIP_TYPE ?= xr872
				__CONFIG_HOSC_TYPE ?= 40
			如果是872，则版本为2：
			__CONFIG_CHIP_ARCH_VER := 2
			
         定义了对标准库的wrap开关。
         允许对malloc进行跟踪。
         默认使用8.2.3的freertos版本。
         lwip默认用1.4.1的。
         是否支持wlan。
         __CONFIG_PSRAM 这个默认关闭。
         默认关闭bootloader。
include $(PRJ_MAKE_RULES)
	这个就是执行编译动作的。
```



看看编译出来的镜像文件。用工具读取出来是这样。

app和app_xip有什么区别？

![1593246484133](../images/random_name/1593246484133.png)

看project下的文件。

![1593246656251](../images/random_name/1593246656251.png)



先看看官网的文档。

https://xradiotech-developer-guide.readthedocs.io/zh/latest/zh_CN/get-started/

*XRADIOTECH的MCU平台仅支持串口打印信息辅助调试，暂不支持Keil，IAR等IDE集成开发环境*



# 链接脚本

从官网资料描述，链接脚本同时使用了sram、flash这多个段，靠链接脚本根据需要把不同的部分放在不同的位置里。

修改需要注意这些约束条件：

1、在中断里执行的代码和数据，不能位于.xip里。

2、没有指定到xip和psram的，默认是链接到sram里。



# 讯飞XR872套件

软件上功能包含语音唤醒+iFLYOS云端操作系统+离线命令词。

单麦降噪唤醒引擎，通过新一代神经网络降噪、去混响及 AGC 算法对拾取音频进行处理，实现普通环境下 3 米远场语音唤醒成功率 90%以上，近场语音唤醒成功率 95%以上，唤醒响应时间在毫秒级。

内存：SRAM 416KB

闪存：外挂8MB

重点看一下这个文档。

https://cdn.iflyos.cn/docs/xr872/development_manual.pdf

参考这个文档来把环境搭好。先编译出来跑起来。

金源德默认的用cygwin环境的，我刚好有cygwin的环境，也就按照他们的要求来。不节外生枝。

1、修改工具链路径。xradio-skylark-sdk-xradio-skylark-sdk-1.0.2/gcc.mk里。

2、

```
cd jyd_evm/gcc
make
make image
```

这个工程的localconfig.mk

```
export __CONFIG_XIP := y
export __CONFIG_OTA := y
export __CONFIG_PSRAM := y
export __CONFIG_XPLAYER := y
```

有psram。

它这一套可以放在xr872的sdk的外面，就是jyd_evm/gcc/Makefile里：

```
ROOT_PATH := ../../xradio-skylark-sdk-xradio-skylark-sdk-1.0.2
```



还需要搞清楚的是spi flash被用来做了什么。

当前看生成的image文件，是2M。这个在片内flash是放不下的。

那么只能放在spi flash里了。

我估计不完全是，有些xip的，应该还是烧录到片内flash的。

另外的部分，可能是从spi flash读取到psram里执行的。

所以还是看链接脚本。

对于XR872，`__CONFIG_ROM`默认是打开的。

```
# rom
ifeq ($(__CONFIG_CHIP_ARCH_VER), 1)
  __CONFIG_ROM ?= n
else
  __CONFIG_ROM ?= y
endif
```

所以下面的代码是打开的：

```
#if (defined(__CONFIG_ROM))
INCLUDE rom_symbol.ld
#endif
```

rom_symbol.ld里的内容，应该是动态生成的。是把所有的符号的位置列出来了。

```
abs = 0x20e2d;
ADC_DisableFifoDataDRQ = 0x8625;
ADC_DisableFifoDataIRQ = 0x8605;
ADC_EnableFifoDataDRQ = 0x8615;
__adddf3 = 0x25cad;
__aeabi_cdcmpeq = 0x264d1;
//...
```



sram在2M的位置。

rom在4M的位置。

psram在20M的位置，长度是4M。

xip里放的，大部分是应用库，例如网络、媒体。

以及rodata。

```
    .xip :
    {
        . = ALIGN(4);
        __xip_start__ = .;

        /* MUST not put IRQ handler/callback in .xip section */
        *libmp3.a: (.text .text.* .rodata .rodata.*)
        *libaac.a: (.text .text.* .rodata .rodata.*)
```

在compiler.h里。

```
#define __xip_text      __attribute__((section (".xip_text")))
#define __xip_rodata    __attribute__((section (".xip_rodata")))

#define __nonxip_text   __attribute__((section (".nonxip_text")))
#define __nonxip_rodata __attribute__((section (".nonxip_rodata")))
#define __nonxip_data   __attribute__((section (".nonxip_data")))
#define __nonxip_bss    __attribute__((section (".nonxip_bss")))

#define __psram_text    __attribute__((section (".psram_text")))
#define __psram_rodata  __attribute__((section (".psram_rodata")))
#define __psram_data    __attribute__((section (".psram_data")))
#define __psram_bss     __attribute__((section (".psram_bss")))

```

大部分的data，都是放在psram里。

```
    .psram_data :
    {
        . = ALIGN(4);
        __psram_data_start__ = .;
        *libmp3.a: ( .data .data.* vtable )
        *libaac.a: ( .data .data.* vtable )
        *libwav.a: ( .data .data.* vtable )
```

bss也是：

````
    .psram_bss :
    {
        . = ALIGN(4);
        __psram_bss_start__ = .;
        *libmp3.a: ( .bss .bss.* COMMON )
        *libaac.a: ( .bss .bss.* COMMON )
        *libwav.a: ( .bss .bss.* COMMON )
````

-R表示移除，hello_demo.bin就是移除xip段的结果。

而-j表示只保留，hello_demo_xip.bin就是只保留了xip段的结果。

```
~/tools/gcc-arm-none-eabi-4_9-2015q2/bin/arm-none-eabi-objcopy -O binary -R .xip   hello_demo.axf hello_demo.bin
~/tools/gcc-arm-none-eabi-4_9-2015q2/bin/arm-none-eabi-objcopy -O binary -j .xip hello_demo.axf hello_demo_xip.bin
~/tools/gcc-arm-none-eabi-4_9-2015q2/bin/arm-none-eabi-size hello_demo.axf
```

现在有个很大的疑问：HAL_CCM_BusDisablePeriphClock这个在哪里定义？

搜索到的是在rom_bin目录下，但是通过在文件里加错误，可以看到并没有编译对应的文件。

```
void HAL_GlobalInit(void)
{
	HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_DEFAULT);
	HAL_CCM_BusDisablePeriphClock(~CCM->BUS_PERIPH_RST_CTRL);

}
```

在rom_symbol.ld里，有罗列出来。

本质上还是对链接机制理解不够深入。

本质上是把一个提前设置好的rom_symbol.ld文件读取，往里面加一点东西。

```
arm-none-eabi-gcc -E -P -CC -D__CONFIG_CHIP_XR872 rom_symbol.ld - < ../../../../lib/xradio_v2/rom_symbol.ld
```

就是往里面加宏定义。

![1593313664811](../images/random_name/1593313664811.png)

那么问题来了。提前预设的这个rom_symbol.ld文件，依据是什么？

我如果要修改，应该怎么做？

分析一下里面的内容。

里面的内容是src/rom/rom_bin下面的代码编译得到的结果。这个不需要我们进行编译。

看地址是在哪里。

```
abs = 0x20e2d;
ADC_DisableFifoDataDRQ = 0x8625;
ADC_DisableFifoDataIRQ = 0x8605;
ADC_EnableFifoDataDRQ = 0x8615;
__adddf3 = 0x25cad;
__aeabi_cdcmpeq = 0x264d1;
```

![1593314094074](../images/random_name/1593314094074.png)

所谓的rom，就是芯片内部固化了的寄存器操作函数。

这些我们不用改，也改不了。

给我们代码就是给我看看里面做了一些什么。

这个也好。

另外os的也固化到里面了。

总共不到1000个符号。



尽量不要改动project目录之外的内容。

```
一般情况下，用户只需要修改以下文件来实现工程配置定义： * project/[prj]/gcc/Makefile * project/[prj]/gcc/localconfig.mk（覆盖“config.mk”中的默认配置） * project/[prj]/prj_config.h（覆盖“project/common/prj_conf_opt.h”中的默认配置）
```

```
修改“project/[prj]/gcc/localconfig.mk”文件后，必须先执行“make build_clean”清除中间文件后，才可执行“make build”进行代码编译和镜像创建,否则可能出现配置错误或冲突
```

另外，board的也需要修改一些，根据板子的不同，需要修改pinmux的配置。

做法是：

```
# 忽略板端的标准的
DIRS_IGNORE += $(ROOT_PATH)/project/common/board/%
# 定义自己的
DIRS += $(PRJ_BOARD)
```

# 运行测试

就用XF7266的板子。

运行hello_demo。

烧录使用300 0000的波特率。烧录需要1分钟左右。

烧录后可以正常运行。我把串口拔插了一下。这个具体怎样才能正常看到打印，还不确定。

至少在我重新拔插之前，没有看到打印。



# 启动模式

启动脚本没有什么特别的。

就是调用了_start。在之前没有做什么特别的操作。



# XF7266电路分析

BK3266是一个低功耗，高度集成的蓝牙系统芯片(SoC)音频设备。它集成了高性能的蓝牙射频收发器、功能丰富的基带处理器、闪存控制器、多个模拟和数字外围设备，**以及一个包含蓝牙软件栈的系统**。播放音频、语音和SPP配置文件。

基于缓存的体系结构使SIP8M闪存设备具有完全的可编程性，并可用于控制和多媒体混合应用程序。

硬件实现均衡器卸载单片机，使芯片成为低功耗耳机的理想应用轻松学习英语。

# 讯飞云端对接

先看看具体做了哪些交互。

嵌入式协议（Embedded iFLYOS Voice Service， 简称EVS）是一个相对IVS更简单的协议，为厂商接入提供方便，降低设备运行要求，本协议采取websocket进行通讯。

`iFLYOS Voice Service`(简称`IVS`)协议是iFLYOS服务端与设备端之间的通讯协议，是一套把iFLYOS的智能语音交互能力向智能硬件设备开放的API。

IVS协议由指令、事件、端状态三个部分组成。

这个从名字就可以看出是在模仿AVS的。按照AVS的来理解就好了。

目前IVS服务提供基于HTTP2的传输层协议，详细内容阅读[传输层协议](https://doc.iflyos.cn/device/transfer_protocol.html)文档。

说明 IVS SDK 已停止迭代，新设备若需要接入，请使用[EVS API](https://doc.iflyos.cn/device/evs/)进行接入。若需要SDK或公版，请联系商务。

这个思路就是：先抄AVS的，后面自己优化一下。

所以现在是时延EVS。EVS是使用websocket协议的，而不是像AVS那样使用HTTP2协议。

这里是Linux下的demo。是在树莓派上测试运行的。

https://github.com/iFLYOS-OPEN/SDK-EVS-Linux

业务逻辑用js写的。

# OS_XX封装接口

文件不多，接口也不多，但是够用了。

os_common.h

```
定义了2个枚举。
2个类型。
枚举：
	OS_Priority：任务优先级。
	OS_Status：5种错误。
	
类型：
typedef void * OS_Handle_t;
typedef uint32_t OS_Time_t;
```

os_errno.h

```
2个接口：
int OS_GetErrno(void);
void OS_SetErrno(int err);
```

os_mutex.h

```
OS_Status OS_MutexCreate(OS_Mutex_t *mutex);
OS_Status OS_MutexDelete(OS_Mutex_t *mutex);
OS_Status OS_MutexLock(OS_Mutex_t *mutex, OS_Time_t waitMS);
OS_Status OS_MutexUnlock(OS_Mutex_t *mutex);
```

os_queue.h

```
OS_Status OS_QueueCreate(OS_Queue_t *queue, uint32_t queueLen, uint32_t itemSize);
OS_Status OS_QueueDelete(OS_Queue_t *queue);
OS_Status OS_QueueSend(OS_Queue_t *queue, const void *item, OS_Time_t waitMS);
OS_Status OS_QueueReceive(OS_Queue_t *queue, void *item, OS_Time_t waitMS);
```

os_semaphore.h

```
OS_Status OS_SemaphoreCreate(OS_Semaphore_t *sem, uint32_t initCount, uint32_t maxCount);
OS_Status OS_SemaphoreCreateBinary(OS_Semaphore_t *sem);
OS_Status OS_SemaphoreDelete(OS_Semaphore_t *sem);
OS_Status OS_SemaphoreWait(OS_Semaphore_t *sem, OS_Time_t waitMS);
OS_Status OS_SemaphoreRelease(OS_Semaphore_t *sem);
```

os_thread.h

```
OS_ThreadCreate
OS_ThreadDelete
OS_ThreadSleep
OS_ThreadYield
OS_ThreadStartScheduler
OS_ThreadSuspendScheduler
OS_ThreadResumeScheduler
OS_ThreadIsSchedulerRunning

```

os_time.h

```
OS_GetTime 这个是获取开机以来的描述。
OS_GetTicks  开机以来的tick数。
OS_MSleep
OS_Sleep
uint32_t OS_Rand32(void);
	假的随机数，实际上是用当前时间值计算得到。
```

os_timer.h

```
OS_TimerCreate
OS_TimerDelete
OS_TimerStart
OS_TimerChangePeriod
OS_TimerStopOS_TimerIsActive
OS_TimerIsActive
```

# 第三方库的适配

看到有不少的第三方库被集成进行，看看这些库进行了哪些修改。

以udhcp的为例。对比原始的代码跟xr872里集成的代码。

基本上是在这个基础上进行了大量修改。

可以看到还有不少的调试代码。

nopoll是一个websocket库。

building pure WebSocket solutions or to provide WebSocket support to existing TCP oriented applications.

目的是给tcp应用增加websocket支持。



# printf的实现

```
# wrap standard input/output/error functions
__CONFIG_LIBC_WRAP_STDIO ?= y
```

这个宏默认的打开的。

看retarget_stdout.c内容。

在src/libc/wrap_stdio.c里。

```
int __wrap_printf(const char *format, ...)
{
	int len;
	va_list ap;

	stdout_mutex_lock();

	if (s_stdio_write == NULL) {
		len = 0;
	} else {
		va_start(ap, format);
		len = vsnprintf(s_stdout_buf, WRAP_STDOUT_BUF_SIZE, format, ap);
		va_end(ap);
		len = stdio_wrap_write(s_stdout_buf, len, WRAP_STDOUT_BUF_SIZE - 1);
	}

	stdout_mutex_unlock();

	return len;
}
```

s_stdio_write 这个是注册进来的写串口操作。

```
static int stdout_write(const char *buf, int len)
{	
	return board_uart_write(g_stdout_uart_id, buf, len);
}
static __inline int32_t board_uart_write(UART_ID uart_id, const char *buf, int len)
{
	return HAL_UART_Transmit_Poll(uart_id, (uint8_t *)buf, len);
}
```





# sys_ctrl

这个是framework里的一部分。

在project目录下。

sys_ctrl目录下，一共6个文件。

```
container.c  
event_queue.c  
looper.c  
observer.c  
publisher.c  
sys_ctrl.c
	这个是对外的接口。上面那些文件，都是为了实现这个文件里的功能。
	主要就是事件机制。
```

```
g_sys_queue
	系统事件队列。
	
```

一个event是一个32位的数。高16位是事件类型，低16位是子类型。

# example

example和demo的区别：

example不能直接编译通过。

可以通过把example下的内容拷贝到hello_demo下面进行编译。

现在因为电路板跟官方的不同，所以只能测试通用性质的内容。

## SmartConfig

这个测试ok。



# 烧录问题

有时候会烧录不了。

正确的烧录顺序应该是：先保证串口是接好的，点击烧录，然后再上电。这个烧录应该是靠内置的bootrom来完成串口通信。



烧录固件首先要保证设备进入到升级模式。

设备进入升级模式的方法有：

1、没有烧录过固件的设备（也就是flash里没有有效内容），会自动进入到升级模式。

2、在设备启动后，给设备发送一条upgrade命令。点击烧录工具的按钮，也是给设备发送了一条upgrade命令。

3、把PB02/PB03这2个gpio同时接地，然后上电，就可以进入到升级模式。

4、短接flash的MISO引脚到地，这个其实是模拟了第一种方法。

# 存储

目前sdk支持的存储类型有4种。

SRAM：上电就能用。

PSRAM：需要在PSRAM驱动初始化完成后才能用。XR872才有。

ROM：上电就能用。只有XR872才有。

XIP：需要在XIP驱动初始化完成后才能用。比ROM慢，而且不能存放中断相关的代码。

我之前还以为xip是指在rom里片内执行的行为呢。

项目开启xip功能的，需要关注3个配置文件：

localconfig.mk：这里定义变量打开XIP

appos.ld：XIP内容的分布。

image.cfg：确定xip的bin文件会被初始化到XIP空间位置。



XIP的技术是基于flash特性而设计的。

工程开启xip支持后，就会影响到编译、链接、启动这些流程。

XIP的初始化过程主要分为3大步骤：

1、flash ctrl初始化。电源配置，时钟配置。

2、flash chip初始化。xip类型适配，xip内部寄存器初始化。

3、xip内容初始化。把app_xip.bin拷贝到指定的位置。



## 提高性能

nor flash的内容如果在cache里有缓存，那就可以直接从cache里读取数据。



## 布局

image的大小是4M左右。

```
#define PRJCONF_IMG_MAX_SIZE            ((4096 - 4-64) * 1024)
```

sysinfo存放在4M的最后4K的位置后。

```
#define PRJCONF_SYSINFO_SIZE            (4 * 1024)
```

sysinfo里存放的应该就是配网信息。token等。



# ota

ota policy

默认是ping pong模式。

```
# ota policy, choose ota mode
#   - 0x00: ping-pong mode
#   - 0x01: image compression mode
__CONFIG_OTA_POLICY ?= 0x00
```



官方的参考板子

使用AC107来做双mic的输入芯片。

如果是单mic的，则可以不加外围音频芯片。XR872本身就可以完成音频输入和输出。

![1593409688824](../images/random_name/1593409688824.png)





参考资料

1、官网资料

资料很全。多看看。

https://xradiotech-developer-guide.readthedocs.io/zh/latest/zh_CN/get-started/

2、XR872开发套件使用指南

https://doc.iflyos.cn/dev_kits/xr872.html#xr872%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6%E6%9E%84%E6%88%90

