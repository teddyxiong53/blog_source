---
title: 《The Way to Go》读书笔记
date: 2020-11-16 09:41:17
tags:
	- go语言

---

1

# 1.1 起源与发展

Go 语言起源 2007 年，并于 2009 年正式对外发布。

它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，

即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。

该项目的三位领导者均是著名的 IT 工程师：

Robert Griesemer，参与开发 Java HotSpot 虚拟机；

Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言；

Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。

自 2008 年 1 月起，Ken Thompson 就开始研发一款以 C 语言为目标结果的编译器来拓展 Go 语言的设计思想。

**这是一个由计算机领域 “发明之父” 所组成的黄金团队，他们对系统编程语言，操作系统和并行都有着非常深刻的见解**

在 2008 年年中，Go 语言的设计工作接近尾声，一些员工开始以全职工作状态投入到这个项目的编译器和运行实现上。

Ian Lance Taylor 也加入到了开发团队中，并于 2008 年 5 月创建了一个 gcc 前端。

Russ Cox 加入开发团队后着手语言和类库方面的开发，也就是 Go 语言的标准包。在 2009 年 10 月 30 日，Rob Pike 以 Google Techtalk 的形式第一次向人们宣告了 Go 语言的存在。

直到 2009 年 11 月 10 日，开发团队将 Go 语言项目以 BSD-style 授权（完全开源）正式公布了 Linux 和 Mac OS X 平台上的版本。Hector Chu 于同年 11 月 22 日公布了 Windows 版本。

### 时间轴：

- 2007 年 9 月 21 日：雏形设计
- 2009 年 11 月 10日：首次公开发布
- 2010 年 1 月 8 日：当选 2009 年年度语言
- 2010 年 5 月：谷歌投入使用
- 2011 年 5 月 5 日：Google App Engine 支持 Go 语言

Go 通过以下的 Logo 来展示它的速度，并以囊地鼠（Gopher）作为它的吉祥物。

# 1.2 语言的主要特性与发展的环境和影响因素

正如 “21 世纪的 C 语言” 这句话所说，Go 语言并不是凭空而造的，

而是和 C++、Java 和 C# 一样属于 C 系。

不仅如此，设计者们还汲取了其它编程语言的精粹部分融入到 Go 语言当中。

在声明和包的设计方面，Go 语言受到 Pascal、Modula 和 Oberon 系语言的影响；

在并发原理的设计上，Go 语言从同样受到 Tony Hoare 的 CSP（通信序列进程 *Communicating Sequential Processes*）理论影响的 Limbo 和 Newsqueak 的实践中借鉴了一些经验，

并使用了和 Erlang 类似的机制。

这是一门完全开源的编程语言，因为它使用 BSD 授权许可，所以任何人都可以进行商业软件的开发而不需要支付任何费用。

尽管为了能够让目前主流的开发者们能够对 Go 语言中的类 C 语言的语法感到非常亲切而易于转型，

但是它在极大程度上简化了这些语法，

使得它们比 C/C++ 的语法更加简洁和干净。

同时，Go 语言也拥有一些动态语言的特性，

这使得使用 Python 和 Ruby 的开发者们在使用 Go 语言的时候感觉非常容易上手。

## 为什么要创造一门编程语言

- C/C++ 的发展速度无法跟上计算机发展的脚步，十多年来也没有出现一门与时代相符的主流系统编程语言，因此人们需要一门新的系统编程语言来弥补这个空缺，尤其是在计算机信息时代。
- 相比计算机性能的提升，软件开发领域不被认为发展得足够快或者比硬件发展得更加成功（有许多项目均以失败告终），同时应用程序的体积始终在不断地扩大，这就迫切地需要一门具备更高层次概念的低级语言来突破现状。
- 在 Go 语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go 语言在这 3 个条件之间做到了最佳的平衡：快速编译，高效执行，易于开发。

## Go 语言的发展目标

Go 语言的**主要目标是将静态语言的安全性和高效性与动态语言的易开发性进行有机结合**，达到完美平衡，

从而使编程变得更加有乐趣，而不是在艰难抉择中痛苦前行。

因此，Go 语言是一门**类型安全和内存安全**的编程语言。

虽然 Go 语言中**仍有指针的存在，但并不允许进行指针运算。**

Go 语言的另一个目标是对于**网络通信、并发和并行编程的极佳支持**，

从而更好地利用大量的分布式和多核的计算机，这一点对于谷歌内部的使用来说就非常重要了。

设计者通过 **goroutine 这种轻量级线程**的概念来实现这个目标，

**然后通过 channel 来实现各个 goroutine 之间的通信。**

他们实现了分段栈增长和 goroutine 在线程基础上多路复用技术的自动化。

这个特性显然是 Go 语言最强有力的部分，不仅支持了日益重要的多核与多处理器计算机，也弥补了现存编程语言在这方面所存在的不足。

Go 语言中另一个**非常重要的特性就是它的构建速度**（编译和链接到机器代码的速度），一般情况下构建一个程序的时间只需要数百毫秒到几秒。

作为大量使用 C++ 来构建基础设施的谷歌来说，无疑从根本上摆脱了 C++ 在构建速度上非常不理想的噩梦。这不仅极大地提升了开发者的生产力，同时也使得软件开发过程中的代码测试环节更加紧凑，而不必浪费大量的时间在等待程序的构建上。

依赖管理是现今软件开发的一个重要组成部分，但是 C 语言中“头文件”的概念却导致越来越多因为依赖关系而使得构建一个大型的项目需要长达几个小时的时间。人们越来越需要一门具有严格的、简洁的依赖关系分析系统从而能够快速编译的编程语言。**这正是 Go 语言采用包模型的根本原因，这个模型通过严格的依赖关系检查机制来加快程序构建的速度，提供了非常好的可量测性。**

**整个 Go 语言标准库的编译时间一般都在 20 秒以内，**其它的常规项目也只需要半秒钟的时间来完成编译工作。这种闪电般的编译速度甚至比编译 C 语言或者 Fortran 更加快，使得编译这一环节不再成为在软件开发中困扰开发人员的问题。在这之前，动态语言将快速编译作为自身的一大亮点，像 C++ 那样的静态语言一般都有非常漫长的编译和链接工作。而同样作为静态语言的 Go 语言，通过自身优良的构建机制，成功地去除了这个弊端，使得程序的构建过程变得微不足道，拥有了像脚本语言和动态语言那样的高效开发的能力。

另外，**Go 语言在执行速度方面也可以与 C/C++ 相提并论。**

由于内存问题（通常称为内存泄漏）长期以来一直伴随着 C++ 的开发者们，Go 语言的设计者们认为内存管理不应该是开发人员所需要考虑的问题。因此尽管 Go 语言像其它静态语言一样执行本地代码，**但它依旧运行在某种意义上的虚拟机**，以此来实现高效快速的垃圾回收（使用了一个简单的标记-清除算法）。

尽管垃圾回收并不容易实现，但考虑这将是未来并发应用程序发展的一个重要组成部分，Go 语言的设计者们还是完成了这项艰难的任务。

Go 语言还能够在运行时进行反射相关的操作。

使用 `go install` 能够很轻松地对第三方包进行部署。

此外，**Go 语言还支持调用由 C 语言编写的海量库文件**（第 3.9 节），从而能够将过去开发的软件进行快速迁移。

## 指导设计原则

Go语言通过减少关键字的数量（25 个）来简化编码过程中的混乱和复杂度。干净、整齐和简洁的语法也能够提高程序的编译速度，**因为这些关键字在编译过程中少到甚至不需要符号表来协助解析**。

这些方面的工作都是为了减少编码的工作量，甚至可以与 Java 的简化程度相比较。

Go 语言有一种极简抽象艺术家的感觉，因为**它只提供了一到两种方法来解决某个问题**，这使得开发者们的代码都非常容易阅读和理解。众所周知，代码的可读性是软件工程里最重要的一部分（ **译者注：代码是写给人看的，不是写给机器看的** ）。

这些设计理念没有建立其它概念之上，所以并不会因为牵扯到一些概念而将某个概念复杂化，他们之间是相互独立的。

Go 语言有一套完整的编码规范，你可以在 [Go 语言编码规范](http://golang.org/doc/go_spec.html) 页面进行查看。

它不像 Ruby 那样通过实现过程来定义编码规范。作为一门具有明确编码规范的语言，它要求可以采用不同的编译器如 gc 和 gccgo（第 2.1 节）进行编译工作，这对语言本身拥有更好的编码规范起到很大帮助。

[LALR](http://en.wikipedia.org/wiki/LALR_parser) 是 Go 语言的语法标准，你也可以在 [`src/cmd/internal/gc/go.y`](https://github.com/golang/go/blob/master/src%2Fcmd%2Finternal%2Fgc%2Fgo.y) 中查看到，这种语法标准在编译时不需要符号表来协助解析。



## 语言的特性

Go 语言从本质上（程序和结构方面）来实现并发编程。

因为 Go 语言**没有类和继承的概念**，所以它和 Java 或 C++ 看起来并不相同。**但是它通过接口（interface）的概念来实现多态性**。Go 语言有一个清晰易懂的**轻量级类型系统**，在类型之间也没有层级之说。因此可以说这是一门**混合型的语言**。

在传统的面向对象语言中，使用面向对象编程技术显得非常臃肿，它们总是通过复杂的模式来构建庞大的类型层级，这违背了编程语言应该提升生产力的宗旨。

**函数是 Go 语言中的基本构件**，它们的使用方法非常灵活。在第六章，我们会看到 Go 语言在函数式编程方面的基本概念。

Go 语言使用静态类型，所以它是**类型安全的一门语言**，加上通过构建到本地代码，程序的执行速度也非常快。

作为强类型语言，隐式的类型转换是不被允许的，记住一条原则：让所有的东西都是显式的。

Go 语言其实也有一些**动态语言的特性（通过关键字 `var`）**，所以它对那些逃离 Java 和 .Net 世界而使用 Python、Ruby、PHP 和 JavaScript 的开发者们也具有很大的吸引力。

Go 语言支持交叉编译，比如说你可以在运行 Linux 系统的计算机上开发运行 Windows 下运行的应用程序。这是**第一门完全支持 UTF-8 的编程语言**，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go 语言做到了真正的国际化！

## 语言的用途

Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。

对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。

它提供了海量并行的支持，这对**于游戏服务端的开发而言是再好不过了**。

Go 语言一个非常好的目标就是实现所谓的复杂事件处理（[CEP](http://en.wikipedia.org/wiki/Complex_event_processing)），这项技术要求海量并行支持，高度的抽象化和高性能。

当我们进入到物联网时代，CEP 必然会成为人们关注的焦点。

但是 Go 语言同时也是一门可以用于**实现一般目标**的语言，**例如对于文本的处理，前端展现，甚至像使用脚本一样使用它。**

值得注意的是，因为垃圾回收和自动内存分配的原因，Go 语言不适合用来开发对实时性要求很高的软件。

越来越多的谷歌内部的**大型分布式应用程序**都开始使用 Go 语言来开发，例如谷歌地球的一部分代码就是由 Go 语言完成的。

如果你想知道一些其它组织使用Go语言开发的实际应用项目，你可以到 [使用 Go 的组织](http://go-lang.cat-v.org/organizations-using-go) 页面进行查看。出于隐私保护的考虑，许多公司的项目都没有展示在这个页面。我们将会在第 21 章讨论到一个使用 Go 语言开发的大型存储区域网络（SAN）案例。

在 Chrome 浏览器中内置了一款 Go 语言的编译器用于本地客户端（NaCl），这很可能会被用于在 Chrome OS 中执行 Go 语言开发的应用程序。

Go 语言可以在 Intel 或 ARM 处理器上运行，因此它也可以在安卓系统下运行，例如 Nexus 系列的产品。

## 关于特性缺失

许多能够在大多数面向对象语言中使用的特性 Go 语言都没有支持，但其中的一部分可能会在未来被支持。

- 为了简化设计，**不支持函数重载和操作符重载**
- 为了避免在 C/C++ 开发中的一些 Bug 和混乱，**不支持隐式转换**
- Go 语言通过另一种途径实现面向对象设计（第 10-11 章）来放弃类和类型的继承
- 尽管在接口的使用方面（第 11 章）可以实现类似变体类型的功能，但本身不支持变体类型
- 不支持动态加载代码
- **不支持动态链接库**
- **不支持泛型**
- 通过 `recover` 和 `panic` 来替代异常机制（第 13.2-3 节）
- 不支持静态变量

关于 Go 语言开发团队对于这些方面的讨论，你可以通过 [Go 常见问题](http://golang.org/doc/go_faq.html) 页面查看。

# 2.2 Go 环境变量

Go 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之前就已经设置好他们。如果你使用的是 Windows 的话，你完全不用进行手动设置，Go 将被默认安装在目录 `c:/go` 下。这里列举几个最为重要的环境变量：

- **$GOROOT** 表示 Go 在你的电脑上的安装位置，它的值一般都是 `$HOME/go`，当然，你也可以安装在别的地方。
- **$GOARCH** 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。
- **$GOOS** 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。
- **$GOBIN** 表示编译器和链接器的安装位置，默认是 `$GOROOT/bin`，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。

# 3.3 调试器

应用程序的开发过程中调试是必不可少的一个环节，因此有一个好的调试器是非常重要的，可惜的是，Go 在这方面的发展还不是很完善。目前可用的调试器是 gdb，最新版均以内置在集成开发环境 LiteIDE 和 GoClipse 中，但是该调试器的调试方式并不灵活且操作难度较大。

如果你不想使用调试器，你可以按照下面的一些有用的方法来达到基本调试的目的：

1. 在合适的位置使用打印语句输出相关变量的值（`print`/`println` 和 `fmt.Print`/`fmt.Println`/`fmt.Printf`）。
2. 在 `fmt.Printf` 中使用下面的说明符来打印有关变量的相关信息：
   - `%+v` 打印包括字段在内的实例的完整信息
   - `%#v` 打印包括字段和限定类型名称在内的实例的完整信息
   - `%T` 打印某个类型的完整说明
3. 使用 panic 语句（第 13.2 节）来获取栈跟踪信息（直到 panic 时所有被调用函数的列表）。
4. 使用关键字 defer 来跟踪代码执行过程（第 6.4 节）。



# 3.4 构建并运行 Go 程序

在大多数 IDE 中，每次构建程序之前都会自动调用源码格式化工具 `gofmt` 并保存格式化后的源文件。如果构建成功则不会输出任何信息，而当发生编译时错误时，则会指明源码中具体第几行出现了什么错误，如：`a declared and not used`。一般情况下，你可以双击 IDE 中的错误信息直接跳转到发生错误的那一行。

如果程序执行一切顺利并成功退出后，将会在控制台输出 `Program exited with code 0`。

从 Go 1 版本开始，使用 Go 自带的更加方便的工具来构建应用程序：

- `go build` 编译自身包和依赖包
- `go install` 编译并安装自身包和依赖包

# 3.5 格式化代码

Go 开发团队不想要 Go 语言像许多其它语言那样总是在为代码风格而引发无休止的争论，浪费大量宝贵的开发时间，

因此他们制作了一个工具：`go fmt`（`gofmt`）。

这个工具可以将你的源代码格式化成符合官方统一标准的风格，属于语法风格层面上的小型重构。

遵循统一的代码风格是 Go 开发中无可撼动的铁律，

因此你必须在编译或提交版本管理系统之前使用 `gofmt` 来格式化你的代码。

# 3.8 Go 性能说明

根据 Go 开发团队和基本的算法测试，Go 语言与 C 语言的性能差距大概在 10%~20% 之间（ **译者注：由于出版时间限制，该数据应为 2013 年 3 月 28 日之前产生** ）。

虽然没有官方的性能标准，但是与其它各个语言相比已经拥有非常出色的表现。

如果说 Go 语言的执行效率**大约比 C++ 慢 20%** 也许更有实际意义。

保守估计在相同的环境和执行目标的情况下，

**Go 程序比 Java 或 Scala 应用程序要快上 2 倍，并比这两门语言占用的内存降低了 70% 。**

在很多情况下这种比较是没有意义的，而像谷歌这样拥有成千上万台服务器的公司都抛弃 C++ 而开始将 Go 用于生产环境才足够说明它本身所具有的优势。

时下流行的语言大都是运行在虚拟机上，如：Java 和 Scala 使用的 JVM，C# 和 VB.NET 使用的 .NET CLR。尽管虚拟机的性能已经有了很大的提升，但任何使用 JIT 编译器和脚本语言解释器的编程语言（Ruby、Python、Perl 和 JavaScript）在 C 和 C++ 的绝对优势下甚至都无法在性能上望其项背。

如果说 Go 比 C++ 要慢 20%，那么 Go 就要比任何非静态和编译型语言快 2 到 10 倍，并且能够更加高效地使用内存。

## Go 命名规范

干净、可读的代码和简洁性是 Go 追求的主要目标。

通过 gofmt 来强制实现统一的代码风格。

Go 语言中对象的命名也应该是简洁且有意义的。

像 Java 和 Python 中那样使用混合着大小写和下划线的冗长的名称会严重降低代码的可读性。

名称不需要指出自己所属的包，因为在调用的时候会使用包名作为限定符。

返回某个对象的函数或方法的名称一般都是使用名词，没有 `Get...` 之类的字符，

如果是用于修改某个对象，则使用 `SetName`。

**有必须要的话可以使用大小写混合的方式，如 MixedCaps 或 mixedCaps，而不是使用下划线来分割多个名称。**

# 6.1 介绍

Go是编译型语言，所以函数编写的顺序是无关紧要的；鉴于可读性的需求，最好把 `main()` 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。

Go 里面有三种类型的函数：

- 普通的带有名字的函数
- 匿名函数或者lambda函数（参考 [第 6.8 节](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/06.8.md)）
- 方法（Methods，参考 [第 10.6 节](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.6.md)）

除了main()、init()函数外，其它所有类型的函数都可以有参数与返回值。函数参数、返回值以及它们的类型被统称为函数签名。

函数重载（function overloading）指的是可以编写多个同名函数，只要它们拥有不同的形参与/或者不同的返回值，在 **Go 里面函数重载是不被允许的**。这将导致一个编译错误：

```
funcName redeclared in this book, previous declaration at lineno
```

Go 语言**不支持这项特性的主要原因**是函数重载需要进行多余的类型匹配**影响性能**；

**没有重载意味着只是一个简单的函数调度**。

所以你需要给不同的函数使用不同的名字，我们通常会根据函数的特征对函数进行命名

**函数也可以以申明的方式被使用，作为一个函数类型**，就像：

```
type binOp func(int, int) int
```

在这里，不需要函数体 `{}`。

函数是一等值（first-class value）：它们可以赋值给变量，就像 `add := binOp` 一样。



目前 Go 没有泛型（generic）的概念，

也就是说它不支持那种支持多种类型的函数。

不过在**大部分情况下可以通过接口**（interface），特别是空接口与类型选择（type switch，参考 [第 11.12 节](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.12.md)）与/或者通过使用反射（reflection，参考 [第 6.8 节](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/06.8.md)）**来实现相似的功能**。

使用这些技术将导致代码更为复杂、性能更为低下，所以在非常注意性能的的场合，

**最好是为每一个类型单独创建一个函数，而且代码可读性更强。**

# 6.2 函数参数与返回值

没有参数的函数通常被称为 **niladic** 函数（niladic function），就像 `main.main()`。

## 按值传递（call by value） 按引用传递（call by reference）

Go 默认使用按值传递来传递参数，也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量，比如 `Function(arg1)`。

如果你希望函数可以直接修改参数的值，而不是对参数的副本进行操作，你需要将参数的地址（变量名前面添加&符号，比如 &variable）传递给函数，这就是按引用传递，比如 `Function(&arg1)`，**此时传递给函数的是一个指针。**

在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）。

## 空白符（blank identifier）

空白符用来匹配一些不需要的值，然后丢弃掉，下面的 blank_identifier.go 就是很好的例子。

`ThreeValues` 是拥有三个返回值的不需要任何参数的函数，在下面的例子中，我们将第一个与第三个返回值赋给了 `i1` 与 `f1`。第二个返回值赋给了空白符 `_`，然后自动丢弃掉。



# 6.4 defer 和追踪

关键字 **defer 允许我们推迟到函数返回之前**（或任意位置执行 `return` 语句之后）一刻才执行某个语句或函数

（为什么要在返回之后才执行这些语句？因为 `return` 语句同样可以包含一些操作，而不是单纯地返回某个值）。

关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 `finally` 语句块，它一般用于释放某些已分配的资源。

使用 defer 的语句同样可以接受参数，下面这个例子就会在执行 defer 语句时打印 `0`：

```
func a() {
	i := 0
	defer fmt.Println(i)
	i++
	return
}
```

当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出）：

```
func f() {
	for i := 0; i < 5; i++ {
		defer fmt.Printf("%d ", i)
	}
}
```



关键字 defer 允许我们进行一些函数执行完成后的收尾工作，例如：

1. 关闭文件流 （详见 [第 12.2 节](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/12.2.md)）

```
// open a file  
defer file.Close()
```

1. 解锁一个加锁的资源 （详见 [第 9.3 节](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.3.md)）

```
mu.Lock()  
defer mu.Unlock() 
```

1. 打印最终报告

```
printHeader()  
defer printFooter()
```

1. 关闭数据库链接

```
// open a database connection  
defer disconnectFromDB()
```

# 6.5 内置函数

Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。

# 6.7 将函数作为参数

函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，一般称之为回调。



# 6.10 使用闭包调试

当您在分析和调试复杂的程序时，无数个函数在不同的代码文件中相互调用，如果这时候能够准确地知道哪个文件中的具体哪个函数正在执行，对于调试是十分有帮助的。您可以使用 `runtime` 或 `log` 包中的特殊函数来实现这样的功能。包 `runtime` 中的函数 `Caller()` 提供了相应的信息，因此可以在需要的时候实现一个 `where()` 闭包函数来打印函数执行的位置：



# 7.0 数组与切片

这章我们开始剖析 **容器**, 它是可以包含大量条目（item）的数据结构, 例如数组、切片和 map。

**从这看到 Go 明显受到 Python 的影响。**

**以 `[]` 符号标识的数组类型几乎在所有的编程语言中都是一个基本主力。**

Go 语言中的数组也是类似的，只是有一些特点。

Go 没有 C 那么灵活，但是拥有切片（slice）类型。

这是一种建立在 Go 语言数组类型之上的抽象，要想理解切片我们必须先理解数组。

数组有特定的用处，但是却有一些呆板，所以在 Go 语言的代码里并不是特别常见。

**相对的，切片确实随处可见的。**它们构建在数组之上并且提供更强大的能力和便捷。

# 7.2 切片

##  概念

切片（slice）是**对数组一个连续片段的引用**（该数组我们称之为相关数组，通常是匿名的），

所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。

这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。

需要注意的是，终止索引标识的项不包括在切片内。

**切片提供了一个相关数组的动态窗口。**

切片是可索引的，并且可以由 `len()` 函数获取长度。

```
func main() {
	var arr1 [6]int
	var slice1 []int = arr1[2:5]

	for i:=0; i<len(arr1); i++ {
		arr1[i]= i
	}
	for i:=0; i<len(slice1); i++ {
		fmt.Printf("slice at %d is %d\n", i, slice1[i])
	}
	//把slice进行扩展
	slice1 = slice1[0:4]
	fmt.Println("after extend")
	for i:=0; i<len(slice1); i++ {
		fmt.Printf("slice at %d is %d\n", i, slice1[i])
	}
}
```



## 将切片传递给函数

如果你有一个函数需要对数组做操作，**你可能总是需要把参数声明为切片**。当你调用该函数时，把数组分片，创建为一个 切片引用并传递给该函数。这里有一个计算数组元素和的方法:

```
func main() {
	var arr = [5]int{10,11,12,13,14}
	fmt.Println(sum(arr[:]))
}
func sum(a []int) int {
	s := 0
	for i:=0; i<len(a); i++ {
		s += a[i]
	}
	return s
}
```

## 用 make() 创建一个切片

当相关数组还没有定义时，我们可以使用 make() 函数来创建一个切片 同时创建好相关数组：`var slice1 []type = make([]type, len)`。

也可以简写为 `slice1 := make([]type, len)`，**这里 `len` 是数组的长度并且也是 `slice` 的初始长度。**

所以定义 `s2 := make([]int, 10)`，那么 `cap(s2) == len(s2) == 10`。

make 接受 2 个参数：元素的类型以及切片的元素个数。

如果你想创建一个 slice1，它不占用整个数组，而只是占用以 len 为个数个项，那么只要：`slice1 := make([]type, len, cap)`。

make 的使用方式是：`func make([]T, len, cap)`，其中 cap 是可选参数。

所以下面两种方法可以生成相同的切片:

```
make([]int, 50, 100)
new([100]int)[0:50]
```



# 9.1 标准库概述

像 `fmt`、`os` 等这样具有常用功能的内置包在 Go 语言中有 150 个以上，它们被称为标准库，大部分(一些底层的除外)内置于 Go 本身。



# 9.3 锁和 sync 包

在一些复杂的程序中，通常通过不同线程执行不同应用来实现程序的并发。

当不同线程要使用同一个变量时，经常会出现一个问题：

无法预知变量被不同线程修改的顺序！

(这通常被称为资源竞争,指不同线程对同一变量使用的竞争)

显然这无法让人容忍，那我们该如何解决这个问题呢？

经典的做法是一次只能让一个线程对共享变量进行操作。

当变量被一个线程改变时(临界区)，我们为它上锁，直到这个线程执行完成并解锁后，其他线程才能访问它。

特别是我们之前章节学习的 map 类型是不存在锁的机制来实现这种效果(出于对性能的考虑)，

所以 map 类型是非线程安全的。

当并行访问一个共享的 map 类型的数据，map 数据将会出错。

在 Go 语言中这种锁的机制是通过 sync 包中 Mutex 来实现的。

sync 来源于 "synchronized" 一词，这意味着线程将有序的对同一变量进行访问。

`sync.Mutex` 是一个互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。



# 9.5 自定义包和可见性

包是 Go 语言中**代码组织和代码编译**的主要方式。

关于它们的很多基本信息已经在 4.2 章节中给出，**最引人注目的便是可见性。**

现在我们来看看具体如何来使用自己写的包。

在下一节，我们将回顾一些标准库中的包，自定义的包和标准库以外的包。



参考资料

1、

https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/01.1.md