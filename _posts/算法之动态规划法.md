---
title: 算法之动态规划法
date: 2019-12-19 09:16:22
tags:
	- 算法

---

1

动态规划，英文是dynamic programming，简写为dp。

是运筹学的一个分支。

是求解决策过程最优化的数学方法。

这个方法是20世纪50年代，由美国数学家Bellman提出的。

在研究多阶段决策过程的优化问题时，提出了著名的最优化原理。

把多阶段过程，转化为一系列单阶段问题。

利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法，就是动态规划。

在1957年，他出版了名著《Dynamic Programming》，是这个领域的第一本著作。



# 分类

可以分为4种：

1、线性动规。例如：拦截导弹、合唱队形。

2、区域动规。例如：统计单词个数

3、树形动规。例如：二分查找树

4、背包动规。例如：01背包问题、完全背包问题，二维背包。



应用实例：

最短路径问题。

项目管理。

网络流优化。



# 意义

动态规划诞生以来，在经济管理、生产调度、工程技术和最优控制等方面得到了广泛的应用。

例如最短路径、库存管理、资源分配、设备更新、排序、装载等问题，用动态规划法比其他方法求解更加方便。





基本思想

动态规划法一般是用于求解最优解的问题。

在这种问题里，可能有许多可行解。

动态规划法跟分治法有类似之处，都是把问题分解为若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

不同在于，动态规划法的子问题是有相互关联的。

只要计算的答案，就保存起来，这就是动态规划法的基本思路。

**关键是状态转移方程。**

动态规划的基本模型如下：

1、确定问题的决策对象。

2、对决策过程划分阶段。

3、对各阶段确定状态变量。

4、根据状态变量确定费用函数和目标函数。

5、建立各阶段状态变量的转移过程，确定状态转移方程。



适用范围

任何思想方法都有局限性。超出了特定条件，它就失去了作用。

动态规划必须满足2个条件：

1、最优化原理。一个最优策略的子策略总是最优的。

2、无后效性。前面的决策不会影响后面的决策。



动态规划是空间换时间的技术。在实现过程中，必须存储产生的各种状态。

所以它的空间复杂度要高于其他算法。



# 例子

## 数字三角形

一个最简单的例子。

下面这样一个数字三角形，找出一条路径，从最上面到最下面，使得经过的数字的和最大或者最小。

```
   1
  2 3
 4 5 6
7 8 9 10
```

这是一个动态规划的决策问题。

每次有两种选择：向左或者向右。

一个n层的数字三角形的完整路线有2^n条。

所以当n比较大的时候，用回溯法是行不通的。

我们可以写出对应的状态转移方程：

```
f[i][j] = a[i][j] + max{f[i+1][j], f[i+1][j+1]}
其中：
a[i][j]表示当前状态。
f[i][j]表示指标函数。
```

```
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;

#define MAX 101
int D[MAX][MAX];
int n;

int MaxSum(int i, int j)
{
    if(i == n) {
        return D[i][j];
    }
    int x = MaxSum(i+1, j);
    int y = MaxSum(i+1, j+1);
    return max(x,y) + D[i][j];
}
int main()
{
    int i,j;
    cin >> n;
    for(i=1; i<=n; i++) {
        for (j=1; j<=i; j++) {
            cin >> D[i][j];
        }
    }
    cout << MaxSum(1,1) << endl;
}
```

运行：

```
./test < 1.txt
```

1.txt的内容：

```
4
1
2 3
4 5 6
7 8 9 10
```



上面只是用了基本的递归，遍历了每条可能的路径，存在大量的重复计算。

现在的时间复杂度是2^n。

如果每算出一次MaxSum，就保存起来，下次用到的时候，直接取用。

这样就可以免去重复计算。这样时间复杂度就看一看降低到O(n^2)。因为数字的个数是n(n+1)/2。

改进如下。

```
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;

#define MAX 101
int D[MAX][MAX];
int n;
int maxSum[MAX][MAX];//增加结果数组
int MaxSum(int i, int j)
{
    if(maxSum[i][j] != -1) {//说明最大值已经被计算出来了。
        return maxSum[i][j];
    }
    if(i == n) {//说明是最后一行的数字了
        maxSum[i][j] = D[i][j];
    } else {
        int x = MaxSum(i+1, j);
        int y = MaxSum(i+1, j+1);
        maxSum[i][j] = max(x,y) + D[i][j];
    }
    return maxSum[i][j];
}
int main()
{

    int i,j;
    cin >> n;
    for(i=1; i<=n; i++) {
        for (j=1; j<=i; j++) {
            cin >> D[i][j];
            maxSum[i][j] = -1;
        }
    }
    cout << MaxSum(1,1) << endl;
}
```

可以继续改进，把递归改成递推。

```
#include <iostream>
#include <algorithm>
using namespace std;

#define MAX 101
int D[MAX][MAX];
int n;
int maxSum[MAX][MAX];//增加结果数组

int main()
{

    int i,j;
    cin >> n;
    for(i=1; i<=n; i++) {
        for (j=1; j<=i; j++) {
            cin >> D[i][j];
        }
    }
    //这里新增
    for(i=1; i<=n; i++) {
        maxSum[n][i] = D[n][i];//让maxSum最后一行的值，赋值为D的最后一行的值。
    }
    for(i=n-1; i>=1; i--) {
        for(j=1; j<=i; j++) {
            maxSum[i][j] = max(maxSum[i+1][j], maxSum[i+1][j+1]) + D[i][j];
        }
    }
    cout << maxSum[1][1] << endl;
}
```

还可以继续改进。

上面的maxSum二维数字空间有点浪费。

## 零钱兑换问题

假如有2元、3元、7元这3种面额的纸笔，怎样让最少的张数来凑成100元。

这个最直接的解法是用贪心算法。先尽量用面额最大的来凑。

不过也可以用动态规划来解。

```
用c(n)表示抽出n元的最少纸笔张数。
那么：
c(100) = c(93+7) = c(93) + 1
c(100) = c(97+3) = c(97) + 1
c(100) = c(98+2) = c(98) + 1
这样持续分解，直到：
c(2) = 1
c(3) = 1
c(4) = 2
c(5) = 2 
c(6) = 2
c(7) = 1
c(8) = 3

可以推导出状态转移方程是：
c[i] = min(c[i-value(j)] + 1)
```

然后我们画出一张表格，

```
总额\面值   2   3    7    最少张数
1          -   -   -     -
2          1   -   -     1
3          -   1   -      1
....
```

然后就可以写代码了。

```

```





如果一个问题有多种可能，看上去需要排列组合的思想，但是最终求的只是最优解。

如最大值、最小值、最短子串、最长子串等，就可以试一下动态规划。

如果可以找到状态转移方程，那么离实现代码就不远了。



参考资料

1、动态规划

https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fromtitle=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95&fromid=8193074&fr=aladdin

2、数字三角形精编版 

https://wenku.baidu.com/view/7be34446900ef12d2af90242a8956bec0875a54b.html

3、动态规划-如何推导出状态转移方程？

https://www.jianshu.com/p/a1f5731811af

4、动态规划详解（数字三角形POJ1163）

这篇讲得好。

https://blog.csdn.net/ancientear/article/details/79170221