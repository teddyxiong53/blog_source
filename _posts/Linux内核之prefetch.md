---
title: Linux内核之prefetch
date: 2019-12-09 09:38:38
tags:
	 - Linux

---

1

看内核2.6.35版本的代码，看到list_for_each_entry宏里面，用到一个叫prefetch的宏。

了解一下。

**先说结论：**

**这个宏的本意是为了提升性能，后面被证明实际上还拖慢了性能。**

**所以在2.6.40里被去掉了。**



在内核层面，性能通常受缓存行为的影响。真正高性能要求只有命中cpu缓存才能够满足，内存访问相比较显得过于缓慢了。
内核尽量地使用cache-hot memory；以及其它一些其它重要的工作，例如调整数据结构使得经常被访问的数据位于同一条cache line中。作为通用的准则，这些优化方法对性能的提升很明显。

百分百命中缓存是难以达到的，但是也可以想办法尽量提高命中率。

如果内核知道最近将要访问的数据所处的位置，它可以使用CPU提供的 prefetch 指令将数据放入缓存。这种指令是通过内核prefetch()函数实现的；开发者已经在广泛使用这个函数。

Prefetch()的思想是在处理当前实体的同时开始获取链表中下一个实体。
希望在下一次循环开始前能够获取到数据，或者至少使这个数据已经开始传输。众所周知，链表是对缓存不友好的数据类型，所以这种类型的优化能够有效提升速度。

但实际上这样做并不能提升速度，至少在x86处理器上不能。

最近，Linus在自己最喜欢的workloads（内核builds）之一上做了一些分析然后发现prefetch 指令集占据了极大比例。执行Prefetching所消耗的时间超出了缓存带来的好处；将prefetch()移除能够让made和build更快。

Ingo Molnar，牛人 Ingo，也关注了这件事情，他进行了很有意义的研究。通过使用perf和一些细微的kernel调试，他证明了使用prefetch()结构造成了0.5%的性能下降。这不是一个简单的性能退化，它本来被指望带来更快的速度，一定有什么地方没有按照人们想象的方式运行。

他工作的成果之一：2.6.40（现在被起名叫3.0了），将prefetch()操作从链表，哈希表以及sk_buff表的遍历操作中移除，正如 Andi Kleen在九月份尝试做的那样。或者其他的prefetch操作也被移除的话性能也有提升的几率。内核中仍然存在prefetch()操作，不过只存在 于特定的能明确提升性能的场景。如同我们尝试的其他底层优化（立刻能想到的就是likely()），我们自以为prefetch能带来帮助，但并不是我们 真正需要做的工作。

参考资料

1、日常笔记之内核prefetch问题

https://blog.csdn.net/hxhardway/article/details/78355242