---
title: ccache编译器缓存
date: 2020-03-12 13:26:13
tags:
	- buildroot

---

--

看buildroot编译的第二个package就是ccache。了解一下。

ccache是compiler cache的意思。

代码：https://github.com/ccache/ccache

用来加快rebuild的速度。



# ccache介绍

ccache是一个用于加速编译过程的缓存工具，

通常用于编译C和C++代码。

它的主要作用是缓存已编译的对象文件，以便在后续编译过程中能够复用这些文件，从而减少编译时间。==ccache通常用于在开发环境中，特别是在大型项目中，以提高代码构建的效率。==

以下是一些ccache的主要特点和功能：

1. 缓存编译结果：ccache会将已编译的对象文件存储在一个缓存目录中，以便后续的构建可以重用这些文件。这有助于减少重复编译相同源代码的时间。

2. 自动识别编译器：ccache能够自动识别不同的编译器（如GCC、Clang等），并与它们一起使用。它通过检查编译命令行参数和文件内容来确定源代码文件是否已更改，以决定是否使用缓存。

3. 配置灵活：ccache允许用户配置不同的缓存参数，如缓存大小、缓存目录、缓存文件的有效期等。这使用户可以根据项目的需要进行调整。

4. 环境变量支持：ccache可以通过设置环境变量来启用或禁用缓存，以便在需要时进行灵活控制。

5. 易于集成：ccache可以与常见的构建工具（如Make、CMake、Autotools等）一起使用，而无需对构建脚本进行重大修改。

6. 统计信息：ccache还提供了有关缓存的统计信息，如缓存命中率、缓存文件数目、缓存未命中数等，以帮助用户了解缓存的性能。

总的来说，ccache是一个有用的工具，可以显著加快代码的编译过程，特别是在大型项目中。它可以减少编译时间，提高开发者的工作效率，并降低了构建过程中的资源消耗。

# ccache的发展历史

ccache的发展历史可以追溯到20世纪90年代初，以下是ccache的主要发展里程碑：

1. 1996年：ccache的起源可以追溯到1996年，由Anders Björklund创建。最初，它是一个用于Solaris操作系统的脚本，用于加速编译过程。它利用了Solaris系统的符号链接（symlink）功能，将已编译的对象文件存储在一个共享目录中，并在后续编译过程中将它们链接到目标目录。

2. 2002年：Anders Björklund将ccache的代码开源发布，并将其托管在SourceForge上。这一举措使更多的开发者能够参与ccache的开发和改进。

3. 2007年：在ccache的开发过程中，针对各种编译器的支持得到了扩展，包括GCC和Clang等。这一年，ccache的用户群体不断增长，项目变得更加成熟。

4. 2015年：ccache的GitHub存储库正式启动，这使得项目的维护和协作更加方便，也为更广泛的社区提供了一个讨论和贡献代码的平台。

5. 2017年：ccache的版本3.3.4发布，它引入了一些新特性和改进，如更好的C++支持和并行编译的优化。

6. 2020年：ccache的版本4.0发布，带来了一些重要的性能改进和兼容性更新，以适应不断变化的编译器和构建工具。

ccache的发展历史表明，它已经成为编译过程中常用的工具之一，受到广泛的开发者和项目的欢迎。随着时间的推移，ccache不断发展和改进，以适应不断变化的编译环境和需求。这个工具的开源性质使得更多人可以为其贡献代码，共同推动其发展。

# ccache原理

ccache的原理是利用缓存技术，将已经编译过的对象文件（如.o文件）存储在一个特定的目录中，以便在后续的编译过程中可以重用这些文件，从而减少编译时间。以下是ccache的基本工作原理：

1. 缓存目录：ccache会为每个编译器建立一个缓存目录，用于存储编译过的对象文件。通常，这些目录会位于用户主目录下的`.ccache`目录中。

2. 编译命令识别：在编译源代码时，ccache会检查编译命令的参数、输入文件和时间戳等信息。它会使用这些信息来生成一个唯一的缓存键（cache key），以识别每个编译任务。

3. 缓存查找：当需要编译源文件时，ccache首先会根据编译命令生成的缓存键在缓存目录中查找是否已有相同的编译任务的结果。如果找到匹配的缓存键，ccache会使用缓存中的已编译对象文件，而不需要实际进行编译，从而加速构建过程。

4. 缓存命中和未命中：如果缓存中找到匹配的缓存键，这被称为“缓存命中”（cache hit）。如果没有找到匹配的缓存键，这被称为“缓存未命中”（cache miss），此时ccache会将编译任务交给编译器执行，然后将生成的对象文件存储在缓存中以供后续使用。

5. 缓存清理：ccache通常会定期清理过期的缓存文件，以释放磁盘空间并保持缓存的有效性。用户可以配置缓存的有效期和最大容量等参数。

总的来说，ccache的核心原理是缓存已编译的对象文件，通过快速查找缓存中的结果，避免重复编译相同的源文件，从而显著加速代码构建的过程。这对于大型项目或频繁构建的开发环境特别有用，可以节省大量的编译时间和资源。

# 举例说明

让我们通过一个简单的示例来说明ccache的工作原理。假设你正在开发一个C++项目，其中包含多个源文件，并且使用GCC编译器。

1. 首次编译：
   - 你的项目包含两源文件：`main.cpp`和`util.cpp`。
   - 你运行以下编译命令编译这两个源文件：
     ```bash
     g++ -o main main.cpp util.cpp
     ```
   - 编译器将`main.cpp`和`util.cpp`编译成目标文件`main.o`和`util.o`，然后将它们链接到可执行文件`main`。
   - ==在这个过程中，ccache会创建一个缓存键，包括编译器类型（g++）、编译命令参数（-o main main.cpp util.cpp），以及源文件的内容和时间戳等信息。==

2. 缓存未命中：
   - 假设你在稍后的时间内对`main.cpp`进行了一些更改，并再次运行相同的编译命令。
   - 因为`main.cpp`已经更改，ccache无法找到与新编译命令匹配的缓存键，这被称为"缓存未命中"。
   - ccache会自动将编译任务交给编译器进行编译，生成新的`main.o`文件。

3. 缓存命中：
   - 接下来，你又一次运行相同的编译命令，但这次没有对任何源文件进行更改。
   - 由于编译命令和源文件内容没有变化，ccache能够找到与之匹配的缓存键，这被称为"缓存命中"。
   - ccache会从缓存中检索`main.o`文件，而不需要实际执行编译过程，因为已经有了可重用的对象文件。

这个示例说明了ccache是如何通过缓存已编译的对象文件，以减少重复编译相同源文件的时间。在开发过程中，随着源文件的修改和重新编译，ccache可以显著提高代码构建的速度，特别是在大型项目中，节省时间和资源。

# Makefile不是也可以做到这个功能吗？

是的，Makefile也可以用来加速代码构建并缓存编译结果。Make是一种构建工具，它允许你定义和管理项目中的编译规则，以确保只有在需要时才重新编译修改过的源文件。这与ccache的目标有些相似，但它们之间存在一些区别：

1. **ccache的无感知性：** ccache是一种无感知的工具，可以与任何编译工具（如GCC、Clang等）一起使用，而不需要对项目的构建脚本进行任何修改。它在后台工作，自动缓存和重用已编译的对象文件。

2. **Makefile的手动配置：** 使用Makefile需要手动编写Makefile规则，以定义源文件之间的依赖关系和编译规则。这通常需要更多的配置工作，并且对于大型项目可能会更加复杂。

3. **细粒度控制：** Makefile允许你定义更细粒度的规则，例如指定哪些文件依赖于其他文件，如何进行编译、链接等，这可以提供更大的灵活性和自定义性。

4. **综合使用：** 实际上，ccache和Makefile可以结合使用。你可以使用Makefile来管理项目的构建规则，同时在构建过程中利用ccache来加速编译过程。这种综合使用可以提供更高的构建效率。

总的来说，Makefile和ccache都是在构建过程中提高效率的工具，但它们的角色和功能略有不同。ccache更注重在后台自动缓存编译结果，而Makefile更注重项目构建规则的定义和管理。选择使用哪种工具取决于你的需求和偏好，以及项目的规模和复杂性。

# 参考资料

1、

