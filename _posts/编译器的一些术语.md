---
title: 编译器的一些术语
date: 2023-06-01 21:48:11
tags:
	- 编译器
---

--

看sdcc的手册，看到的一些术语，顺手用chatgpt查询一下，记录到这里。

# 术语

## global sub expression elimination

全局子表达式消除（Global Subexpression Elimination，简称GSE）是编译器中的一种优化技术，用于提高代码执行的效率。它旨在通过识别和重用程序中的常见子表达式来消除冗余计算。

当一个子表达式在程序中多次出现时，如果它的结果不会改变，那么多次计算它是不必要的。全局子表达式消除通过分析程序中的表达式，找出这些重复的子表达式，并在计算时重复使用它们的结果。

具体而言，全局子表达式消除的过程包括以下步骤：
1. 对程序进行静态分析，识别出各个表达式。
2. 为每个表达式计算其值，并记录结果。
3. 比较不同表达式之间的值，找出相同的子表达式。
4. 将重复的子表达式替换为其对应的结果，以减少重复计算。

全局子表达式消除可以减少程序中的计算量，提高程序的执行速度。通过消除冗余计算，它可以减少内存访问、减少指令数目，从而提高程序的性能。

这种优化技术通常由编译器自动完成，开发人员无需手动介入。编译器会根据程序的特征和优化目标自动应用全局子表达式消除，以提高生成的机器代码的效率。

## loop optimizations

循环优化（Loop Optimizations）是编译器中用于提高循环执行效率的一系列技术。

其中包括

循环不变量（Loop Invariant）、

归纳变量的强度降低（Strength Reduction of Induction Variables）和

循环反转（Loop Reversing）等优化手段。

1. 循环不变量（Loop Invariant）优化：循环不变量是指在循环内部不会改变数值的表达式或变量。循环不变量优化的目标是将这些不变量的计算提到循环外部，避免重复计算。通过将循环不变量提取出来，可以减少循环内部的计算量，提高循环的执行效率。

2. 归纳变量的强度降低（Strength Reduction of Induction Variables）优化：归纳变量是在循环中根据迭代次数递增或递减的变量。强度降低优化的目标是将复杂的归纳变量操作替换为更简单、更高效的操作。例如，将乘法操作替换为位移操作或加法操作，以减少计算开销。

3. 循环反转（Loop Reversing）优化：循环反转是指改变循环迭代的顺序，从而减少分支判断和提高指令级并行性。通过反转循环的迭代顺序，可以使得循环中的数据访问模式更加有序，有利于缓存的命中和指令的重排，从而提高循环的执行效率。

这些循环优化技术通常由编译器自动进行。编译器会对循环进行静态分析，并根据程序的结构和特性应用适当的优化策略。通过循环优化，可以提高程序的性能，减少计算时间和资源消耗，特别对于含有大量迭代计算的代码段来说，循环优化是非常重要的。

## constant folding & propagation,

常量折叠（Constant Folding）和常量传播（Constant Propagation）是编译器中常见的优化技术，用于在编译时对程序中的常量进行优化。

1. 常量折叠（Constant Folding）：常量折叠是指在编译时对表达式中的常量进行计算，以便在编译时确定表达式的结果。例如，对于一个表达式 2 + 3，编译器可以在编译时计算出结果 5，并将结果直接替换到代码中。这样可以避免程序运行时重复计算常量的开销，提高程序的执行效率。

2. 常量传播（Constant Propagation）：常量传播是指将常量值传递给变量，在编译时替换变量的引用为对应的常量值。如果变量在后续的代码中没有被修改，编译器可以通过常量传播将变量的值替换为常量值，以减少运行时的变量引用和内存访问。这种优化技术可以减少不必要的运行时开销，提高程序的执行效率。

通过常量折叠和常量传播的优化，编译器可以在编译阶段对程序中的常量进行计算和替换，从而减少程序运行时的计算和访存开销。这些优化技术可以显著提高程序的性能，并减少程序执行所需的时间和资源消耗。

需要注意的是，常量折叠和常量传播只适用于那些在编译时可以确定其值的常量和表达式。对于运行时动态计算的部分，这些优化技术不适用。编译器会根据代码的结构和上下文，以及优化的开销和收益进行决策，选择合适的优化策略来提高程序的性能。

## copy propagation,

复制传播（Copy Propagation）是编译器中的一种优化技术，用于替换程序中的变量复制操作，以减少不必要的内存访问和计算开销。

在程序中，经常会遇到将一个变量的值复制给另一个变量的操作，如 `x = y;`。复制传播的目标是找到这些复制操作，并尝试将被复制变量的使用处替换为复制变量本身。这样可以消除中间的复制操作，直接使用原始变量的值，减少内存访问和计算的开销。

具体而言，复制传播的过程包括以下步骤：
1. 遍历程序的语句，找到赋值语句中的复制操作。
2. 对于每个复制操作，分析变量的使用情况。
3. 如果变量的使用处只是读取其值，而没有其他修改，那么将使用处替换为复制变量。
4. 重复步骤2和步骤3，直到无法进行进一步的替换。

通过复制传播，编译器可以减少不必要的复制操作，避免了在内存中存储重复的值，并且可以减少对内存的访问，提高程序的执行效率。此外，复制传播还有助于其他优化技术的应用，如常量传播、常量折叠和死代码消除等。

需要注意的是，复制传播可能引入一些额外的复杂性和开销，特别是在存在条件分支和循环的情况下。编译器会综合考虑优化的效果和开销，选择合适的时机和方式进行复制传播的优化操作。

## dead code elimination

死代码消除（Dead Code Elimination）是编译器中的一种优化技术，用于删除程序中不会被执行的无用代码，以减少程序的冗余和提高执行效率。

在程序中，可能存在一些被定义但从未使用过的变量、未被调用的函数、不会被执行的语句或不会产生副作用的表达式等。这些无用的代码被称为死代码，因为它们对程序的功能没有贡献，并且可能占用了内存和资源。

死代码消除的目标是通过静态分析程序的结构和上下文，找到并删除这些死代码，以减少程序的体积、提高执行速度和减少资源消耗。

具体而言，死代码消除的过程包括以下步骤：
1. 对程序进行静态分析，确定每个变量和函数的使用情况。
2. 标记未使用的变量和函数，以及不会被执行的语句和表达式。
3. 删除被标记为死代码的部分，同时更新程序的引用和依赖关系。

通过死代码消除，可以减少程序的冗余，提高代码的可读性和维护性，并且可以减少内存占用和资源消耗。此外，死代码消除还有助于其他优化技术的应用，如常量传播、常量折叠和复制传播等。

需要注意的是，死代码消除是在编译时进行的静态优化，所以只能检测和删除在编译时可确定为死代码的部分。对于依赖于运行时条件或动态输入的代码，死代码消除无法进行准确的判断。编译器会根据程序的结构和上下文进行死代码消除的决策，以平衡优化效果和开销。

## jump tables for *switch* statements.

跳转表（Jump Tables）是用于优化编程语言中的`switch`语句的一种技术。它通过创建一个索引表来实现`switch`语句的分支跳转，从而提高代码执行效率。

在许多编程语言中，`switch`语句用于根据不同的条件值执行不同的代码块。传统的`switch`语句通常使用一系列的条件分支（`case`语句）来判断条件值，并执行相应的代码块。这种实现方式在条件分支较多时可能会导致性能下降，因为每次执行`switch`语句时都需要逐一比较条件值。

跳转表通过创建一个索引表，将条件值与对应的代码块的跳转目标关联起来，从而避免逐一比较条件值的开销。跳转表通常是一个数组或者类似的数据结构，其中每个元素与条件值对应，并存储了相应代码块的跳转目标（例如函数指针或标签）。通过使用跳转表，编译器可以直接根据条件值在表中查找对应的跳转目标，实现快速的分支跳转。

使用跳转表的优点包括：
1. 提高执行速度：跳转表减少了条件值的逐一比较，直接通过索引查找跳转目标，从而减少了分支判断和执行的开销，提高了代码的执行速度。
2. 代码可读性和维护性：跳转表将条件值与跳转目标关联起来，使得代码逻辑更加清晰，易于阅读和维护。
3. 节省空间：跳转表将多个条件值对应的跳转目标存储在一个表中，避免了重复的代码块，节省了空间。

需要注意的是，跳转表适用于条件值连续且值域较小的情况，例如整数或枚举类型。对于条件值分布散乱或值域较大的情况，使用跳转表可能不太适合，可能会导致过大的表或不均匀的分支开销。

跳转表的使用通常由编译器自动完成，开发人员无需手动干预。编译器会根据`switch`语句的特征和程序的优化目标来决定是否使用跳转表以及如何构建跳转表。



## peep hole optimizer 

Peephole优化器是编译器中的一种局部优化技术，用于在生成目标代码的过程中通过短程模式匹配和替换来改进代码质量和性能。

Peephole优化器通过在目标代码的有限窗口（称为Peephole窗口）内检测和优化代码序列，对连续的指令序列进行模式匹配，并根据预定义的优化规则进行替换或删除。这种优化技术通常在汇编级别进行，用于微调生成的机器代码，以消除冗余、改进指令序列和提高执行效率。

Peephole优化器的工作流程包括以下几个步骤：
1. 确定Peephole窗口的大小，即需要检查的指令序列的长度。
2. 在目标代码中滑动Peephole窗口，检测指令序列是否匹配预定义的优化模式。
3. 如果匹配成功，根据优化规则进行相应的替换、删除或重排指令。
4. 继续滑动Peephole窗口，直到遍历完整个目标代码，或不再有优化匹配。

Peephole优化器可以执行各种优化，例如：
- 删除冗余指令：识别和删除无效或冗余的指令，从而减少代码量和提高执行速度。
- 替换指令序列：根据性能更好的指令序列模式，将原指令序列替换为更高效的等价指令序列。
- 优化算术运算：通过使用位操作、移位操作或特定的指令序列，改进算术运算的效率。
- 改进访存操作：识别和改进访存操作的模式，例如使用加载-存储合并技术减少访存操作次数。
- 消除无用代码：检测和删除无用的指令，从而减少代码量和提高代码清晰度。

Peephole优化器在编译器中作为后端优化阶段的一部分，用于微调生成的目标代码。它通常与其他全局和局部优化技术相结合，以获得更好的代码质量和性能。由于Peephole优化器只关注局部代码序列，因此其优化能力有限，但它可以处理一些常见的模式并提供额外的性能改进。