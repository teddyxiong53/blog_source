---
title: 算法之斐波那契不同算法思想解决
date: 2020-07-28 16:20:49
tags:
	- 算法

---

1

斐波那契作为一个经典的算法题目，可以用不同的算法思想来进行解决。

所以适合用来对比不同算法思想的特点。

我们就以求输入为n的斐波那契值来做题目。不需要打印所有元素。

函数原型：

```
int fab(int n);
```

最基本的，就是递归。

```
int fab(int n) {
	if(n <= 1) {
        return n;
    } else {
        return fab(n-1) + fab(n-2);
    }
}
```

这个算法的特点是看起来直观简洁，但是效率非常低。

根本原因在于重复计算。

例如fab(5)计算的时候，需要计算fab(4)和fab(3)。而计算fab(4)的时候，还需要计算一遍fab(3)。

太多的重复计算了。

所以改进的要点就是把之前计算的值缓存起来，这样就可以避免重复计算了。

这样来做。

```
int fab(int n)
{
    if(n<=1) {
        return n;
    }
    int *ans = new int[n+1];
    ans[0] = 0;
    ans[1] = 1;
    for(int i=2; i<=n; i++) {
        ans[i] = ans[i-1] + ans[i-2];
    }
    int tmp = ans[n];
    delete[] ans;
    return tmp;
}
```

改进后的时间复杂度和空间复杂度都是O(N)的了。

后面的这种解法，是动态规划法。

动态规划法的关键，记录子问题的解，空间换时间。



参考资料

1、

