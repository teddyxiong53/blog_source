---
title: Linux之sysfs了解
date: 2018-01-28 18:52:43
tags:
	- Linux
	- sysfs

---

1

# 一些认识

/sys/class，这个目录，相当于windows的设备管理器。可以看到各类设备的具体信息。

或者说，/sys目录下的目录，是从不同的维度来观察设备的构成。



sysfs的作用是什么？

1、建立系统里bus、driver、device这三者之间的桥梁。

2、在用户空间展示内核里各种device的拓扑图。

3、对用户空间暴露接口，取代部分ioctl功能。



sysfs跟proc类似，都是提供了一种从shell访问内核数据的方式。但是sysfs会比proc更好一些。其中最重要的一点就是设计上更加清晰。

proc里的文件格式各不相同，用户程序读取后，可能要进行字符串解析，才能取得有效信息。

**而sysfs的设计原则是：一个属性文件只做一件事情。里面只有一个值。**



对于驱动开发者，如果想要把驱动跟用户程序建立连接，可以选择的方法有：

**1、注册cdev设备。ioctl来设置属性。但是无法在脚本里用。**

2、注册proc。

3、注册sysfs。



不过一般是这3个都做的。proc可以选择不做了。

sysfs需要增加的代码最少。可维护性也最好。



**一般最少是需要cdev设备的。其他两个是补充性的。**



/dev节点的缺点：

1、一般用read/write/ioctl来进行操作。

2、read/write，只能做一件事。

**3、ioctl可以实现多种功能。但是无法在shell脚本里使用。还有大小端不兼容、64位兼容问题。**



/proc的缺点：

1、写代码比较麻烦。



/sys节点的优点：

1、在用户层都是可见的，透明的。

2、需要增加的代码是最少的。



什么是uevent机制。

这个得从热插拔设备开始说起。

最简单的一个例子就是U盘了。

当我们在计算机上插上一个U盘的时候，系统的USB hub会检测到U盘设备接入，并且完成设备枚举过程(从设备上读出相应的设备信息)，并在内核中创建相应的设备结构体。

但是，usb设备千奇百态，内核不可能预先将所有usb设备驱动都增加到内存中来。

也就是当插入U盘设备的时候，内核中不一定存在对应这个设备的usb驱动。

**这个时候USB驱动也许以模块的形式保存在硬盘上。**

**载入驱动必然只能从用户态来进行，那这时候应该怎么办呢？**

看到这里的时候，有人一定会想，人工敲入命令载入驱动，呵呵。

这必然是一种方法，但是是一种很古老的方法。

Linux对类似的情况设计了一种uevent的机制。

当有新的设备加入的时候，**将设备的信息发送消息到用户态**。

而用户态有一个udev的进程监听这个信息。

**当收到信息后做一定的解析，根据解析到的结果和用户程序的配置做一些处理，也包括加载驱动程序。** 



Uevent是Kobject的一部分，用于在Kobject状态发生改变时，例如增加、移除等，通知用户空间程序。



由此可知，Uevent的机制是比较简单的，设备模型中任何设备有事件需要上报时，会触发Uevent提供的接口。Uevent模块准备好上报事件的格式后。

可以通过两个途径把事件上报到用户空间：一种是通过kmod模块，直接调用用户空间的可执行文件；

另一种是通过netlink通信机制，将事件从内核空间传递给用户空间。



前面有提到过，在利用Kmod向用户空间上报event事件时，**会直接执行用户空间的可执行文件**。

而在Linux系统，**可执行文件的执行，依赖于环境变量，**

因此kobj_uevent_env**用于组织此次事件上报时的环境变量**。



# 参考资料

1、

https://www.ibm.com/developerworks/cn/linux/l-cn-sysfs/index.html

2、内核Uevent事件机制 与 Input子系统

https://www.cnblogs.com/sky-heaven/p/6394267.html