---
title: Linux内核里的设计模式
date: 2023-10-24 15:58:32
tags:
	- Linux

---

--

在软件开发中，设计模式是一种被广泛应用的解决问题的方法。

设计模式可以帮助开发人员有效地解决软件设计中的问题，

提高软件的可维护性和可扩展性，

同时也能提高代码的可读性和可重用性。



而在Linux内核的开发中，设计模式也扮演了重要的角色。

Linux内核作为一个开源操作系统内核，

其内部架构复杂，代码庞大，设计模式在其中的应用也十分广泛。



本文将介绍一些常见的设计模式在Linux内核中的应用，

以及它们在内核中的具体实现方式。

通过本文的介绍，读者可以更加深入地了解Linux内核的设计和实现，

并学习如何应用设计模式来提高自己的软件开发能力。

# 设计模式

## 单例模式

在Linux内核中，单例模式（Singleton Pattern）被广泛使用，

主要用于管理内核的全局数据结构，确保它们只被创建一次，避免资源浪费和不必要的竞争。

### 使用场景

在Linux内核中，全局数据结构经常用于表示系统的各种状态和配置，

如进程表、文件系统等。

这些数据结构需要在整个系统中被访问和修改，因此需要被全局共享。

但是，如果这些数据结构不是单例模式，就可能会被多次创建，导致浪费系统资源和引入不必要的竞争。

因此，单例模式是管理全局数据结构的一种常用方式。



在Linux内核中，为了保证资源的安全性和一致性，单例模式被广泛应用于管理各种资源，例如：

**1. 驱动程序管理设备资源：**在Linux内核中，驱动程序是管理设备资源的重要组成部分。

每个设备驱动程序都需要管理特定设备的资源，例如设备寄存器、内存和I/O端口等。

为了避免重复的资源分配，每个设备驱动程序只需要创建一个实例即可，这就可以使用单例模式来实现。

**2. 内存分配器管理系统内存：**内存分配器是Linux内核中另一个重要的资源管理器。

为了保证系统内存的安全和一致性，内存分配器也需要使用单例模式来保证只有一个实例来管理内存分配。

在Linux内核中，内存分配器实现通常使用slab分配器，slab分配器是一种高效的内存管理机制。

它使用单例模式来保证系统中只有一个实例来管理内存分配和释放。

每个slab分配器实例包含多个slab缓存，每个缓存用于管理一类大小相同的内存块。

### 实现方式

在Linux内核中，实现单例模式的方式有以下几种：

**1. 全局变量**：全局变量是实现单例模式最常用的方法之一。

在Linux内核中，可以定义一个全局变量来存储单例实例。

该变量可以使用static修饰符来限制其作用域，避免在其他文件中访问。

然后在需要使用单例模式的地方，可以使用该变量来获取单例实例。

**2. 宏定义：**宏定义是另一种常用的实现单例模式的方法。

**3. 函数封装：**函数封装是实现单例模式的一种灵活方式。

### 进程管理中的init进程

在Linux内核中，init进程是所有用户进程的祖先进程，

它是系统启动时创建的第一个进程，也是进程管理中的重要组成部分。

在进程管理中，Linux内核使用了单例模式来确保init进程的唯一性。

在Linux内核源码中，init进程的唯一性通过task_struct结构体中的静态指针init_task来实现。

在进程管理子系统中，init_task是一个全局变量，

它被用来保存init进程的进程描述符（task_struct）的指针。

当Linux内核启动时，init_task被初始化为一个新的进程描述符，

并在init进程被创建时，将init_task指针设置为该进程的进程描述符。



由于init_task是一个全局变量，因此在系统运行期间，只能有一个init进程存在，从而实现了单例模式的效果。

## 工厂模式

工厂模式是一种创建型设计模式，其目的是创建对象而不是直接通过new关键字来实例化对象。

### 使用场景

在Linux内核中，工厂模式通常用于以下场景：

**1. 设备驱动：**在Linux内核中，设备驱动程序通常需要使用设备对象来与硬件设备进行交互。使用工厂模式可以在内核启动时动态地创建设备对象，而不是预先实例化所有可能的设备对象。这可以大大减少内存使用，并提高系统性能。

**2. 系统调用：**Linux内核中的系统调用通常需要返回一个特定的数据结构，如file或socket。使用工厂模式可以在系统调用被调用时创建这些数据结构，从而使系统更加灵活。

**3. 内存管理：**Linux内核中的内存管理子系统负责对物理内存进行分配和管理。使用工厂模式可以动态地创建和管理不同类型的内存分配器，从而使内存管理更加高效。



# 内核里用到的设计模式

在 Linux 内核开发中，通常会应用一些常见的设计模式来解决各种问题，提高代码的可维护性、可扩展性和性能。以下是一些常见的设计模式，它们在内核开发中经常使用：

1. **观察者模式（Observer Pattern）**：
   - 在 Linux 内核中，观察者模式经常用于事件处理，例如中断处理和通知机制。驱动程序和其他内核组件可以注册为观察者，以侦听和响应事件。

2. **策略模式（Strategy Pattern）**：
   - 策略模式用于在内核中实现不同策略的选择，例如调度策略、内存分配策略等。内核中的调度器就是一个策略模式的例子，根据不同的策略选择进程运行。

3. **工厂模式（Factory Pattern）**：
   - 工厂模式用于创建对象的实例，这在内核中经常用于驱动程序注册和设备管理。内核模块通常通过设备树或 ACPI 表格来识别并创建设备实例。

4. **单例模式（Singleton Pattern）**：
   - 单例模式确保一个类只有一个实例。在内核中，全局数据结构的单一实例（例如内存管理的伙伴系统）常常使用单例模式。

5. **命令模式（Command Pattern）**：
   - 命令模式用于封装和解耦请求发送者和接收者。在内核中，命令模式可以用于处理 IOCTL 命令，其中命令对象将请求封装成对象，然后执行请求。

6. **状态模式（State Pattern）**：
   - 状态模式用于在对象状态改变时，切换对象的行为。内核中的网络协议栈就是一个状态机，根据连接状态选择不同的行为。

7. **装饰器模式（Decorator Pattern）**：
   - 装饰器模式用于动态地添加功能，而不需要改变类的接口。在内核中，驱动程序可以使用装饰器模式来添加额外的功能或修饰其他驱动程序的行为。

8. **适配器模式（Adapter Pattern）**：
   - 适配器模式用于将不兼容的接口转换为可兼容的接口。在内核中，适配器模式可以用于处理不同设备的不同接口。

9. **迭代器模式（Iterator Pattern）**：
   - 迭代器模式用于遍历集合对象，而不暴露集合的底层表示。内核中的链表遍历通常使用迭代器模式。

这些设计模式是内核开发中的一些常见实践，但它们通常以更底层的方式实现，以满足内核的性能和可预测性需求。内核开发也有一些自身的编码约定和最佳实践，这些实践与传统的设计模式相结合，以满足内核的特殊需求。设计模式在内核中有不同的应用场景，但每种情况都需要考虑到内核的特殊性质，例如实时性、性能和稳定性。

## 内核里的观察者模式举例

在 Linux 内核中，观察者模式常常用于事件处理和通知机制，允许不同部分的代码注册为观察者，以侦听和响应事件。以下是内核中观察者模式的一个示例：

**Linux 内核的中断处理**：

中断处理是内核中广泛使用观察者模式的典型示例。

内核需要在外部硬件设备发生中断时采取相应的措施，

例如，设备完成传输、设备错误等。

在这种情况下，内核的中断处理程序充当了观察者，

而硬件设备则充当了主题（或被观察者）。



具体来说，以下是观察者模式在 Linux 内核中的应用：

1. **中断注册**：硬件设备的驱动程序向内核注册中断处理程序。这是注册过程，其中驱动程序充当了观察者，而内核中的中断子系统充当了主题。

2. **中断发生**：当硬件设备引发中断时，内核的中断控制器（IRQ controller）将中断通知内核。

3. **中断处理**：内核调用已注册的中断处理程序，以响应中断。这些中断处理程序可能是硬件设备的驱动程序，它们充当了观察者，根据不同的中断类型执行相应的处理。

4. **通知**：在中断处理程序执行期间，驱动程序可以执行特定的操作，例如将数据传送到内核缓冲区，通知相关的子系统等。

在这个示例中，中断处理程序的注册和执行是观察者模式的一个应用。不同的硬件设备驱动程序可以注册自己的中断处理程序，并在中断事件发生时接收通知并执行相应的操作。这种模式帮助实现了内核的可扩展性，允许多个硬件设备并行工作，并相互独立地处理它们的中断事件。

需要注意的是，Linux 内核中有多种事件和通知机制，观察者模式在各个子系统中都有所应用，以便有效地处理各种事件和异步操作。这只是观察者模式在 Linux 内核中的一个示例。

## 内核里的策略模式举例

策略模式在 Linux 内核中经常用于各种策略的选择，例如调度策略、内存分配策略等。以下是 Linux 内核中策略模式的一个示例：

**调度策略（Scheduler Policy）**：

在 Linux 内核中，进程调度是一个关键的组成部分，用于决定哪个进程在特定时间片内运行。策略模式在这里得到广泛应用，内核支持不同的调度策略，每种策略都是一个实现了相同接口的调度类。不同的策略包括：

1. **CFS（Completely Fair Scheduler）策略**：CFS 是 Linux 内核的默认调度策略，它基于策略模式。CFS 调度策略的目标是提供公平的 CPU 时间分配，确保所有进程都有机会执行。它采用权重值来调整进程的优先级，以实现公平的时间分配。

2. **实时调度策略**：Linux 内核支持多种实时调度策略，如SCHED_FIFO和SCHED_RR。这些策略允许实时进程以高优先级执行，确保它们在严格的实时限制下执行。

3. **调度器插件**：Linux 内核还支持可插拔的调度器插件，允许用户自定义调度策略。这些插件可以实现不同的策略，以满足特定需求。

在这个示例中，策略模式用于不同的进程调度策略。不同的策略类实现相同的调度接口，允许内核在运行时选择适当的策略。这种灵活性允许内核适应不同类型的工作负载和应用程序需求。

需要指出，Linux 内核的调度策略是一个复杂的子系统，包括多个调度器类、调度队列和与实际硬件架构相关的细节。这个示例只是演示了策略模式在内核中的一种具体应用。它帮助内核实现了不同的调度策略，以满足不同类型的工作负载和性能需求。

## 内核里的装饰器模式举例

在 Linux 内核中，装饰器模式并不像在面向对象编程语言中那样直接体现，因为内核的实现方式通常更加底层和性能优先，而且内核编程通常不涉及典型的对象和类。然而，在内核代码中仍然可以找到一些类似装饰器模式的思想，即在已有的功能上动态添加额外的功能或修饰功能。以下是 Linux 内核中的一个示例：

**内核文件系统（VFS）和文件操作对象**：

在 Linux 内核中，文件系统实现通常涉及到文件操作对象（`struct file_operations`），这些对象定义了文件系统操作的接口函数。文件系统开发者可以实现这些接口函数来执行文件的读取、写入、打开、关闭等操作。

装饰器模式的思想在这里可以这样应用：

1. **核心文件操作对象**：每个文件操作对象包含一组核心操作函数，例如`read`、`write`、`open`等。

2. **装饰函数**：开发者可以创建额外的文件操作对象，并通过装饰函数动态添加额外的功能。这些装饰函数可以在核心操作函数的基础上添加额外的操作，或者在核心操作函数之前或之后执行额外的逻辑。例如，可以创建一个装饰函数，该函数在文件读取之前执行某种安全性检查。

这个过程在内核文件系统中不是以传统的面向对象方式来实现，但其思想类似于装饰器模式。通过装饰函数，开发者可以在不修改核心文件系统操作的情况下添加额外的功能或修饰功能。

请注意，内核开发通常需要更多的底层编码技巧和对内核架构的深刻理解。因此，虽然装饰器模式的思想可以在内核中找到对应，但实现方式可能会有所不同。此示例仅为了说明在内核中如何使用类似装饰器模式的思想。

==（hooks函数是不是就可以认为是装饰器模式？）==

# 参考资料

1、一文讲解Linux内核中的设计模式

https://zhuanlan.zhihu.com/p/657369033