---
title: Linux内核之位置无关代码
date: 2019-12-06 16:48:46
tags:
	 - Linux
---

1

位置无关代码是怎么产生的？

在编译选项里加上-fPIC就可以了。

**实际上是对符号的重定位方式进行不同的标记。**

链接的时候，根据不同的重定位方式，生成真正的重定位代码。



位置无关代码的原理：

**访问变量或者函数的时候**，**使用相对地址来做，**而不是绝对地址。

是不是很简单？



位置无关代码的相关数据结构：

1、.got表，用于变量的查找。

2、.got.plt表，用于函数的查找。

3、.plt表。这个是为了延迟绑定。



2个概念：

加载域。例如flash。

运行域。例如ram。

从上面的分析可知**bootloader转移到内核运行的时候**第一个运行的实际上还不是真内核的内容，而只是内核前面的那段解压缩代码



那么到底到什么时候PIC代码才结束呢？

答案是，压缩代码解压完毕并跳转到真正内核入口运行，**并在执行完一些初始化的工作后打开mmu，这时候才是PIC代码结束的时候。**

那为什么是这样呢？

上面已经说到，内核是从0xC0008000开始链接的，

但是代码实际上是放在0x30008000的地方，0xC0008000这段地址在s3c2410中又是保留的地址，不是实际的RAM，

**因此没有办法使用像uboot、vivi那样的重定位方式来解决运行域与加载域不一致的矛盾，**

**只能通过虚拟内存映射的方法，将物理上的0x30008000映射为虚拟的0xC0008000**，这样运行域就与加载域一致了。

**因此在使用mmu之前的代码必须是位置无关的，否则代码将无法运行。**



参考资料

1、关于位置无关代码

https://www.jianshu.com/p/00ed1957dd70

2、bootloader与linux中位置无关代码的分析理解

https://blog.csdn.net/soar_dream/article/details/51592198