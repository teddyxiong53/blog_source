---
title: Linux之fork
date: 2018-01-31 13:57:01
tags:
	- fork

---

--

说到fork，首先，fork是linux的一个系统调用。

但是，fork同样有个同名的C库函数。

fork的字面含义叉子，分支的意思。

我们下面默认讨论fork库函数的行为。

# fork的过程

1、fork一次调用，返回两次。这是一种神奇的用法。

2、一次返回子进程的pid，一次返回0，

3、我们自己写代码取得返回值，非0那个分支，就是父进程自己后面的处理，一般都是退出。

4、==0那个分支，就是子进程自己的处理，里面一般是调用exec函数。==

5、子进程是父进程的拷贝。子进程得到了父进程的数据空间、堆和栈的副本。

6、但是实际上，子进程拿到父进程的副本，基本是用不上的。所以如果直接拷贝副本，就是白费力。所以现在fork都这样实现：把上面这些副本标记为只读的，如果父进程或者子进程由修改其中的内容，只把修改的部分另外制作副本。这就是COW（copy on write）的技术。提高了fork的效率。

7、父进程的所欲的fd，子进程也都可以用。

# fork之后，父进程先执行还是子进程先执行？

不确定，取决于os的调度算法。

不过我们可以用进程间通信来控制。

# fork失败的原因

主要有2个原因：

1、系统里的进程已经太多了。

2、该用户的创建的进程数已经超过限制了。

# fork之后的处理

一般有这么两种情况：

1、父进程希望子进程复制自己。让子进程跟自己同时执行不同的代码。这个在服务器程序上是常见的。

2、fork之后，马上调用exec。shell程序就是这样使用情况。

第二种情况，其实是更加普遍存在的，所以可以优化一下。

把fork和exec合起来，变成一个spawn函数。

我们可以简单看看musl库里的实现。

```
posix_spawn
	__posix_spawnx
		__clone(child)
			看child里面
				args->exec
```

# vfork

各种系统基本都支持它。

但是大家认为它不太好。为了可移植性，不推荐使用。

vfork就是执行exec的那种情况。



vfork跟fork的不同：

1、vfork保证子进程先运行，而且父进程要等子进程完了才能继续运行。



为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址
空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工
作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与
父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中
运行，所以子进程不能进行写操作，并且在儿子 霸占”着老子的房子时候，要委屈老子一
下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的
房子了，这时候就相 于分家了。



https://blog.csdn.net/jianchi88/article/details/6985326



# zombie进程

如果子进程先于父进程结束，而父进程没有对子进程进行善后处理。子进程就会变成zombie。

父进程的处理就是wait子进程。

zombie进程会占用pid不释放，多了就会导致分配不到pid的。

zombie也是你没法kill掉的，因为已经是dead状态了。

可以把球踢给init进程，谁叫你是大佬呢是吧。杀掉父进程就可以了干掉zombie进程。

另外，init收养的孤儿进程，是不会变成zombie的，因为init考虑很周全。已经wait了。

##怎么避免zombie进程的出现？

1、子进程退出的时候，会给父进程发一个signal，叫SIGCLD。父进程处理这个信号就好。

这种方式，对于非常频繁的fork，可能就会漏掉很多，因为signal不可靠。

2、最靠谱的还是，父进程wait子进程。

3、但是，还有一个妙招。就是fork两次。



# wait函数

父进程调用wait的时候，子进程的情况可能是：

1、没有子进程。直接返回错误。

2、有子进程，已经结束了。马上返回子进程的pid。

3、有子进程，都在运行呢。那就等。

wait是对waitpid的封装。musl libc的实现是这样的：

```
pid_t wait(int *status)
{
	return waitpid((pid_t)-1, status, 0);
}
```

# 其他

stdout连接到终端的时候，是行缓冲的，否则是全缓冲。

重定向父进程的stdout的时候，子进程的也被重定向了。

# exec和fork的区别

`exec` 和 `fork` 是用于进程创建和替换的两个不同的系统调用，它们在操作系统中扮演不同的角色和执行不同的任务。

1. **`fork`**：
   - `fork` 是用于创建一个新进程的系统调用。
   - 调用 `fork` 后，操作系统会在当前进程的基础上创建一个几乎完全相同的子进程，包括代码、数据、打开的文件描述符等。
   - 子进程和父进程的唯一区别是它们的进程 ID（PID）和父进程 ID（PPID）。子进程的 PID 是新的，而 PPID 是父进程的 PID。
   - `fork` 通常用于创建一个子进程，以便在子进程中执行与父进程相同的程序。这样可以实现并行执行、并发编程等。

2. **`exec`**：
   - `exec` 是用于替换当前进程的系统调用。
   - 调用 `exec` 会加载一个新的程序映像，用新的程序替代当前进程的代码和数据。
   - 新程序可以是同一程序的不同版本，也可以是完全不同的程序。
   - `exec` 调用不会创建新进程，而是在当前进程内部执行程序替换。因此，它通常用于在当前进程内部切换到不同的程序。

总结：
- `fork` 用于创建新的进程，保持当前进程的副本，并在新进程中执行相同的程序。它常用于并行编程和创建子进程。
- `exec` 用于替换当前进程的代码和数据，以加载新的程序。它常用于在一个进程内部切换到不同的程序，例如，用于执行不同的命令或程序。==在这种情况下，进程的 PID 和 PPID 不会改变。==