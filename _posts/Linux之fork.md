---
title: Linux之fork
date: 2018-01-31 13:57:01
tags:
	- fork

---



说到fork，首先，fork是linux的一个系统调用。

但是，fork同样有个同名的C库函数。

fork的字面含义叉子，分支的意思。

我们下面默认讨论fork库函数的行为。

#fork的过程

1、fork一次调用，返回两次。这是一种神奇的用法。

2、一次返回子进程的pid，一次返回0，

3、我们自己写代码取得返回值，非0那个分支，就是父进程自己后面的处理，一般都是退出。

4、0那个分支，就是子进程自己的处理，里面一般是调用exec函数。

5、子进程是父进程的拷贝。子进程得到了父进程的数据空间、堆和栈的副本。

6、但是实际上，子进程拿到父进程的副本，基本是用不上的。所以如果直接拷贝副本，就是白费力。所以现在fork都这样实现：把上面这些副本标记为只读的，如果父进程或者子进程由修改其中的内容，只把修改的部分另外制作副本。这就是COW（copy on write）的技术。提高了fork的效率。

7、父进程的所欲的fd，子进程也都可以用。

# fork之后，父进程先执行还是子进程先执行？

不确定，取决于os的调度算法。

不过我们可以用进程间通信来控制。

# fork失败的原因

主要有2个原因：

1、系统里的进程已经太多了。

2、该用户的创建的进程数已经超过限制了。

# fork之后的处理

一般有这么两种情况：

1、父进程希望子进程赋值自己。让子进程跟自己同时执行不同的代码。这个在服务器程序上是常见的。

2、fork之后，马上调用exec。shell程序就是这样使用情况。

第二种情况，其实是更加普遍存在的，所以可以优化一下。

把fork和exec合起来，变成一个spawn函数。

我们可以简单看看musl库里的实现。

```
posix_spawn
	__posix_spawnx
		__clone(child)
			看child里面
				args->exec
```

# vfork

各种系统基本都支持它。

但是大家认为它不太好。为了可移植性，不推荐使用。

vfork就是执行exec的那种情况。



vfork跟fork的不同：

1、vfork保证子进程先运行，而且父进程要等子进程完了才能继续运行。



为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址
空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工
作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与
父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中
运行，所以子进程不能进行写操作，并且在儿子 霸占”着老子的房子时候，要委屈老子一
下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的
房子了，这时候就相 于分家了。



https://blog.csdn.net/jianchi88/article/details/6985326



# zombie进程

如果子进程先于父进程结束，而父进程没有对子进程进行善后处理。子进程就会变成zombie。

父进程的处理就是wait子进程。

zombie进程会占用pid不释放，多了就会导致分配不到pid的。

zombie也是你没法kill掉的，因为已经是dead状态了。

可以把球踢给init进程，谁叫你是大佬呢是吧。杀掉父进程就可以了干掉zombie进程。

另外，init收养的孤儿进程，是不会变成zombie的，因为init考虑很周全。已经wait了。

##怎么避免zombie进程的出现？

1、子进程退出的时候，会给父进程发一个signal，叫SIGCLD。父进程处理这个信号就好。

这种方式，对于非常频繁的fork，可能就会漏掉很多，因为signal不可靠。

2、最靠谱的还是，父进程wait子进程。

3、但是，还有一个妙招。就是fork两次。



# wait函数

父进程调用wait的时候，子进程的情况可能是：

1、没有子进程。直接返回错误。

2、有子进程，已经结束了。马上返回子进程的pid。

3、有子进程，都在运行呢。那就等。

wait是对waitpid的封装。musl libc的实现是这样的：

```
pid_t wait(int *status)
{
	return waitpid((pid_t)-1, status, 0);
}
```

#其他

stdout连接到终端的时候，是行缓冲的，否则是全缓冲。

重定向父进程的stdout的时候，子进程的也被重定向了。

