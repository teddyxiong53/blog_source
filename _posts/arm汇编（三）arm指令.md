---
title: arm汇编（三）
date: 2018-02-02 13:47:58
tags:
	 - arm
typora-root-url: ..\
---



# arm模式

arm总共有7种模式：

1、用户模式。usr

2、中断。irq

3、快中断。fiq

4、管理。svc（supervisor）

5、终止。abort

6、未定义。undef

7、系统模式。sys。

# arm寄存器

arm提供了31个通用寄存器，其中16个是一直可以访问的。另外15个是用来加快异常处理用的。

一直可见的这16个寄存器，叫做UserMode寄存器。

UserMode的特点：

1、只能通过产生一个exception，才能切换到其他的mode。一般用swi这一条指令。

2、存储系统和协处理会限制UserMode的访问范围。用来保护OS。

16个基本寄存器，最后3个又有专门用途。分别是sp、lr、pc。（顺序记忆，用各自的第一个字母，得到slp，实力派）。

寄存器就可以从下面这里数出来。

状态寄存器有6个，1个通用CPSR，其他的特权模式各有一个特殊的。注意，名字是叫SPSR了。

通用寄存器16个通用。特权模式有15个（看加了三角阴影的那些）。

![arm汇编（三）-arm寄存器.jpg](/images/arm汇编（三）-arm寄存器.jpg)



##CPSR的位定义

总共32位，最高4位为标志。nzcv（记忆方法：女主持）

中间20位保留。

最低8位为控制位。

bit7到bit5是IFT。I代表irq禁止（1表示禁止，因为要默认使能），F代表fiq禁止，T代表Thumb使能。记忆（爱福田）。

跟上面一起记忆，就是女主持爱福田。

bit4到bit0就是用来表示usr、sys、irq那7种模式的。

给cpsr寄存器，配了2个指令来进行访问。

mrs和msr。

记忆方法：mrs：read special。读取特殊寄存器。是从CPSR里读取到R0这种普通寄存器。另外一个相反就好了。

另外还配了2个指令来开关中断的。

cpsid i/f

cpsie i/f

d表示disable，e代表enable

i代表interrupt。f代表fiq。

irq和fiq的区别又是什么呢？

1、irq可以被fiq打断。fiq优先级比irq高。

那是不是可以这样理解：fiq高优先级的irq？

怎么指定fiq呢？

1、可以在中断控制器里配置某个中断是irq还是fiq。

2、同一时刻，只能有一个中断是fiq的。



# arm传参的方法

1、用r0到r3来放函数是前4个参数，r0放左边起第一个参数，以此类推。

# cp15协处理器

cp15协处理器是用来进行存储管理。mmu那些事情。

给它分配了2个指令。

mcr和mrc。记忆方法跟mrs一样。规律也是一样的。mrc，read coprocessor。读取协处理器到主处理器。

指令格式：

```
mrc{cond} coproc,opcode1, Rd, CRn, CRm, opcode2
```

coproc：协处理器的名字。P0到P15 。我们用的是p15这种。带16个寄存器的。

opcode1：协处理器的特定操作码。对cp15，一定要是0 。

Rd：主处理的寄存器。

CRn：放第一个操作数的协处理器寄存器。

CRm：放第二个操作数的协处理器寄存器。

opcode2：可选的协处理器操作码。一般也是 0 。



C12寄存器一般是用来放异常向量基地址的。arm7、arm9不能修改这个地址。只能是在0或者0xffff 0000 。

cortex-a的可以修改。



# arm指令概述

1、从指令长度上看，arm指令属于定长指令，所有的指令都是32位。（x86的就是变长指令，不同指令长度不同）。

2、从cpu结构上看，arm的寄存器比x86的更多。

arm指令格式：

```
|31   28 | 27 26  25 | 24 | 23 | 22 | 21 | 20 | 19  16| 15  12| 11           0|
-------------------------------------------------------------------------------
| cond   |  0  0  I  |      opcode       |  S | Rn    |   Rd  |shifter_operand|
```

cond：指令执行的调节码。总共16种情况。

opcode：指令操作编码。

S：决定指令是否影响CPSR寄存器。

Rn：包含第一个操作数的寄存器编码。有的地方说是叫SBZ。Should Be Zero。

Rd：目标寄存器编码。

shifter_operand：第二个操作数。也叫operand2





## cond

指令执行过程会出现这么几种情况：

1、执行结果为0

2、执行结果溢出。

3、执行结果为负。

4、两个操作数的大小判别。

上面4个情况分别对应CPSR寄存器里的Z/V/N/C这4个位。

| cond | 助记符   | 标志      | 含义        |
| ---- | ----- | ------- | --------- |
| 0000 | eq    | z=1     | 相等        |
| 0001 | ne    | z=0     | 不相等       |
| 0010 | cs/hs | c=1     | 无符号数大于或等于 |
| 0011 | cc/lo | c=0     | 无符号数小于    |
| 0100 | mi    | N=1     | 负数        |
| 0101 | pl    | N=0     | 非负数       |
| 0110 | vs    | v=1     | 溢出        |
| 0111 | vc    | v=0     | 没有溢出      |
| 1000 | hi    | C=1，Z=0 | 无符号数大于    |
| 1001 | ls    | C=0，Z=1 | 无符号数小于或等于 |
| 1010 |       |         |           |
| 1011 |       |         |           |
| 1100 |       |         |           |
| 1101 |       |         |           |
| 1110 |       |         |           |
| 1111 |       |         |           |

##25位I

表示operand2是否是立即数。1表示是。0表示不是（那就是寄存器了）。

```
1、不是立即数的情况。
bit11到bit4表示：Rm可以加的偏移。（没太懂）
bit3到bit0表示：Rm。第二个操作数所在的寄存器。16种情况，刚好覆盖完。
2、是立即数的情况。
bit11到bit8：立即数的偏移。
bit7到bit0: 8位无符号数。
```

我们把`mov r0, r0`这条指令翻译成对应的机器码看看：

## opcode

4bit，也是16种情况。这个是指令码。为什么是16种呢？



0000: and。op1 and op2的值赋给Rd。

0001:eor。 op1 eor op2

0010: sub。op1 - op2 

0011:rsb。 op2 - op1

0100: add。 op1 + op2

0101: adc。op1 + op2 + C

0110: sbc。 op1 - op2 + C -1

0111: rsc。op2 - op1 +C -1

1000：tst。

1001：teq。

1010：cmp。

1011：cmn。

1100：orr。

1101：mov

1110：bic。

1111：mvn。把not op2赋值给Rd。



# arm机器码计算

1、`mov r1, #0x64`

对应的机器码是E3A01064。怎么算的。

cond的4个bit；1110。1110适用于任何条件。

接下来2个00，这个好像没有明确的定义的。

任何bit25的I是1，因为是立即数寻址。

opcode是1101，就是mov的指令码。

S为0，mov没有S。

SBZ，当然就是0了。

Rd，是R1，对应就是0001

立即数：0x64 。

2、`movs pc, r14`。

cond；1110

2个00

I为0，寄存器方式。

1101，move指令码。

S为1，这个movs有S标志。

SBZ，都是0

Rd为R15，就是1111

op2：是R14，就是0000 0000 1110

3、`movlt r3, #01`

cond： 1011，lt的是这个。

2个00.

I为1：表示立即数。

1101：表示mov

S为0

SBZ为0

Rd为0011，因为是R3寄存器。

op2位1，是立即数1



#ldr

```
|31   28 | 27 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19  16| 15  12| 11     0|
--------------------------------------------------------------------------
| cond   |  0  1 | I  |  P | U  | 0  | W  |  1 | Rn    |   Rd  |addr_mode|
```

ldr指令的32个bit定义如上所述。

```
ldr {<cond>} <Rd>, <addressing_mode>
```

举例：

```
ldr r0, [r1]; r1相当于一个指针，把对应的内存数据取出来。
ldr r0, [r1,r2]; r1+r2=addr。从addr取数据。
ldr r0, [r1,#8]; 将r1+8=addr
ldr r0, [r1,r2]!; 除了取数据，还把r1+r2表示的地址写入到r1
ldr r0, [r1,#8]!;
ldr r0,[r1],r2; 将r1表示的内存数据放入到r0，把r1+r2写入到r1
ldr r0, [r1, r2, lsl#2]; r1+r2<<2=addr, 然后把addr写入到r1
```

arm是risc架构，数据从内存到cpu之间的移动只能通过ldr和str指令。

> 注意：
>
> 另外gnu as有个伪指令，也叫ldr。名字一模一样，别弄混了。
>
> 例子是这样：
>
> ```
> ldr r0, =0x12345678
> ```
>
> 是吧0x12345678写入到r0，这个伪指令的作用跟mov是比较相似。那么为什么要这个伪指令呢？
>
> mov后面跟的立即数地址有限制，而ldr这伪指令没有限制。最后这ldr会被汇编器处理成mov的。



# ldmfd和stmfd

这个是ldr指令的扩展。

m：multiple。

f；full

d；descending。递减的意思。这个位置还可以是a，表示递增。

一般用在堆栈操作这里。

ldmfd是出栈。

stmfd是入栈。



# bl

类似的跳转指令还有b指令。

b指令，是单纯的跳转指令，cpu会直接跳到对应的地址执行。

bl指令，名字上多了一个l，l代表的是link，表示带分支的跳转。link表示是Link Register，是R14，也叫lr。

就是在跳转之前，把pc（r15）放到lr（r14）里，到跳转的函数执行完之后，加一句 `mov pc, lr`就可以返回来继续执行了。就像C语言里的调用函数一样的。

还有bx和blx。区别有在哪里呢？x表示切换的意思，表示thumb指令和arm指令切换。我不管它。因为不混用。



# bic

bit clear的意思。

用法：

```
bic r0, r0, #0xf ;作用是将低4位清零。运算过程是：先把r0的值和0xf的反码进行与操作，再复制给r0
```

一起使用的还有orr指令。

bic清零，orr置位。

```
orr r0, r0, #0x13
```



# tst

其实，tst和and做的是一样的运算，只是tst不管结果值是多少，只管是不是0 。



# dsb

清缓存的。

