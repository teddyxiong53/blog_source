---
title: linux虚拟内存理解
date: 2017-02-20 22:56:29
tags:
	- Linux
	- 虚拟内存
typora-root-url: ..\
---
虚拟内存是一种内存管理技术。

它产生这样的效果：

App认为自己有用连续可用的内存，而这个内存实际上在物理上是分布在多个页的，有的还可能缓存在磁盘上。

在C语言编程里，我们可以用`&`来获取变量的地址，这个地址就是一个虚拟地址。

实现虚拟内存的一个步骤就是内存的分页，页大小一般是4K。

x86的分段机制，在Linux没怎么使用。

Linux里一个进程的地址分布情况：

![](/images/Linux进程内存布局.jpg)

从0x0到0x0804 0000是保留区域，所以NULL可以用来做空指针判断。
从图里面，还可以看到堆上往上增长的，栈是往下增长的。

同一个进程的多个实例，text段是可以共享的。

所有进程都认为自己被加载到了0x0804 000这个位置。

所有进程共享同一个物理内存，每个进程只把自己目前需要的虚拟内存存储到物理内存上。

进程需要知道哪些虚拟地址的内存在物理内存上，哪些又不在，这个信息用页表来描述。

页表包括：

1、是否在物理内存上，yes或no。

2、如果yes，那么在物理内存的哪一页。

如果进程用到的某个虚拟地址，发现不在物理内存上，触发缺页中断，把对应的数据从硬盘拷贝到物理内存，如果当前物理内存满了，就把一个暂时不用的页写入都硬盘，腾出空间来用。

这种处理方式带来的好处：

1、每个进程的内存空间布局都一样的，而且是固定的，linker干活就比较简单了，不用花心思去关注链接地址。

2、动态库，内存里只需要放一份就够了。

3、可以利用物理内存碎片。



在进程创建的时候，内核只是为进程创建了虚拟内存的布局，

对应到代码的实现，就是初始化task_struct里的内存相关链表。

这个时候，还没有把elf文件的text段、data段拷贝到物理内存。

只是建立了硬盘和虚拟内存的映射关系。（这一步叫做存储器映射）。

等到运行时需要相关数据的时候，就靠缺页中断来拷贝数据进来用。



一个更加详细的图。这个图解答了我的一个疑惑，用户进程的页表存放在进程空间 。

![Linux进程虚拟地址空间](/images/Linux进程虚拟地址空间.png)

64位系统的地址空间。

```
事实上， 64 位系统的虚拟地址空间划分发生了改变： 
1、地址空间大小不是2^32，也不是2^64，而一般是2^48。

因为并不需要 2^64 这么大的寻址空间，过大空间只会导致资源的浪费。64位Linux一般使用48位来表示虚拟地址空间，40位表示物理地址， 
cat /proc/cpuinfo 
address sizes   : 42 bits physical, 48 bits virtual

2、其中，0x0000000000000000~0x00007fffffffffff 表示用户空间， 0xFFFF800000000000~ 0xFFFFFFFFFFFFFFFF 表示内核空间，共提供 256TB(2^48) 的寻址空间。 
这两个区间的特点是，第 47 位与 48~63 位相同，若这些位为 0 表示用户空间，否则表示内核空间。 
3、用户空间由低地址到高地址仍然是只读段、数据段、堆、文件映射区域和栈；
```

查看某个程序的发生缺页异常的次数。用下面的命令。这个是查看bash触发缺页异常的次数。

```
teddy@teddy-ubuntu:~/work/linux2.6/linux$ sudo ps -o majflt,minflt -C bash
MAJFLT MINFLT
     0   1375
     0   5993
     0   2296
     4   2701
     0    206
```

majflt是major fault，叫大错误。要重点关注。majflt对性能的影响是致命的。



发生缺页异常的时候，会执行哪些操作？

1、陷入到内核态，检查要访问的地址是否合法。

2、查找或者分配一个物理页。

3、填充物理页内容，可以是读取磁盘，也可以是全部清理，也可以是什么都不做。如果这一步是要读取磁盘，就会把majflt加一。否则就是minflt加一。

4、建立映射关系。



# 内核地址空间



![内核内存空间分布](/images/内核内存空间分布.png)



1、kmalloc、get_free_pages都是从物理内存映射区得到内存，在物理地址是连续，它们跟真的物理地址只是相差一个固定的偏移量。

在物理内存映射区内，可以用virt_to_phys来得到物理地址。用phys_to_virt得到虚拟地址。

2、vmalloc的虚拟内存映射区。前后的8M和8K，是gap，防止越界的。

vmalloc分配的内存，都对应一个vm_struct结构体（在vmalloc.h里定义）。跟vm_area_struct不同。







# 内核里分配内存最大可以分配多少？

这个应该是受物理内存的限制的，分多少给多少。要多了，就会失败。

# 0x0804 000这个地址怎么定的？

1、准确来说，这个地址是针对x86的32位架构的。

2、这个地址应该是从SystemV i386 ABI那边借用过来的。

网上找到一段话：

```
On 386 systems, the text base address is 0x08048000, which permits a reasonably large stack below the text while still staying above address 0x08000000, permitting most programs to use a single second-level page table. (Recall that on the 386, each second-level table maps 0x00400000 addresses.)
```

意思是为了在text段下面容纳一个足够大的栈。

（感觉还是没有搞清楚，先放着）

有的说低于0x0804 0000的，是C库在用。

用户使用会报segment Fault的。



进程的虚拟地址和内核的虚拟地址有一点不同：

内核的虚拟地址如果出现缺页中断，系统就会panic掉。而用户进程的则不会。

为什么这样设计？

因为如果内核的虚拟地址缺页中断后，进行中断处理的时候，还有可能继续发生 缺页中断，如此死循环了。所以要限制。

那么是怎么做到内核上下文不出现缺页中断呢？

最简单的方法就是把所有的物理内存映射到内核的某段虚拟地址空间上，这样就不会出现缺页中断了。（没太懂）



# 高端内存

从0xc000 0000开始的1G的内核空间，在0XC000 0000 + 892M的位置分开，低的叫低端内存，高的叫高端内存。

内核空间的虚拟地址是从0xc000 0000开始的1G。这1G空间其实分了3个部分：

1、从开头（就叫0吧）16M。这个叫zone_dma。

2、从16M到896M。这个叫zone_normal。

3、从896M到最后。这个叫zone_highmem。

## 为什么需要高端内存？

我们先假定物理内存是从0x0000 0000开始的。

内核空间和物理内存有一个基本的一一映射关系。

如果没有高端内存，那么内核只能访问1G的物理内存空间，电脑安装的4G内存条就成了摆设。

我们把内核空间的1G分出高端内存后，我们就可以借用高端的那128M来访问到电脑的所有的4G的物理内存。

举例说明。

内核想要访问在物理地址2G位置开始的1M的内存，物理地址就是：0x8000 0000 到0x8010 0000这里。

内核先自己找到一段暂时不用的线性地址空间，例如0xF8700 000到0XF880 0000这段。用这1M的地址空间映射前面的那1M的物理地址空间。

用完之后，解除这个映射关系。这样其他代码还可以继续使用0XF8700 0000这里的这1M的地址空了。



## 其他疑问

1、用户空间是否有高端内存的概念？

没有。用户进程最多可以访问3G的物理内存，而内核进程可以访问所有物理内存。

2、64位系统有高端内存吗？

没有。当前物理内存还没有超出64位内核地址空间范围。

3、物理内存不超过896M，就不需要高端内存。



# Android系统的一个内存分析实例

文章链接在这：http://blog.csdn.net/crazyjiang/article/details/7903772

现在我总结一下。

分析的对象是Cortex A9 ，用1G的内存。

为了加深印象，我把原图自己画一遍。

![一个安卓系统内存布局](/images/一个安卓系统内存布局.png)

这个图可以和linuxDocumentations目录下的文档参照着看。

1、modules和pkmap。是在内核空间下面一点。跟x86上标准的不同。

modules要放在这里，是因为kernel的text段就在0xc000 0000这个位置，距离要在32M以内。

2、从CP Memory到pmem（包括），是low mem。这段的映射是平坦的一一映射。也就是说，kernel初始化这段映射后，页表将不会改变，这样可以避免不断修改页表。这段地址空间非常珍贵，因为映射效率很高。

这部分总大小是512M：

1）128M给了pmem。（这个是Android特有的连续内存管理机制）。

2）16MB给了CP。

所以剩余可用的lowmem只有360M左右。

3、high mem部分，有比较多的没有用到的。

然后我们看1G地址空间跟1G的物理内存的映射关系。

![一个安卓系统内存布局-地址映射](/images/一个安卓系统内存布局-地址映射.png)

事实上，这个映射是有问题的。

在用monkey test长期运行测试后，会出现vmalloc失败。

出错信息是说graphic模块在调用vmalloc分配1M空间时会失败。

分析：

1、通过/proc/meminfo查看，MEMFree还有156M，VmallocTotal-VmallocUsed也还剩下22M。

2、从数据上看，vmalloc的内存还是有的，但是vmalloc要求虚拟地址是连续的，那么可能就是没有连续1M的虚拟地址了。

3、那我们就看看/proc/vmallocinfo的内容。我们看到vmalloc已经用到了0xefeff000了。0xf000 0000减去这个，得到0x101000,1M多一点，而前面我们要分配的比这个要多，是0x1a0000 。

4、为什么会出现情况呢？

我们看看/proc/buddyinfo。buddy系统，是把内存分成16个链表，从2的0次方到2的15次方。单位是页（4KB）。如果要分配的内存介于`2^4`到`2^5`之间，就给`2^5`。

从这里，我们可以看出目前，最大只能分配出2^7这个大小的内存了。

于是我们可以得出结论，graphic通过get_free_pages向kernel的buddy系统申请连续内存，过了一段时间，buddy系统产生了大量的碎片。graphic无法获取连续的物理内存。因此想通过vmalloc申请不连续的内存，不幸的是，vmalloc的虚拟地址空间耗尽。尽管还有很多的物理内存，还是出现了申请失败。

5、解决的办法，就是修改上面的内存配置，上面not used解决200M。

挪出来给lowmem，现在lowmem加大到720M。上面的not used还剩1M来占位。



# linux页表有多少级？

linux内核采用了一种同时可以适应32位和64位的分页模型。对于32位，二级页表就够了。对于64位，需要四级页表。

四级页表分别：

1、页全局目录。PGD。

2、页上级目录。PUD。

3、页中间目录。PMD。

4、页表。Page Table。

可以按照文件夹和文件的层次关系来帮助理解记忆。

## 伙伴算法

简单说，就预先给出一系列的不同尺寸的内存块。

我感觉像是rtos里的内存池的概念。

## slab算法

就是单独给内核对象开小灶，单独给一块内存，为各种内存对象用。



# 什么情况下使用vmalloc函数

kmalloc：

申请小的、连续的物理内存。单位是字节。

一般只有硬件设备才需要物理地址连续的内存。

kmalloc一次不能分配超过128K的内存。

vmalloc：

申请较大的内存，虚拟地址连续，物理地址不连续。

这个可以最大分配到1G这种大小级别的内存。

# 内核空间

内核空间和用户空间都是在虚拟空间里进行的讨论。

内核空间在虚拟空间里是占用3G开始的1G空间，但是物理内存往往是从0开始的，所以这里有一个简单的线性关系。在内核里叫做PAGE_OFFSET。

在树莓派上是：

```
CONFIG_PAGE_OFFSET=0x80000000
```

因为树莓派配置的是2G/2G的划分方案。





# 参考资料

1、linux环境内存分配原理 mallocinfo

这篇文章 特别好。

https://www.cnblogs.com/dongzhiquan/p/5621906.html

2、linux 用户空间与内核空间——高端内存详解

https://www.cnblogs.com/zlcxbb/p/5841417.html