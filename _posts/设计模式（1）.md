---
title: 设计模式（1）
date: 2020-11-05 15:55:30
tags:
	- 设计模式
---

1

1. 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
2. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
3. 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
4. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
5. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
6. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
7. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
8. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
9. 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。
10. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
11. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
12. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
13. 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
14. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
15. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
16. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
17. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
18. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
19. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
20. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
21. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
22. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
23. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

# 简单工厂模式

## 优点

这个模式存在的价值是什么？

1、工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；

2、简单工厂模式通过这种做法**实现了对责任的分割**，它提供了专门的工厂类用于创建对象。

3、客户端**无须知道所创建的具体产品类的类名**，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以**减少使用者的记忆量**。

4、**通过引入配置文件**，可以在**不修改任何客户端代码**的情况下**更换和增加新的具体产品类**，在一定程度上提高了系统的灵活性。



简单来说：

1、责任划分更明确。

2、减少使用者的记忆量。

3、增减产品的时候，客户端不用改。



## 缺点

1、由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。

2、使用简单工厂模式将会**增加系统中类的个数**，在一定程序上增加了系统的复杂度和理解难度。

3、系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。

4、简单工厂模式由于使用了静态工厂方法，**造成工厂角色无法形成基于继承的等级结构**。



参考资料

1、使用简单工厂模式的优点是什么？

https://zhidao.baidu.com/question/131823823.html



# 工厂方法模式

跟简单工厂的不同。

1、工厂也进行抽象。每一种产品，都对应专门生产这种产品的工厂。

这样的确定很明显，就是增减了大量的类。



简单工厂模式的工厂只有一个。

工厂方法模式的工厂有多个。



# 抽象工厂模式

从名字上看，也是对工厂进行了抽象。

那么跟工厂方法模式的区别在哪里呢？

抽象工厂模式的工厂，可以生产多种产品。

以白色衣服和黑色衣服为例，白色衣服为一个产品系列，黑色衣服为一个产品系列。

白色上衣搭配白色裤子，   黑色上衣搭配黑色裤字。

每个系列的衣服由一个对应的工厂创建，这样一个工厂创建的衣服能保证衣服为同一个系列。

# 单例模式

单例模式分为懒汉和饿汉两种实现方式。

## 懒汉式

非线程安全版本。

这个简单。可以说明本质。

```
class Singleton
{
public:
    static Singleton* getInstance()
    {
        if(m_singleton == NULL) {
            m_singleton = new Singleton();
        }
        return m_singleton;
    }
    ~Singleton();
private:
    Singleton()
    {
        //私有构造，空的就行。
    }
    Singleton(const Singleton& ) = delete;
    Singleton& operator=(const Singleton& ) = delete;

    static Singleton* m_singleton;
};
Singleton* Singleton::m_singleton = NULL;
```

要线程安全。就加上mutex来锁一下。

然后double check。

```
    static Singleton* getInstance()
    {
        if(m_singleton == NULL) {
            std::lock_guard lock(g_mutex);
            if(m_singleton == NULL) {
                m_singleton = new Singleton();
            }
        }
        return m_singleton;
    }
```

## 饿汉式

就是默认这里就创建。

```
Singleton* Singleton::m_singleton = new Singleton();
```

# 原型模式

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。

这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，**该接口用于创建当前对象的克隆**。

**当直接创建对象的代价比较大时，则采用这种模式。**

例如，一个对象需要在一个高代价的数据库操作之后被创建。

我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

以下情形可以考虑使用原型模式：

- 当new一个对象，非常繁琐复杂时，可以使用原型模式来进行复制一个对象。比如创建对象时，构造函数的参数很多，而自己又不完全的知道每个参数的意义，就可以使用原型模式来创建一个新的对象，不必去理会创建的过程。
- 当需要new一个新的对象，这个对象和现有的对象区别不大，我们就可以直接复制一个已有的对象，然后稍加修改。
- 当需要一个对象副本时，比如需要提供对象的数据，同时又需要避免外部对数据对象进行修改，那就拷贝一个对象副本供外部使用。



关键就是提供一个clone方法。

对于c++来说，就是拷贝构造。

# 建造者模式

builder模式。

将复杂对象的**构建和其表示分离**，使得相同的构建过程可以产生不同的表示。

产品之间差异性大，内部变化较大、较复杂时不建议使用建造者模式。



# 策略模式

在策略模式（Strategy Pattern）中，一个类的行为或其算法**可以在运行时更改**。

这种类型的设计模式属于行为型模式。

在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。

策略对象改变 context 对象的执行算法。

## 主要解决

主要是为了解决多种算法类似的情况下，避免引入大量if else分支。

## 什么时候用

一个系统里有许多类。他们的不同只是他们直接的行为。

## 关键

实现同一个接口。

## 生活例子

旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略

## 优点

避免写很多条件判断。

扩展性好。

## 缺点

几乎所有设计模式，都有带来更多类的的缺点。

这个也不例外。



参考资料

1、C++ 常用设计模式（学习笔记）

主要参考这篇。

https://www.cnblogs.com/chengjundu/p/8473564.html

2、菜鸟教程

这个系列也很系统。

https://www.runoob.com/design-pattern/strategy-pattern.html