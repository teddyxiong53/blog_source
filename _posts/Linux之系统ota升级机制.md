---
title: Linux之系统升级机制
date: 2018-07-25 10:10:28
tags:
	- Linux

---



更新嵌入式设备最佳的方式是对整个镜像进行更新。

对于Linux，这个问题转化为对分区的更新。

所以分区要仔细考虑。

bootloader分区。尽量避免更新这个。

内核分区。除非有安全问题，否则不更新。

rootfs。一般是只读的。

用户分区。最需要更新的。



有两种可能的镜像更新：

1、对称。

```
有2个bootloader分区。2个kernel分区。2个rootfs分区。2个用户分区。
可以在更新过程中取消。
```

2、非对称。

```

```



基于镜像的更新软件有：

1、swupdate。

2、RAUC。



嵌入式设备位置分散、数量庞大、部署地点情况复杂。

因此对这些设备进行升级，肯定是无法采取单个、本地升级。太费时费力。

看看怎么进行远程批量自动升级。

最好可以通过web界面实时查看升级的情况。



一个参考的分区

````
|2M   |8M      | 100M   |16M    |2M    |
----------------------------------------
|uboot| kernel | rootfs | backup| info |
````

分区作用：

```
backup：
	存放要备份的东西，以便升级完成后，从这里再拷贝到新的文件系统里。
info：
	固化信息分区。
	存放版本号，设备类型、设备id等。
```



# 板端的升级管理程序

功能：

```
1、管理版本信息。
2、post设备信息给服务端。
3、从服务端下载升级包。
4、校验、管理升级包。
5、启动升级执行程序。
```



```
1、开机运行，作为守护进程。
2、第一次运行，读取版本信息，存放到info分区里。
3、每隔一段时间上传版本号给服务端，服务端看看是否需要更新（这个让客户端主动，减轻服务端的压力）
4、如果有新版本，给客户端返回镜像下载地址和升级命令。
```

# 升级执行程序

功能：

```
1、解压升级包。
2、备份文件。
3、格式化内核、文件系统分区。
	格式化分区，不影响系统正常运行？
	我觉得把应用单独放一个分区，根文件系统不用升级。
	内核被覆盖，不影响运行。
4、加载升级包里的文件到内核、文件系统分区。
5、重启系统。
6、拷贝备份文件到文件系统里。
```





升级方案需要

```
1、可以更新app，也需要可以更新内核和其他基础组件。
2、要可以避免变砖。
3、应该是原子的。要么成功，要么失败。不能存在第三种状态。这样就有不确定的风险。
4、必须有验证签名机制。
5、ota应该是通过安全通道。
```

怎么做升级方案？

不要自己写，用成熟的开源方案。

有这些：

```
1、swupdate。
2、rauc。
3、mender。
4、ostree、libostree。
5、swupd。
```



为什么不采用桌面系统的包管理的方式进行更新？

因为不是原子的。会带来不可控的东西。

所以只能通过镜像的方式进行更新。



recovery的是ramfs，

**基于recovery的，比ab系统会省空间。**

Android直到N版本才引入ab系统的。之前也是基于recovery的。

**基于recovery的叫单拷贝方式。基于ab系统的叫双拷贝方式。**

单拷贝的分区情况：

```
|bootloader|recovery |normal| data|
```



单拷贝方式的缺点：

```
1、在更新期间，你什么也做不了。
2、没法回退。
```

单拷贝的优点：

```
1、空间会少占用一点。
2、经过多年考验，可靠。
```



双拷贝的分区

```
|bootloader| system a| system b| data |
```

双拷贝的优点：

```
1、升级用户可以没有感知。可以在后台升级。用户下次重启时切换到系统。
2、可以做回退。
```



还有增量升级法。



# 在uboot里实现升级

升级包可以是放在SD卡，也可以放到芯片上的某个分区里。

在uboot里使用网络，不是非常安全。

在uboot里执行脚本是这样：

```
"if fatload usb 0:1 ${loadaddr} ${updatefilename}; then " \
    "source ${loadaddr}; " \
"fi; "
```

脚本的内容可以是这样：

```
# Update Linux kernel
fatload usb 0:1 ${loadaddr} uImage;
nand erase.part kernel;
nand write ${loadaddr} kernel ${filesize};
 
# Update rootfs
fatload usb 0:1 ${loadaddr} ubi.img;
ubi write ${loadaddr} rootfs ${filesize};
```

UBI, and we probably need to use UBIFS if we are to load an update image from the rootfs

# uboot使用ubifs

# genimage工具生成镜像

代码在这里：

https://github.com/pengutronix/genimage

# android ota升级

这个可以作为参考。



参考资料

1、

这个系列文章不错

https://blog.csdn.net/guyongqiangx/article/details/129019303



# Mender

Mender 支持嵌入式 Linux OTA 更新中的系统和应用软件更新。

业内许多人将系统更新称为固件更新或无线固件 (FOTA)。

这通常是引导加载程序、内核和根文件系统。

应用程序或软件无线 (SOTA) 更新是指用户空间中的软件，可以是容器、包、文件和目录。



Mender 使用更新模块执行应用程序更新，该模块允许在设备上安装不同类型的软件。 Mender 还提供了通过使用状态脚本进行自定义更新的自由。



Mender 在部署 OTA 软件更新时的首要指示是安全性和稳健性。

安全可防止设备被攻击者劫持，安装未经授权的软件，并且功能强大，因此更新不会使设备无法使用。

它确保在发生电源或网络连接等故障时有回退模式，并且没有半途而废的软件安装（原子性）。



参考资料

1、

https://mender.io/blog/ota-update-embedded-linux

2、

https://mender.io/user/pages/05.resources/04.whitepapers/embedded-linux/mender-whitepaper-software-updates-for-embedded-linux.pdf

# 差分升级

在嵌入式Linux系统中，实现增量更新的一种常见方法是使用差分包（Delta Update）技术。差分包是一种只包含两个版本之间差异部分的补丁文件，可以将旧版本的系统快速升级到新版本，而无需下载和安装完整的系统镜像。

下面是一个简单的嵌入式Linux增量更新的实现步骤：

1. **生成差分包**：通过比较新旧版本的文件系统，生成表示差异的差分包文件。这可以使用相关工具（如bsdiff、xdelta等）来完成。差分包文件只包含旧版本和新版本之间的变化内容，通常会比完整系统镜像小很多。

2. **传输差分包**：将生成的差分包文件传输到目标设备。可以通过网络传输（如HTTP、FTP等）或者其他可行的方式将差分包文件传输到目标设备上。

3. **应用差分包**：在目标设备上，通过相应的差分包工具加载和应用差分包文件。差分包工具会根据差分包文件的指令，对旧版本的文件系统进行更新和修改，将其变为新版本。

4. **验证更新**：在应用差分包后，进行更新的验证。可以通过检查系统的完整性、功能的正确性、版本号的变化等方式来验证更新的成功与否。

嵌入式Linux增量更新的实现需要注意以下几点：

- 差分包生成的过程需要确保准确性和完整性，以避免在更新过程中出现问题。
- 差分包传输需要考虑网络的稳定性和安全性，以确保差分包文件能够正确传输到目标设备。
- 应用差分包的过程需要进行错误处理和回滚机制，以防止更新失败导致系统不稳定或无法启动。

需要注意的是，嵌入式Linux增量更新的具体实现方式可能因系统和平台而异，可以根据具体需求和条件进行定制和优化。此外，还可以考虑使用其他工具和技术，如基于版本控制系统的增量更新、采用容器化技术等来实现增量更新功能。

# mcu和linux系统的ota的不同

MCU和Linux系统在OTA（Over-the-Air）更新方面有显著差异，主要体现在硬件限制、软件复杂性和更新机制等方面。以下是它们的主要区别：

| **方面**       | **MCU OTA**                        | **Linux系统 OTA**                          |
| -------------- | ---------------------------------- | ------------------------------------------ |
| **硬件资源**   | 资源有限（内存、存储、处理能力）   | 资源相对丰富（更多的内存、存储和处理能力） |
| **更新包大小** | 通常较小（KB级别）                 | 通常较大（MB级别或更高）                   |
| **更新方式**   | 简单的固件替换                     | 文件系统级别的更新，涉及多个包和依赖关系   |
| **网络协议**   | 通常使用轻量级协议（如MQTT、CoAP） | 可以使用多种协议（如HTTP、HTTPS、FTP）     |
| **安全性**     | 基本的加密和验证机制               | 高级的安全机制（如SSL/TLS、签名验证）      |
| **恢复机制**   | 简单的回滚机制，可能需要手动干预   | 复杂的回滚和恢复机制，通常支持自动恢复     |
| **更新触发**   | 固定时间间隔或手动触发             | 可以是定时任务、用户触发或自动检测         |
| **软件栈**     | 固件单体结构，更新整体固件         | 模块化结构，可以更新单个软件包或组件       |
| **依赖管理**   | 无依赖管理                         | 有复杂的依赖管理机制                       |
| **用户交互**   | 通常没有用户交互                   | 可能需要用户确认和交互                     |
| **更新策略**   | 通常为全量更新                     | 支持全量更新和增量更新                     |

这两个系统的OTA设计各有优劣，主要取决于具体应用场景和需求。MCU的OTA更新更注重简洁和高效，而Linux系统的OTA则更注重灵活性和安全性。

# linux的增量ota更新原理

Linux系统的增量OTA更新旨在仅传输和应用相对于现有系统的新变化，从而减少下载的数据量和更新时间。以下是增量OTA更新的主要原理和步骤：

| **步骤**         | **说明**                                                     |
| ---------------- | ------------------------------------------------------------ |
| **差异计算**     | 使用工具（如`bsdiff`、`xdelta`）对比旧版本和新版本的文件或文件系统，生成差异包。差异包仅包含变化的部分。 |
| **差异包传输**   | 将生成的差异包通过网络传输到目标设备。差异包通常比完整的更新包小得多。 |
| **验证差异包**   | 在目标设备上接收差异包后，对其进行完整性和安全性验证，以确保传输过程中的数据未被篡改。 |
| **应用差异**     | 使用工具（如`bspatch`、`xdelta3`）将差异包应用到旧版本上，生成新版本。这涉及到对旧版本的文件进行补丁操作。 |
| **文件系统更新** | 更新后的文件系统或者软件包被替换到正确的位置，完成系统的更新。 |
| **验证更新**     | 更新完成后，对新版本进行验证，以确保其完整性和正确性。可以通过校验和或者签名验证来完成。 |
| **回滚机制**     | 如果更新过程中出现错误，系统应能够回滚到旧版本，确保设备的正常运行。 |

以下是常用的增量更新工具和技术：

| **工具/技术**      | **说明**                                                     |
| ------------------ | ------------------------------------------------------------ |
| **bsdiff/bspatch** | 用于生成和应用二进制差异文件，适用于文件级别的增量更新。     |
| **xdelta/xdelta3** | 类似于bsdiff，但支持更多功能和格式，适用于文件级别的增量更新。 |
| **rsync**          | 用于同步文件和目录，可以通过网络传输差异数据，适用于文件和目录级别的增量更新。 |
| **OSTree**         | 一种专为Linux设计的更新系统，支持增量更新和版本控制，常用于嵌入式系统。 |

增量OTA更新通过减少传输的数据量和更新时间，提高了更新效率和用户体验，同时也降低了网络带宽的消耗。

# swupdate支持增量更新吗？原理是什么？增量更新的风险是什么？

SWUpdate是一种灵活的嵌入式Linux系统软件更新框架，通常用于全量更新。不过，SWUpdate也支持增量更新，但需要一些额外的配置和工具。以下是SWUpdate支持增量更新的原理和相关风险分析。

### SWUpdate增量更新原理

1. **差异生成**：
   - 使用工具生成新旧版本之间的差异包。常用的工具有`bsdiff`、`xdelta`等。这些工具会生成一个差异文件，只包含新旧版本间的差异数据。

2. **差异包传输**：
   - 将生成的差异包通过OTA传输到目标设备。这通常比传输完整的更新包更小、更快。

3. **应用差异包**：
   - 在目标设备上，使用相应的补丁工具（如`bspatch`、`xdelta3`）将差异包应用到旧版本的文件或文件系统，生成新的版本。

4. **验证**：
   - 应用更新后，验证更新的文件或文件系统的完整性，确保更新过程没有错误。

5. **更新替换**：
   - 将更新后的文件或文件系统替换到设备的工作区，完成更新。

### 增量更新的风险

| **风险**           | **描述**                                                     |
| ------------------ | ------------------------------------------------------------ |
| **数据完整性风险** | 如果差异包在传输过程中损坏或应用过程中出错，可能导致设备无法正常工作。 |
| **安全风险**       | 增量更新需要确保差异包的安全性，防止被篡改或恶意攻击。       |
| **版本兼容性风险** | 新旧版本之间的差异可能引发兼容性问题，导致更新失败或应用异常。 |
| **回滚复杂性**     | 增量更新失败后，回滚到之前的版本可能比全量更新更复杂。       |
| **存储管理风险**   | 设备需要足够的存储空间来存储旧版本、差异包和新版本，可能导致存储管理问题。 |

### 增量更新的风险缓解措施

| **措施**       | **描述**                                           |
| -------------- | -------------------------------------------------- |
| **数据校验和** | 在传输和应用差异包前后进行校验，确保数据完整性。   |
| **签名和验证** | 使用数字签名和验证机制确保差异包的安全性。         |
| **版本控制**   | 维护清晰的版本控制，确保新旧版本间的兼容性。       |
| **充分测试**   | 在发布增量更新前进行全面测试，确保更新过程可靠。   |
| **存储管理**   | 合理管理设备的存储空间，确保有足够的空间进行更新。 |

尽管增量更新可以提高更新效率，减少数据传输量，但也需要仔细设计和测试以确保其可靠性和安全性。

# 参考资料

1、嵌入式 Linux 软件更新机制及架构汇总

https://www.aliyun.com/jiaocheng/121425.html

2、IoT固/软件更新及开源选项

https://blog.csdn.net/wireless_com/article/details/79548091

3、【IoT】如何实现 ESP32 固件的 OTA 在线升级更新

https://blog.csdn.net/liwei16611/article/details/81051909

4、可在线OTA升级的嵌入式系统设计方案

https://blog.csdn.net/zhou_chenz/article/details/54917622

5、基于Flask搭建Android应用OTA升级服务

https://blog.csdn.net/zjt19870816/article/details/80917529

6、嵌入式定制常用的实时Linux改造方案

https://blog.csdn.net/qq_34003774/article/details/80591716

7、260亿物联网终端，或将使OTA升级独成一个产业

http://www.sohu.com/a/214389286_472880

8、OTA升级如何实现？全解共享单车OTA升级过程

https://www.sohu.com/a/231352656_100093632

9、【迷你强的物联网】起始篇-简介与MQTT服务器【从零开始搭建自己的物联网系统】

https://blog.csdn.net/relijin/article/details/73274739

10、Updating Embedded Linux Devices: Update strategies

https://mkrak.org/2018/01/10/updating-embedded-linux-devices-part1/

11、

https://elinux.org/images/3/31/Comparison_of_Linux_Software_Update_Technologies.pdf

12、可在线OTA升级的嵌入式系统设计方案

https://blog.csdn.net/zhou_chenz/article/details/54917622

13、相关的专利

https://patents.google.com/patent/CN101477471A/zh

14、在Linux/U-Boot里为QSPI Flash使用UBIFS

https://xilinx.eetrend.com/content/2021/100553647.html

15、【f1c200s/f1c100s】使用genimage工具制作img系统镜像

https://blog.csdn.net/qq_27350133/article/details/124181468

16、android ota升级

https://blog.csdn.net/tq501501/article/details/114403131