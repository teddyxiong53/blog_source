---
title: 宽字符wchar分析
date: 2023-05-01 10:20:31
tags:
	- 基础

---

--

一般没有怎么涉及到wchar这个东西。

现在看awtk的代码，有这个东西。所以看看具体是怎么回事。



 c/c++标准只是**声明wchar_t是一个可以表示字符集中的任意一个字符的足够宽的变量类型**。

wchar_t可以用任何encoding编码方式来存储这个字符，

如ANSI, or UCS-2, or UCS- 4, 甚至是SCU-128，

只不过我们通常是用unicode编码方式。

==wchar_t是与实现相关的。==



wchar中文叫宽字符。

对应的char，就是窄字符。

而**wchar_t**则是因为char所能表示的字符数太少(256个)而应运而生的，

它的长度可以8bit，16bit，32bit,

长度是与不同平台上的c库相关的。

其实这个长度是根据指定平台上想要用的encoding编码方式来设定的。

**在win32 MSVC环境下，c库中wchar_t的长度是2个byte**,定义如下：

```
typedef unsigned short wchar_t; /* 16 bits */
```

它是按照utf-16编码，

但是因为wchar_t定义的长度只有2个字节，

所以它不能表示utf-16编码长度为4个字节的字符。

即wchar_t只表示了utf-16的一个子集。

换句话说，**就是MSVC下，wchar_t是utf-16编码的**，

但是只能表示utf-16的一个子集。

按utf-16编码时，大部分字符都以固定长度的字节 (2字节) 储存.

在[Linux](http://lib.csdn.net/base/linux)-x86的GCC环境下，c库中wchar_t的长度为四个字节，用UCS-4(即utf-32编码方式)。

wchar_t就是存储的字符的unicode码值的编码值，

如windows下就是unicode码值的utf-16编码值：



所以为了可移植性，我们不能假定wchar_t的编码方式，然后根据编码方式做一些相关性操作，

**我们只能理解它为一个足够宽的字符类型。**



unicode有两种格式，UCS2和UCS4，

它们采用定长编码，

UCS2指定2个字节编码一个字符，

UCS4指定4个字节编码一个字符，

==在这样的约定下，所有国家的字符都采用这样的约定格式来进行重新编码，==

原有的ascii保持编码格式不变，

只是将它扩展成了2个字节或者是4个字节。

当然，你可能也发现了，这样的编码指定也存在一些问题，

==UCS2根本就不能编码出所有的字符，==

==UCS4却可能是文本的长度成倍的增加，==

因为一些字符本可以用一个字节或者是两个字节就可以编码的。

==所以基于这样一些原因，而且随着互联网的出现，就有了后来的 UTF-8,UTF-16,UTF-32，==

它们都是Unicode编码格式的具体实现方式。

UTF-8和UTF-16采用变长的编码方式，

utf-8约定可以用1-4个字节来表示一个字符，

utf-16可以用2个或者是4个字节来编码一个字符。

utf-16可以说是ucs2的扩展，

而utf-32和ucs4基本相同。

关于utf-8的具体编码方式，我建议你可以看一下后面第二个链接阮一峰老师的文章，讲得很清楚。



# 宽字符类型(wchar_t)的跨平台处理

当我们需要把以前写的Windows程序进行跨平台处理时，

如果原来的工程采用的Unicode编码，

我想你肯定首先想到了，

wchar_t类型在Windows和Linux平台下的大小时不一样的，

**Windows下采用的是2字节编码一个字符，基于utf-16，**

**Linux下采用的是4个字节编码一个字符，基于utf-32。**

两个平台下的wchar_t类型sizeof出来的大小不同，那同一份代码进行跨平台处理的时候，会不会出问题呢，这个或许你就有点犯难了。



在这里，我们首先应该明确一点，

==wchar_t类型在Windows和Linux平台下字节大小的不同，==

==对我们程序本身的跨平台性没有任何影响，==

你Windows下是怎么处理wchar_t的，那么在Linux下就怎么处理，

相应的接口和操作都不用改变。

不会对数据的读取产生错误。

==但是有一点，这些是基于这样一个事实的，==

==就是你没有在两个平台之间对不同平台下产生的文件进行读取。==

如我目前所做的项目中，在代码实现上，需要把wchar_t类型的一些数据输出到文件保存，然后在后续的代码中进行读写。

在不同平台下产生的这个文件，wchar_t字符的编码方式肯定是不一样的，所以不能把Windows下生成的文件，直接拿到Linux下面来进行读写，如果这样做，那么读写错误是肯定会发生的。



还有一点，不能贸然的添加gcc 编译项 -fshort-wchar，

强制将Linux平台下的wchar_t指定成两个字节，

因为这样做，只会改变你在代码中自己实现的部分，

而内部库或者是第三方库中用到的接口和函数都是没有变的，仍然采用的是4字节编码。

如，std::wstring, QT中的QString等。



对于这点，在项目中我拟定了两个方案，

==方案一是在代码中读写文件的部分，写入文件的时候，把wchar_t类型的数据转成utf-8的编码格式来保存，==读取的时候把utf-8编码的数据读出来后再转成平台对应的wchar_t字符，两个平台下都采用同样的解决办法。

在windows下可以采用系统函数WideCharToMultiByte()和MultiByteToWideChar()来进行转换，如下面把宽字符转成UTF-8的列子：

# linux使用举例

在 Linux 下使用 `wchar_t` 类型和宽字符字符串（wide character strings）通常涉及标准 C 库的宽字符函数和类型。以下是一个简单的示例，演示如何在 Linux 中使用 `wchar_t` 类型和宽字符字符串：

```c
#include <stdio.h>
#include <wchar.h>
#include <locale.h>

int main() {
    // 设置本地化环境，以支持宽字符
    setlocale(LC_ALL, "");

    // 定义一个宽字符字符串
    wchar_t wstr[] = L"宽字符示例";

    // 打印宽字符字符串
    wprintf(L"宽字符字符串：%ls\n", wstr);

    // 计算宽字符字符串的长度
    size_t len = wcslen(wstr);
    wprintf(L"字符串长度：%zu\n", len);

    // 遍历宽字符字符串并打印每个字符
    wprintf(L"每个字符：");
    for (size_t i = 0; i < len; ++i) {
        wprintf(L"%lc ", wstr[i]);
    }
    wprintf(L"\n");

    return 0;
}
```

在这个示例中：

1. 我们首先包含了 `<stdio.h>`、`<wchar.h>` 和 `<locale.h>` 头文件，分别用于标准输入输出、宽字符支持和本地化设置。

2. 使用 `setlocale` 函数将本地化环境设置为默认值，以支持宽字符。

3. 定义了一个宽字符字符串 `wchar_t wstr[] = L"宽字符示例";`。

4. 使用 `wprintf` 函数打印宽字符字符串，并使用 `%ls` 格式说明符。

5. 使用 `wcslen` 函数计算宽字符字符串的长度。

6. 使用 `for` 循环遍历宽字符字符串的每个字符，并使用 `%lc` 格式说明符打印每个字符。

注意事项：
- 请确保你的终端支持宽字符显示。一些终端可能需要额外的配置，以正确显示宽字符。
- `wchar_t` 的大小和编码方式可能因系统而异，通常在 Linux 中是 32 位的，表示 Unicode 字符。
- 本示例中的宽字符字符串使用了 `L` 前缀，以指示它是宽字符字符串。在 C 中，宽字符字符串使用 `L` 前缀，如 `L"宽字符示例"`。

这个示例演示了如何在 Linux 中使用 `wchar_t` 类型和宽字符字符串进行基本的输入、输出和操作。在实际应用中，宽字符字符串可用于处理不同语言的字符和国际化文本。

打印的输出：

```
宽字符字符串：宽字符示例
字符串长度：5
每个字符：宽 字 符 示 例
```



# 参考资料

1、

https://blog.csdn.net/qq_26093511/article/details/60332795

2、

https://www.cnblogs.com/csstudy/p/11554914.html