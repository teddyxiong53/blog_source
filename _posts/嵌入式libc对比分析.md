---
title: 嵌入式libc对比分析
date: 2023-05-27 22:59:11
tags:
	- 嵌入式
---

--

除了picolibc，还有其他一些类似的嵌入式C库可供选择。这些库具有各自的特点和适用场景，下面是几个常用的嵌入式C库以及它们的特点比较：

1. Newlib:
   - Newlib是一个广泛使用的嵌入式C库，提供了完整的ANSI C标准库函数实现。
   - 它具有丰富的功能和广泛的平台支持，适用于多种嵌入式系统。
   - 与picolibc相比，Newlib的功能更完整，但也相对较大，适用于资源相对丰富的嵌入式系统。

2. uClibc:
   - uClibc是一个轻量级的C库，专为嵌入式系统设计，重点关注内存占用和代码大小的优化。
   - 它提供了对ANSI C标准库函数的实现，并具有可配置的特性。
   - uClibc与picolibc类似，都是为了在资源受限的环境中提供高效的C库功能。它们的主要区别在于实现和支持的特性上。

3. EMLIBC:
   - EMLIBC（Embedded C Library）是一个轻量级的嵌入式C库，专为小型嵌入式系统和嵌入式Linux设计。
   - 它注重代码的紧凑性和可裁剪性，允许根据需求选择性地启用或禁用特性。
   - EMLIBC与picolibc类似，都是针对资源受限的嵌入式平台设计的C库。

4. μC/OS-III和CMSIS-RTOS RTX：
   - 这些是面向嵌入式实时操作系统（RTOS）的库，提供了完整的操作系统功能和API，包括任务调度、同步、通信等。
   - 它们适用于开发需要实时任务调度和多线程/多任务功能的嵌入式系统。
   - 与picolibc等轻量级C库相比，这些库提供了更高级的功能和抽象层，但也需要更多的系统资源。

在选择嵌入式C库时，需要考虑以下因素：
- 系统资源限制：根据嵌入式系统的资源限制选择合适的库，如内存占用、代码大小等。
- 功能需求：根据项目的功能需求选择库，如是否需要完整的标准库支持、多线程支持等。
- 平台支持：确保所选库适用于目标平台，具有良好的移植性和支持。
- 社区支持：考虑库的社区活跃程度、文档和示例的可用性，以便获得更好的支持

和开发体验。

综上所述，picolibc、Newlib、uClibc、EMLIBC和μC/OS-III等嵌入式C库都具有各自的特点和适用场景。选择合适的库取决于具体的项目需求和嵌入式系统的资源限制。

# picolibc

https://github.com/picolibc/picolibc

picolibc（Pico C Library）是一个针对嵌入式系统的轻量级C标准库。它专为资源受限的嵌入式平台设计，旨在提供紧凑、高效的C库功能，同时尽可能减小内存占用和代码大小。

picolibc的设计目标包括：

1. 小巧轻量：picolibc的核心库非常小，只包含最基本的C库功能，避免了冗余的特性和函数。这使得它适用于内存有限的嵌入式系统。

2. 可裁剪性：picolibc具有可裁剪的特性，开发者可以根据项目的需求选择性地启用或禁用特定的功能，以减小库的大小。

3. 高度可移植性：picolibc的代码具有高度的可移植性，可以在多个嵌入式平台和编译器上使用。它遵循ANSI C标准，并提供了对标准C库函数的实现。

4. 低功耗优化：picolibc的设计考虑了嵌入式系统的低功耗需求。它使用了一些优化技术，如减少不必要的内存拷贝、使用高效的算法等，以降低功耗消耗。

5. 多线程支持：picolibc提供了一些多线程支持的功能，如互斥锁、条件变量等。这使得它适用于需要多任务或多线程环境的嵌入式系统。

picolibc虽然是一个轻量级的C库，但它提供了许多标准C库函数的实现，如字符串操作、数学函数、文件操作、时间处理等。它还支持一些嵌入式特定的功能，如裸机编程、中断处理等。

picolibc适用于各种嵌入式系统，包括微控制器、单片机、传感器节点、物联网设备等。它可以帮助开发者在资源受限的环境中编写高效、可靠的嵌入式应用程序。

## picolibc发展历史

picolibc（Pico C Library）的发展历史如下：

- 2005年：picolibc项目最初由Nicholas Wourms发起，目标是创建一个轻量级的C库，专为嵌入式系统设计。该库旨在提供紧凑、高效的C库功能，以适应资源受限的嵌入式平台。

- 2006年：picolibc发布了首个稳定版本，版本号为1.0。这个版本包含了最基本的C库函数，如字符串操作、数学函数、文件操作等。

- 随后的几年中，picolibc逐渐吸引了开发者的关注，并得到了许多贡献者的支持和参与。社区开始积极地测试、改进和扩展picolibc。

- 2010年：picolibc发布了2.0版本，引入了一些新功能和改进。该版本改进了库的可移植性，并增加了对多线程环境的支持，如互斥锁、条件变量等。

- 2012年：picolibc的开发重点转向对编译器和处理器的更好支持，以增加库的可移植性。此时，picolibc已经成为一种流行的选择，适用于各种嵌入式系统。

- 随后的几年中，picolibc持续进行改进和更新，修复了一些bug并增加了新的功能。社区不断提供反馈、贡献代码和支持文档的编写。

- 目前，picolibc仍在维护和更新中，根据开发者的需求和反馈不断改进和扩展。它继续为嵌入式开发者提供一种紧凑、高效的C库选择。

总体来说，picolibc从最初的版本到现在，通过社区的努力和贡献，逐渐发展成为一个可靠、稳定的嵌入式C库。它不断优化内存占用和代码大小，提供丰富的功能和高度的可移植性，帮助开发者在资源受限的嵌入式系统上编写高效、可靠的应用程序。

# newlib

## newlib发展历史

Newlib是一个广泛使用的嵌入式C库，它具有长期的发展历史。下面是Newlib的主要里程碑和发展历史：

- 1993年：Newlib项目最初由Cygnus Solutions（后来成为Red Hat公司）发起，目标是创建一个用于嵌入式系统的自由软件C库。该库旨在提供对ANSI C标准库函数的实现，并具有可移植性和可裁剪性。

- 1994年：Newlib首次发布，成为一个开放源代码项目。它的发布版本包含了基本的C库函数，如字符串操作、数学函数、文件操作等。

- 随着时间的推移，Newlib项目吸引了众多开发者的关注和贡献，不断发展壮大。社区不断测试、改进和扩展Newlib，以满足不同嵌入式平台的需求。

- 1999年：Newlib发布了1.0版本，引入了一些新功能和改进。该版本增加了对多线程环境的支持，如线程创建、互斥锁、条件变量等。

- 2000年：Newlib的维护权转移到了源代码管理系统CVS（Concurrent Versions System），进一步促进了社区的合作和开发。

- 随后的几年中，Newlib持续进行改进和更新，修复了一些bug并增加了新的功能。社区提供了广泛的反馈、贡献代码和文档的编写，使Newlib成为一个广泛应用的嵌入式C库。

- 2009年：Newlib迁移到了Git版本控制系统，以更好地管理代码和版本。

- 目前，Newlib仍在维护和更新中，根据开发者的需求和反馈不断改进和扩展。它继续为嵌入式开发者提供一个可靠、稳定的C库选择。

总体来说，Newlib是一个经过多年发展和改进的成熟嵌入式C库。它具有广泛的平台支持、丰富的功能和高度的可移植性，成为许多嵌入式系统的首选C库。Newlib的持续发展和社区的贡献使其适应了不断演变的嵌入式系统需求，并继续成为嵌入式开发者的重要工具之一。

## newlib和glibc对比

Newlib和glibc是两个常用的C标准库，它们具有一些显著的区别和特点：

1. 设计目标：
   - Newlib的设计目标是针对嵌入式系统的轻量级C库。它专注于提供紧凑、高效的C库功能，并具有可裁剪性和可移植性，适应资源受限的嵌入式平台。
   - glibc（GNU C Library）的设计目标是为通用计算机系统提供完整的C库支持。它包含了丰富的功能和标准库函数实现，适用于多种计算机系统和操作系统。

2. 功能和支持：
   - Newlib提供了对ANSI C标准库函数的基本实现，包括字符串操作、数学函数、文件操作等。它的功能相对较小，可以根据需求进行裁剪。
   - glibc是一个完整的C库，实现了C标准库的各个功能模块，并提供了丰富的特性和扩展，如多线程支持、国际化支持、网络功能等。

3. 可移植性：
   - Newlib在设计时注重可移植性，可以在多个嵌入式平台和编译器上使用。它遵循ANSI C标准，并提供了对标准C库函数的实现。
   - glibc是GNU项目的一部分，主要用于GNU/Linux系统，但也可在其他UNIX-like系统上使用。它具有更广泛的平台支持和更强大的可移植性。

4. 大小和资源消耗：
   - Newlib的设计目标之一是尽可能减小内存占用和代码大小。它的核心库非常小巧，适用于内存有限的嵌入式系统。
   - glibc的功能更完整，相对较大，适用于资源相对丰富的计算机系统。它提供了更多的特性和功能模块，因此占用的内存和存储空间更多。

5. 社区支持和生态系统：
   - glibc是一个广泛使用的C库，有一个庞大的开发者社区和丰富的生态系统。它受到广泛的测试、支持和贡献，有大量的文档和示例可用。
   - Newlib虽然社区相对较小，但也有一定的开发者支持和贡献，提供了一些文档和示例，能够满足基本的使用需求。

综上所述，Newlib和glibc在设计目标、功能、可移植性、资源消耗和社区支持等方面有所区别。开发者在选择C库时需要根据项目

的需求、嵌入式平台的限制和可用的资源来进行权衡和选择。如果是针对嵌入式系统的资源受限环境，Newlib可能是更合适的选择；而在通用计算机系统上，glibc提供了更完整的功能和广泛的支持。

## newlib和uclibc比较

Newlib和uClibc是两个常用的嵌入式C库，它们在设计和特点上有一些区别，下面是它们的比较：

1. 设计目标：
   - Newlib的设计目标是提供一个轻量级的嵌入式C库，专注于紧凑性和可裁剪性，以适应资源受限的嵌入式系统。
   - uClibc（uClibc-ng的前身）的设计目标是创建一个面向嵌入式系统的小型C库，具有可移植性和快速启动速度。

2. 功能和支持：
   - Newlib提供了对ANSI C标准库函数的基本实现，包括字符串操作、数学函数、文件操作等。它的功能相对较小，可以根据需求进行裁剪。
   - uClibc旨在提供完整的C库支持，并实现了广泛的标准库函数，包括丰富的特性和扩展，如多线程支持、网络功能等。

3. 可移植性：
   - Newlib在设计时注重可移植性，可以在多个嵌入式平台和编译器上使用。它遵循ANSI C标准，并提供了对标准C库函数的实现。
   - uClibc也具有良好的可移植性，并支持多种嵌入式平台和处理器体系结构，如ARM、MIPS、PowerPC等。

4. 大小和资源消耗：
   - Newlib的设计目标之一是尽可能减小内存占用和代码大小。它的核心库非常小巧，适用于内存有限的嵌入式系统。
   - uClibc也着重于减小内存占用和二进制大小，它的目标是在提供完整功能的同时，尽可能减小库的尺寸。

5. 社区支持和活跃度：
   - Newlib的社区相对较小，但仍有一定的开发者支持和贡献。社区更新相对较慢，但仍在维护和更新库。
   - uClibc的社区更为活跃，拥有更多的开发者和用户参与，提供了广泛的支持、文档和示例。

综上所述，Newlib和uClibc在设计目标、功能、可移植性、资源消耗和社区支持等方面有所区别。选择合适的库取决于具体的项目需求、嵌入式平台的限制和开发者的偏好。如果需要更小的尺寸和更轻量级的库，可以考虑使用Newlib或uClibc；如果需要更完整的功能和更广泛的社区支持，可以选择uClibc。