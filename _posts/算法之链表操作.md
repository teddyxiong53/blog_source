---
title: 算法之链表操作
date: 2019-04-10 21:56:30
tags:
	- 算法

---

1

# 相关概念

头节点：头节点可以没有。

头指针：指向第一个节点的指针，叫做头指针。头指针必须有。

傀儡节点：什么时候需要傀儡节点？是一个技巧，目的是让新链表可以有一个着手点。最终使用的，是dumm.next。

头插法：是创建一个链表的方法。

尾插法

快指针、慢指针：快指针一次走2步，慢指针一次走一步。这是一种技巧，在很多地方都有应用。

左右指针。

```
一般在处理链表问题时，大多时候都会在开头再加一个 dummy node，因为翻转链表时头结点可能会变化，为了记录当前最新的头结点的位置而引入的 dummy node
```



比起树，链表的指针技巧更多。更适合用来研究这些指针操作。

# 快慢指针的应用

有这些使用场景：

```
1、判断单链表是否有环。
2、在有序链表里寻找中位数。
3、输出链表里倒数第N个节点。
4、判断链表里是否有环。如果有，找到环的入口。
	这个分为两步。第一步判断是否有环。是让快慢指针相遇，然后让fast停住不动。
	然后slow回到head处，重新往后走。如果fast和slow没有相遇，就fast和slow各自往前一步（注意fast现在也是一次一步了。）
5、判断链表是否交叉。这个也可以用快慢指针来解决。
```



# 带头节点的链表

头节点的val里，放链表的长度。

```
ListNode *head = new ListNode(5);//创建一个长度为5的链表。
head->next = nullptr;
//依次创建节点，采用头插法进行插入。
ListNode *s = new ListNode(rand());
s->next = head->next;
head->next = s;
```



要把握指针的灵魂，还是要多练习链表的操作。

下面讨论的，以这个结构体为基础。

```
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x): val(x), next(nullptr) {}
};
```



# 判断2个链表是否有交叉

2个链表交叉后，就会呈现Y字型，而不可能是X型。

最直接的暴力法。

```
void test_cross()
{
    ListNode *a = new ListNode(1);
    ListNode *n1 = new ListNode(1);
    ListNode *n2 = new ListNode(2);
    ListNode *n3 = new ListNode(3);
    ListNode *n4 = new ListNode(4);
    ListNode *b = new ListNode(10);
    a->next = n1;
    n1->next = n2;
    b->next = n4;
    n4->next = n2;
    n2->next = n3;
    printList(a);
    printList(b);
    printf("is a cross b?\n");
    ListNode *b_root = b;

    while(a) {
        b = b_root;
        while(b) {
            if(a == b) {
                printf("yes\n");
                return;
            }
            b = b->next;
        }
        a = a->next;
    }
    printf("no\n");
}
```

要判断2个链表是否相交，可以判断尾节点是否是同一个就可以了。

分别取到链表的最后一个节点（非null的那个）。时间复杂度是O(2N)，也就是O(N)。

```
    while(a) {
        ListNode *a_last = a;
        a = a->next;
    }
```



# 链表的逆转

假设最开始的链表是这样：

```
1 -> 2 -> 3 -> 4 ->5
^
root
```

我们需要引入一个节点指针node。

```
1 -> 2 -> 3 -> 4 ->5
^
root

null
^
node
```

对应代码是：

```
ListNode *reverse(ListNode * root) {
    ListNode *node = nullptr;
}
```

第一步，我们希望把节点1从链表里剥离。为了不丢掉索引，我需要先把节点1的next（也就是节点2）保存到一个next指针里。

```
ListNode *reverse(ListNode * root) {
    ListNode *node = nullptr;
    ListNode *next = root->next;
    root->next = node;//当前node是null
    node = root;
    root = next;
}
```

经过上面的三条语句，就把节点1剥离下来了。

然后我们如法炮制，把剩下的节点都剥离下来。

```
ListNode *reverse(ListNode * root) {
    ListNode *node = nullptr;
    while(root) {
        ListNode *next = root->next;
        root->next = node;
        node = root;
        root = next;
    }
    return node;
}
```

# 链表去重

链表内容如下：

```
1->1->2->2->3->4
^
head
cur
```

如果用一个指针cur来表示当前指针的话，出现重复的条件是：

```
cur->val == cur->next->val
```

我们去掉后面的那个相同的。

```
1->1->2->2->3->4
^  ^  ^
cur   next
|     |
|------
```

代码是：

```
if(cur->val == cur->next->val) {
    ListNode *next = cur->next->next;
    delete cur->next;
    cur->next = next;
}
```

这个思路很简单，这个是很多复杂问题的基础，所以值得注意。

````
ListNode *removeDuplicates(ListNode *head) {
    if(head == nullptr) {
        return head;
    }
    for(ListNode *cur=head; cur->next; ) {
        if(cur->val == cur->next->val) {
            ListNode *next = cur->next->next;
            delete cur->next;
            cur->next = next;
        } else {
            cur = cur->next;
        }
    }
    return head;
}
````

# 链表合并

```
1->2->3
^
a
			===> 1->4->2->5->3->6
4->5->6          ^
^                new_list
b
```

这个问题本身非常简单，但是想通过这个基本问题，引申出链表问题的一个非常常见的技巧。

就是设立dummy节点，也叫傀儡节点。

dummy节点的作用是让新合成的链表有一个着手点。

这个节点的值不用关注，因为我们最终需要的是dummy.next。

```
ListNode *shuffleMerge(ListNode *a, ListNode *b) {
    ListNode dummy(0), *tail = &dummy;
    while(a && b) {
        tail->next = a;
        tail = a;
        a = a->next;
        tail->next = b;
        tail = b;
        b = b->next;
    }
    tail->next = a? a: b;
    return dummy.next;
}
```

可以看到代码也有对称感。



#移动节点

从a移动一个节点到b上。

```
1->2->3             2->3 
^					^
a					a
           =>  
4->5->6				1->4->5->6
^					^
b					b
```

代码实现：

```
void moveNode(ListNode **dst, ListNode **src) {
    ListNode *newNode = *src;
    *src = newNode->next;
    newNode->next = *dst;
    *dst = newNode;
}
```

顺序合并

```
1->3->5
		==> 1->2->3->4->5->6
2->4->6
```

这个也是很基础的操作，结合上面的傀儡节点和moveNode技巧，很容易写出下面的。

```
ListNode *sortedMerge(ListNode *a, ListNode *b)
{
    ListNode dummy(0), *tail = &dummy;
    for(; a&&b; tail=tail->next) {
        if(a->val <= b->val) {
            moveNode(&(tail->next), &a);
        } else {
            moveNode(&(tail->next), &b);
        }
    }
    tail->next = a? a: b;
    return dummy.next;
}
```

可以用递归法来实现。递归替代了循环体。

```
ListNode *sortedMergeRecursion(ListNode *a, ListNode *b)
{
    ListNode *ret = nullptr;
    if(a == nullptr) {
        return b;
    } else if(b == nullptr) {
        return a;
    }
    if(a->val <= b->val) {
        ret = a;
        ret->next = sortedMergeRecursion(a->next, b);
    } else {
        ret = b;
        ret->next = sortedMergeRecursion(a, b->next);
    }
    return ret;
}
```

还有没有其他思路？

有的，我们可以把dummy节点省掉。

我们分析一下这个思路。这个思路很重要。

我们看下面的情况。

```
1->null
^
a
		==> 1->2->3
2->3
^
b
```

这个是一个简单到不能再简单的链表连接了，只需要把a->next=b就可以了。

如果a指向的不是1，而是null？怎么办呢？

```
1->null
	^
	a
		==> 1->2->3
2->3
^
b
```

只需要把b挪到a的位置。

指针a指向null，在内存里是什么样子？

```
ListNode *a = null;
首先，a是一个变量，需要占据内存的位置。
ListNode **aRef = &a;
*aRef = b;
这样，当我们找到指针a的地址的时候，我们缺找到了b。
```

这个实际上就是c++里的引用了。

代码是这样：

```
ListNode *sortedMerge(ListNode *a, ListNode *b) {
    ListNode *ret = nullptr, **lastPtrRef = &ret;
    for (; a && b; lastPtrRef = &((*lastPtrRef)->next)) {
        if (a->val <= b->val) moveNode(lastPtrRef, &a);
        else moveNode(lastPtrRef, &b);
    }
    *lastPtrRef = a ? a : b;
    return ret;
}
```



# 顺序插入

```
4
^
newNode
			=> 1->2->3->4->5
1->2->3->5
^
head
```

还是可以采用上面的三种方法：

1、直接插入法。

2、dummy节点法。

3、引用法。

## 直接插入法

这个是最简单直观的方法。

我们考虑两种情况：

```
1、newNode比head还要小，这个就直接放到开头就好了。
2、newNode比head要大，这个我们就需要遍历找到插入点。
```

```
void sortedInsert(ListNode **headRef, ListNode *newNode) {
    if(*headRef == nullptr || newNode->val <= (*headRef)->val) {
        newNode->next = *headRef;
        *headRef = newNode;
    } else {
        ListNode *cur = *headRef;
        while(cur->next != nullptr && newNode->val > cur->val) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
    }
}
```



代码放在这里：

https://github.com/teddyxiong53/MyAlgo/tree/master/ListNode





参考资料

1、谈指神通

https://segmentfault.com/a/1190000002490878

2、单链表的创建（有头结点和无头结点）

https://blog.csdn.net/songsong2017/article/details/88024883

3、

https://blog.csdn.net/question_mark/article/details/101466588

4、判断两个单链表是否相交及找到第一个交点

https://blog.csdn.net/fengxinlinux/article/details/78885764

5、快慢指针应用总结

https://blog.csdn.net/qq_21815981/article/details/79833976