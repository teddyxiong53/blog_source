---
title: 网络之并发reactor模式
date: 2019-03-21 13:30:32
tags:
	- 网络

---



对reactor模式的各个组件，不是非常理解，还是需要借助现实生活场景来帮助理解。

并发系统经常采用reactor模式，用来替代常用的多线程的处理方式。

节省系统资源。提高系统的吞吐量。



我们以点餐场景为例。

客人点餐，就是一个事件。

多线程方式处理是这样的：

```
一个人来就餐，一个服务员去服务。
二个人来就餐，二个服务员去服务。
五个人来就餐，五个服务员去服务。
```

这就是多线程的处理方式。每一个事件到来，都有一个专门的线程进行服务。

这种方式，在人少的时候，效果很好。客户有专人服务的好的体验。

但是餐馆的生意好了，一下子来了20个人吃饭。老板只请了10个人。

让这10个人做事情快一点，而且做完事情，马上服务下一位。这10个就相当于一个线程池。

但是有一个严重的问题，如果某个客人点菜很慢，某个服务员就会被长期占用处于忙碌状态，其他客人没有得到服务，就会很生气。



reactor模式是怎么处理的呢？

老板后来发现，客人点菜很慢，服务器大部分时候都是在等客人点菜，其实没有做多少事情。

老板就发现一个好的办法：当客人点菜的时候，服务员去招呼其他客人，客人点菜好了后，就喊一声“服务员，点菜”。马上就有服务员过去服务。

这样只需要一个服务员就可以了。这就是单线程做了多线程的事情。

实际生活中的餐馆都是在用reactor模式在工作的。



reactor模式主要是提高系统的吞吐量，在有限的资源下处理更多的事情。



我借助这个比喻来分析muduo里的类。

在s01这个里面，就3个类。

```
EventLoop
	这个是最外层的类。可以理解为一家餐馆。
	loop.loop方法相当于开门营业。
	餐馆里出现的人：
	threadId：餐馆的老板。一个餐馆只能有一个老板。这个就对应了one loop per thread。
	poller：一个服务员。
	ChannelList activeChannels_; 来吃饭的客人，是vector。
	
	loop里，是调用了poller的poll方法，这个相当于是靠服务员来服务的。
	老板不干活的。
	
Channel
	这个相当于来吃饭的客人。
	fd：这个相当于服务员发给客人的号码。
		fd产生和销毁都不由客人做主的。
	loop：
		和fd一起，构成一次在某某餐厅第几号客人吃饭的事件。
	channel.enableReading();
		这个相当于客人走进餐馆。拿起菜单看。
		loop_->updateChannel(this); //餐馆就就把这个人加到自己的当前客户里去。
			poller_->updateChannel(channel);//还是要靠服务员来加入到自己的服务列表里。
				对应到PollFdList pollfds_;//这个就是服务员的服务列表。
Poller
	这个相当于服务员。
	EventLoop* ownerLoop_;
		服务员工作的餐厅。
	poller_->poll(kPollTimeMs, &activeChannels_);
		这个相当于，每过1分钟，服务员都抬头看一下有没有客人招手，
		或者是客人喊话了。（表示有事件发生）
		然后把有服务要求的客人记下来。
		fillActiveChannels
			pollfds_.begin()//是遍历自己的服务列表里的客人。
			
		最后(*it)->handleEvent();//这就是为客人提供服务了。提供吃的、喝的。
```



多路复用的最大改变就是变主动为被动，让客人主动提出服务要求，而不是服务员一次又一次去问。



后面增加的Acceptor。

我觉得可以理解为搬椅子给客人做的特殊服务员。

不对，不是服务员，服务员要有poll方法。

Acceptor是一个特殊的客人。聚合了Channel。



参考资料

1、Reactor模式，或者叫反应器模式

https://daimojingdeyu.iteye.com/blog/828696