---
title: 《Linux内核设计与实现》读书笔记
date: 2019-11-30 16:48:31
tags:
	- Linux

---

接口定义合理，代码风格一致。
一次做一件事情，做到完美。
这是Linus倡导的内核的开发原则。

# 1 Linux内核简介

## 1.1 Unix的历史
Unix取得成功的原因：
1、unix很简洁。
	不想其他的系统，有上千个syscall。
	unix只有200多个。而且用途非常明确。
2、unix里，一切都是文件。
	这样处理接口就可以统一。
3、使用C语言编写。
	这样可移植性就很高。
4、unix创建进程很快。
	fork的优点。
5、简单高效的ipc方式。
	
## 1.2 追寻Linus足迹：Linux简介

## 1.3 操作系统和内核简介

## 1.4 Linux内核与传统Unix内核比较
Linux是宏内核，也就是说，Linux内核运行在单独的内核地址空间上。
不过，Linux吸收了微内核的优点：
1、模块化设计。
2、抢占式内核。
3、支持内核线程。
4、动态加载内核模块的能力。
Linux避免了微内核设计上性能的缺陷。
让所有的事情都运行在内核态，直接调用函数，无须消息传递。

Linux是实用主义的胜利。

## 1.5 Linux内核版本

## 1.6 Linux内核开发社区

# 2. 从内核出发

## 2.1 获取内核源代码

## 2.2 内核源码树

## 2.3 编译内核

## 2.4 内核开发的特点

1、内核编程不能使用C库函数和C库头文件。
	很多函数在内核里有一个简单的实现。
2、内核编程必须使用GNU C。
	内联函数
	内联汇编
	分支声明unlikely这种。
	
3、内核编程缺乏内存保护机制。
	内存错误会导致oops。
	
4、内核编码不要使用浮点计算。
	内核不能完美地支持浮点操作。
	
5、内核里每个进程只有一个很小的定长的栈。
	32位的是8K。64位的是16K。
	
6、因为内核支持异步中断、强制和smp，所以需要随时注意同步和并发。
7、要考虑可移植性。

# 3. 进程管理

## 3.1 进程

每个线程有一个独立的程序计数器、进程栈、一组进程寄存器。

内核调度的对象是线程，而不是进程。

Linux实现的线程其实是一种特殊的进程。

在现代os里，进程提供两种虚拟机制：
1、虚拟处理器。
2、虚拟内存。

## 3.2 进程描述符和任务结构

内核把进程的列表存放在叫task list的双向循环链表里。
链表里的每一项都是一个task_struct。
里面存放了一个进程的所有信息。
task_struct结构体比较大。
在32位机器上，大概是1.7KB。

Linux通过slab分配器来分配task_struct。
这样可以达到2个目的：
1、对象复用。
2、缓存着色。

在进程的内核栈的底部，有一个struct thread_info，里面有一个task_struct指针。

pid的存放
pid默认是32768，这个对于桌面系统够用了。
之所以是这个值，是为了跟老的系统兼容，之前是short类型的。
对于服务器是不够的。
可以通过修改/proc/sys/kernel/pid_max来修改。

内核中大部分处理进程的代码，都是通过task_struct来做的。

因此，通过current宏查找到当前正在运行的进程的pid就很主要。
根据硬件的不同，current宏的实现也不同。

进程的状态，有5种：
1、running。
2、interruptible。
	睡眠中，可以被提前唤醒。
3、uninterruptible。
	睡眠中，不能被提前唤醒。
4、traced。
	正在被追踪，例如被ptrace追踪。
5、stopped。
	收到STOP信号时。
	调试期间也是这种状态。
	
进程家族树
所有的用户进程都是pid为1的init进程的后代。

## 3.3 进程的创建

Linux通过clone这个syscall来实现fork函数。
clone有一些标志。
fork、vfork、__clone这些函数都是调用了clone，只是设置的标志不一样。

vfork
除了不拷贝父进程的页表项之外，vfork和fork功能相同。

## 3.4 线程在Linux中的实现
线程机制是现代编程技术中常用的一种抽象机制。
这种机制提供了在同一进程地址空间进行并发的能力。

从Linux内核的角度说，并不存在线程的概念。
所有的线程都是进程。


内核线程
内核经常需要在后台执行一些操作。
这种任务通过内核线程来完成。

内核线程跟普通进程的区别：
内核线程没有独立的地址空间，task_struct的mm指针为NULL。
内核进程和普通进程一样，可以被调度和抢占。

内核确实是把一些任务交给内核线程去做。
向flush和ksofirqd。
你用top可以看到不少的内核线程。

## 3.5 进程终结

当一个进程终结的是，内核必须释放它所占用的资源，并把这个不幸的消息告诉它的父进程。

在进程调用了do_exit（这个函数永不返回）之后，线程已经陷入僵死状态。
系统还是保留了它的pid。
这样做是为了让系统还有办法继续获取到它的信息。
对应的task_struct也还没有被释放。

# 4. 进程调度

调度程序没有太复杂的原理。
最大限度地利用处理器时间的原则是：
只要有可以执行的进程，那么就总会有进程正在执行。

但是只要系统中的进程数比核心数多，那么肯定某一时刻有进程不能被执行。
这些进程处于等待状态，从这些等待的进程中，选择一个来投入运行。
就是调度程序要做的事情。

## 4.1 多任务

多任务系统可以分为两种：
1、非抢占式。
2、抢占式。

抢占模式下，由调度程序决定什么时候把一个正在运行的程序强行停下来。
换另外一个进程去运行。
这个行为就叫抢占。
进程在被抢占之前可以运行的时间是预先设定好的。
而且有一个专门的名字，叫进程的时间片。

在非抢占模式下，除非进程主动停止运行，否则它会一直执行。
进程主动挂起自己的行为，叫让度yield。

## 4.2 Linux的进程调度


