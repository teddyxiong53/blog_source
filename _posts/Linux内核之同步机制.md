---
title: Linux内核之同步机制
date: 2018-03-26 18:55:21
tags:
	- Linux

---

--

要做到对共享资源的恰当保护，不是一件容易的事情。

多年之前，linux还不支持smp的时候，避免并发数据访问还算比较简单。所以内核早期的开发工作比现在要容易许多。

但是从linux2.0开始支持smp，而且从2.6版本开始支持内核抢占。共享数据的保护变得更加复杂了。



分辨出真正需要共享的数据和相应的临界区。这是最具挑战性的部分。

由于任何可能被并发访问的代码都几乎需要保护，所以找出不需要保护的部分，显得更加容易一些。

哪些是不需要保护的？

1、局部变量。

2、只被特定进程访问的数据。

大多数内核数据结构都需要加锁。

一条经验：

如果有其他的执行线程可以访问这些数据，那么就要给这些数据加上某种形式的锁。

如果任何其他的什么东西都能看到它，那么就要锁住它。

给数据加锁，而不是给代码加锁。



如果可以用原子操作，就不要用复杂的锁，因为这样开销比较小。对cache的影响也最小。



所有的rwsem都是互斥信号量。只对写互斥，对读不互斥。

rwsem只有down函数，没有down_interruptible函数。所以不会被信号打断。



mutex和二值sem类似，但是接口更加简单，实现也更加高效。

内核里，可以很方便地调试mutex，你只需要打开CONFIG_DEBUG_MUTEXES选项。

在menuconfig里的Kernel Hacking -- Lock Debugging 里面。



关于sem和mutex的选择：

1、如果可以用mutex来做到，就用mutex。

2、mutex不能满足了，才用sem。



vfork是如何保证子进程比父进程先运行呢？就是用了一个完成量。



内存屏障，确保指令的顺序执行。

要告诉两个对象，一个是CPU，一个是编译器。因为这2个都可能会对指令顺序进行重排。

处理器会在执行指令期间，会按照自认为最好的顺序进行排列。

大多数情况下，它确实是可以提高效率的。

rmb函数提供了读内存屏障，wmb函数提供了写内存屏障。

实际上是一样的。

```
#define mb()	asm volatile ("": : :"memory")
#define rmb()	mb()
#define wmb()	asm volatile ("": : :"memory")
```





# 1. 什么是内核同步机制？

同步是指内核控制多个进程按照一定的规则或者顺序访问特定资源的机制。

同步机制是内核稳定和效率的重要基础设施。

# 2. 为什么需要同步机制？

当os引入进程的概念，进程成为调度的实体之后，系统就具备了并发执行多个进程的能力。

但是这也同时引入了各个进程直接的资源竞争和共享的问题。

另外，中断、异常这些的引入，导致各个进程的执行相互交错，如果不对共用的资源进行同步，势必会导致系统崩溃。

# 3. 系统中并发的来源

系统并发的来源有：

1、中断。

2、内核态抢占。

3、smp多处理器。

# 4. linux的同步机制分类

1、关中断。

2、自旋锁及变种。

```
1、普通自旋锁 spinlock_t
2、读写自旋锁 rwlock
3、顺序自旋锁 seqlock
```

自旋锁的特点是空转。这种方式有些地方不能用。所以需要有信号量这种会导致sleep的来补充。

3、信号量及变种。

```
1、信号量。struct semaphore。
2、读写信号量。struct rw_semaphore
3、互斥信号量。就是count只能取值为0和1的sem。
```

4、互斥锁。

开始估计是没有互斥锁，所以用信号量来替代。后面linux还是引入了mutex。

5、RCU。

6、完成量complete。



# 参考资料

1、浅析Linux内核同步机制

https://blog.csdn.net/fzubbsc/article/details/37736683

