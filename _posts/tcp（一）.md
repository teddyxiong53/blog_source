---
title: tcp梳理（一）
date: 2018-03-12 10:06:20
tags:
	- 网络
	- tcp
typora-root-url: ..\

---



tcp梳理。这些点是关键点。

#大纲

1、滑动窗口。

以建立tcp连接过程来分析滑动窗口的建立过程。
2、定时器。
怎样决定超时时间和确定重传频率是提高tcp性能的关键。

3、rtt估算和超时重传。
4、慢启动和拥塞避免。
5、快速恢复与重传。
6、Nagle算法。





tcp也反反复复看了好多遍。现在把过程认真梳理一遍。

先来一个交互的图。

![tcp连接传输断开](/images/tcp连接传输断开.png)

对于上面的过程，一般初始化的时候，认为x=0，y=0 。







# 连接的3次握手

作用：

1、初始化seq number的值。这个要在后续的通信中作为序号使用。保证不会乱序。

# 断开的4次挥手

1、其实是2次。因为tcp是全双工的，所以发送方和接收方都要进行fin和ack。只不过有一方是被动的。

2、如果发送方和接收方同时

# 重传机制

ack只会认最后一个连续的包。例如发送方发了1到5共5份数据，接收方收到了1和2，回复发送方一个ack 3，但是却收到了4这个包。（说明中间的3这个包丢掉了）。

ack不能跳着确认，只能连续确认，不然就会认为前面的包都收到了。

下面就针对这个场景来看看各种重传怎么做。

## 超时重传

一种方式是，不会ack，一直等3，等发送方发现收不到3的ack的时候，就会重传3的。

而一旦接收方收到3，就会ack 4，因为之前4已经收到了。

这种方式有个问题，就是要死等3 ，而发送方不知道发生了什么。可能会导致4和5也要重传。

现在有2个选择：

```
1、只重传超时的包，也就是数据3 。节省带宽，但是慢。
2、重传之后的所有的包，也就是数据3/4/5 。快一点，但是没好多少。
```

可以看到，两种方法都不够好。所以就引入了新的算法。

## 快速重传机制

当收到一个乱序的报文的时候，接收方要马上产生一个ack，这个ack不能被延迟，它的目的就是要让发送方知道自己希望收到的报文的seqno。

如果连续收到3个重复的ackno，就认为这个报文丢了。那么就要求发送方理解重传对应的报文。这个不需要等到超时才重传的。

快速恢复和快速重传一般是同时使用的。一起叫做TCP Reno算法。

TCP Reno算法就是在慢启动和拥塞避免的基础上添加了快速重传和快速恢复算法。

这样就避免了在拥塞不严重的情况下，把cwnd变得太小，而影响了效率。

快速恢复算法是基于这样的思考：

1、丢了几个包，问题没有那么严重，不想超时那么严重，所以没有必要回到刚刚建立连接的那种状态，从慢启动开始加速。这样太影响效率了。

2、所以这样处理：

```
1、cwnd = cwnd/2。发送方的拥塞窗口减半。
2、ssthresh = cwnd。慢启动阈值设置。

```



快速重传机制，不是靠时间驱动，而是靠数据驱动。

靠的就是ack的不能跳着确认的原理。

当包3丢了的时候，你给接收方发送任何数据，都会回复ack 2。

如果连续3次，发送方都收到ack 2，那么就可以确认包3丢掉了。可以重新发送包3了。

快速重传只解决了一个问题，就是timeout的问题。

它还是要面临一个艰难的选择：

是重传一个呢？还是重传所有？

所以，问题还需要继续解决。

## SACK

sack是选择性确认的意思。s是selective的意思。

这个需要在tcp头里加一个SACK的东西。

这个需要协议的通信双方都支持才行，linux从2.4以后就默认支持了。

这个的引入，是为了避免不必要的重传，可以只重传必要的包。

这里有说明。

https://blog.csdn.net/wdscq1234/article/details/52503315?locationNum=3



## RTT算法

这个就是计算超时时间的。

timeout这个参数：

1、如果太长了，重发就慢。导致性能差。

2、如果太短了。可能导致误判断丢包。导致越发越丢包，越丢包越发的恶性循环。

这个参数其实是一个动态参数，会根据网络的质量动态调整的。

这个就是RTT算法。RTT是Round Trip Time。来回时间。

算法在RFC793里是这样描述的：

```
1、首先，采用RTT，记下最近的几次RTT值。
2、做平滑计算SRTT。S代表Smoothed。
一个加权移动平均参数，记为a。a在0.8到0.9之间。
公式是这样的：SRTT = (a * SRTT) + ((1 - a)*RTT)
3、计算RTO。超时时间。
引入参数b。b在1.3到2.0之间。
RTO = min[ubound, max[lbound, (b*SRTT)]]
ubound是最大的timeout值。
lbound是最小的timeout值。
```

# 窗口大小具体是指什么？

在TCP报头中，窗口字段是2字节，最大值65535，也就是缓冲区最大为16K字节。
窗口控制大小的目的不是为了控制“长度”，而是控制“速度”。

MTU

是链路层的限制，但是需要在网络层处理。

MSS

Max Segment Size。是网络层的限制，需要传输层进行处理。

指的是不包含tcp头和ip头的负载部分长度。

例如mtu为1500 ，那么MSS就是1500 - ip头（20字节）- tcp头（20字节）= 1460 字节。

如果是这样的两台机器进行通信。

```
A(MTU 1500) <---> B(MTU 1492)
```

建立tcp连接的过程中：

1、A告诉B，我的mss是1460 。

2、B告诉A，我的mss是1452 。

3、协商的结构是用二者的较小值，就是1452 。



如果A告诉B，自己的window是8192，意思就是，B最多可以连续给A发送8192个字节。

如果A告诉B，自己的window是0，那么B就不会给A发送数据。

一直A说自己的window是0的时候，是自己很忙，没空处理。

但是A不能一直说自己很忙。B怎么知道A已经不忙了呢？

这个就要借助一个坚持定时器。

坚持定时器时间到了，B就给A发送负载为1个字节的tcp数据。意思说，你现在有空了吗？

如果A还是很忙，则还是告诉B自己的window是0 。

坚持定时器的时间是1s、2s、4s、8s这样依次递增的。





以太网包最大是1518字节。18个字节是以太网帧头（14字节的头加上4个字节校验）。

1500字节是ip包的长度。

ip包的包头最少是20字节，所以里面的数据就是1480字节。

tcp的包头最短也是20字节，tcp有效数据就是1460字节。



一个10MB的文件，就需要被分包为7100多个包。

这么多包，就要编号，这样接收者就可以根据编号把数据重新组装起来。如果有丢包，也可以知道是哪个包丢了。

这个过程是协议栈完成的，应用程序不需要关注。



第一个包的编号是随机产生的，我们就叫1号包。

如果1号包的长度是100字节，那么下一个包的编号应该是101号。我们可以根据抓包看到的编号来推断包的长度。



服务器方式数据，当然是希望能够尽快发送完成，但是发快了，有可能会丢包。

带宽太小、路由器温度太高、缓存溢出都会导致丢包。

最理想的情况是，在线路允许的情况下，达到最高速率。

但是我们怎么知道线路的情况是怎样的呢？那就是慢慢试。

tcp协议为了达到效率和可靠性的统一，设计了一个慢启动的机制。

开始放松，比较慢，根据丢包情况，调整速率。如果丢包，就降速，如果不丢包，就加速。



linux内核里，TCP_INIT_CWND这个常量就是10。刚开始通信的时候，发送方一次性发送10个数据包，然后等待对方的确认，再继续发送。

默认情况下，接收方每收到2个tcp数据包，就要发送一个ack消息。

ack消息包括：1、期待手动的下一个包的编号。2、自己的接收窗口的剩余容量。

发送方得到这2个信息，就可以推算接收方的大概接收速度，从而进行调整。



#tcp断开为什么要4次挥手？

1、仔细看的话，其实是2次，因为tcp是全双工的，所以，sender和receiver都要FIN和ACK。

只不过有一方是被动的。所以看上去就成了4次挥手。如果两边同时断开连接，那么就会进入到CLOSING状态。

然后再转到TIME_WAIT状态。

断开过程描述，我们以client主动断开为例。

1、client这边调用close(sockfd)接口。里面调用的协议栈实现，会发送一个FIN到server端。client自己进入到FIN_WAIT_1 。

2、server收到了一个FIN，就会进入到CLOSE_WAIT阶段，给client回复一个ACK 。server自己进入LAST_ACK状态，等待客户端回复最后一个ACK 。

3、client收到了ACK，就会进入到FIN_WAIT_2阶段。然后收到server发来的一个FIN。

然后 client回复一个ACK，然后client进入到TIME_WAIT阶段，超时后，就变成CLOSE状态了。

4、而server收到client的ACK后，就变成CLOSE状态。就这样，关闭完成。



上面描述的是一个正常的过程。

但是实际中，有可能出现server主动关闭连接的情况。



server read函数返回值为-1的时候，应该关闭连接，这样server就会发起FIN 。

FIN_WAIT_2在协议栈里没有实现超时，但是linux系统实现了超时回收。

我看lwip在500ms定时器里做了这个。

```
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
```



tcp_output是同步的吗？是的。是要等到发送完成才继续往下走的。





# MSL

最大报文段生存时间。

RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。

TTL与MSL是有关系的但不是简单的相等的关系，MSL要大于等于TTL。





# tcp的send buf和recv buf

每个tcp socket在内核里都有一个send buf和一个recv buf。

tcp的全双工、流量控制都是依赖这2个buffer。

不管应用是否取用，内核都会自动把收到的数据存入到recv buf。

应用的read操作，只是从recv buf里拷贝数据而已。

应用的write操作，也只是写入到send buf里而已。

如果用户进程一直没有从recv buf里取走数据，导致recv buf满了，那么接下来会：

1、通知对端，把滑动窗口设置为0 。保证了recv buf会溢出丢数据，这样就保证了可靠性。

对于udp，则是在满了后直接丢弃新的数据的。所以udp不可靠。

```
/proc/sys/net/ipv4 # cat tcp_wmem 
4096    16384   1951328           
```

这3个值：

1、第一个是min。表示send buf的最少字节数。

2、第二个是默认值。16K。

3、第三个是max。send buf里最大字节数。

SO_RCVBUF和SO_SNDBUF可以用来调整buf的大小。



# MSS

在以太网上，这个值是1460 。

tcp单个包的最大data字节是1448 。为什么少了12个？

这个实际TCP单包传输1448字节数据的根源在于“以太网Ethernet最大的数据帧是1518字节”。

实际场景下，TCP包头中会带有12字节的选项----时间戳。

所以还有12个字节，一般放了时间戳。



# tcp限制大小了，ip分组还常见吗

tcp的是不会分片了。

但是udp的没有限制啊。



# 参考资料

1、

https://link.zhihu.com/?target=http%3A//coolshell.cn/articles/11564.html

2、

http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm

3、请问TCP的窗口大小到底指的是什么？

https://zhidao.baidu.com/question/1641775096629872460.html

4、TCP流量控制中的滑动窗口大小、TCP字段中16位窗口大小、MTU、MSS、缓存区大小有什么关系

https://blog.csdn.net/scythe666/article/details/51967591

5、TCP-IP详解：快速重传与快速恢复

https://blog.csdn.net/wdscq1234/article/details/52529994

6、TCP之深入浅出send和recv

https://www.cnblogs.com/ralap7/p/9180810.html