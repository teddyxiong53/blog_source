---
title: busybox之ash分析
date: 2023-10-24 19:08:32
tags:
	- Linux

---

--

# busybox的ash 这个shell介绍

BusyBox 的 `ash`（Almquist Shell）是一个轻量级的、POSIX 兼容的 Unix shell。它是 BusyBox 工具集中的默认 shell，用于处理命令行输入和执行命令。以下是有关 `ash` shell 的一些主要特点和信息：

1. **轻量级**：`ash` 被设计成非常轻量级，占用较少的内存和存储空间。这使它成为嵌入式系统中的理想选择，特别是在资源受限的环境中。

2. **POSIX 兼容**：`ash` 遵循 POSIX 标准，因此它提供了许多标准 Unix shell 的功能和语法，使其在与其他 shell（如 `bash`、`sh`）不同的环境中具有较高的兼容性。

3. **基本功能**：`ash` 提供了基本的 shell 功能，包括变量、条件语句、循环、命令替换等。尽管它不包含一些高级特性，但对于简单的脚本和命令行任务来说足够了。

4. **小巧且快速**：由于 `ash` 的设计目标是保持小巧和快速，因此它通常执行速度较快，并在启动时占用的内存较少。

5. **命令历史**：`ash` 支持命令历史，允许用户在以前执行的命令之间进行浏览和重用。

6. **脚本编写**：`ash` 可用于编写简单的脚本，处理文件操作、文本处理以及其他常见任务。虽然它不具备像 `bash` 那样的强大编程功能，但对于嵌入式系统中的自动化任务来说，足够使用。

7. **默认 shell**：在许多 BusyBox 版本中，`ash` 被配置为默认的系统 shell，因为它占用资源较少，适合嵌入式系统的需求。

总的来说，`ash` 是一款小巧、高效的 Unix shell，适用于资源受限的嵌入式系统和嵌入式 Linux 环境。尽管它不像某些其他 shell 那样功能丰富，但在这些环境中，它的轻量级和基本功能通常足够满足需求。如果需要更多功能，您可以在 BusyBox 中配置其他 shell（如 `bash`）来替代 `ash`。

## ash的 if也是会生成单独的进程吗？

`ash`（Almquist Shell）中的 `if` 控制结构通常不会创建单独的子进程。

**相反，`ash` 中的 `if` 语句是在当前 shell 进程中执行的，**

因此不会引入额外的进程开销。

当您在 `ash` 中使用 `if` 语句时，`ash` 解释器会根据条件的结果来执行不同的命令块，但这些命令块仍然在同一个进程中执行。

这与某些其他 shell（如 `bash`）中的子 shell 行为不同，后者可能在 `if` 语句内创建子进程来执行条件块。

在 `ash` 中，通常会在同一个进程中执行条件块，这有助于减少额外的进程开销。

例如，在 `ash` 中的简单 `if` 语句如下所示：

```bash
if [ condition ]; then
  # commands to run if condition is true
else
  # commands to run if condition is false
fi
```

在这种情况下，条件的评估和两个块中的命令都在同一个 `ash` 进程中执行，而不会创建额外的进程。

请注意，虽然 `ash` 较轻量，但它也不像一些其他 shell（如 `bash`）那样功能丰富，因此在复杂的脚本中，您可能需要小心处理变量作用域和子 shell 的问题，以确保代码的正确性。

## 是怎么做到的呢？

`ash` 中的 `if` 语句通常不会创建单独的子进程，这是因为 `ash` 的设计采用了更简单的方式来处理条件和执行不同分支。这是通过在同一 shell 进程中执行条件和分支代码的方式实现的。

当你编写一个 `if` 语句时，`ash` 遵循以下步骤来执行：

1. `ash` 解释器首先评估 `if` 语句中的条件表达式（在方括号 `[ ]` 内），以确定它是真还是假。

2. 根据条件的结果，`ash` 解释器决定执行 `then` 块（如果条件为真）或 `else` 块（如果条件为假）。

3. 执行所选块中的命令。这些命令是在同一个 `ash` 进程中执行的，而不是在新的子进程中执行。这意味着它们共享相同的环境变量和变量作用域，因此没有子进程的额外开销。

这种执行方式的好处是简洁和高效，因为它不涉及创建和销毁子进程。但这也意味着在条件块中的变量和状态可以直接传递给后续命令，而不需要通过进程间通信。

请注意，这是 `ash` 的行为，与其他 shell（如 `bash`）可能有所不同。在某些其他 shell 中，`if` 语句可能会创建子 shell 或子进程来执行条件块，这可以导致不同的行为和变量作用域规则。因此，在编写跨不同 shell 的脚本时，需要注意这些差异。

## posix shell规范主要有哪些内容

POSIX（Portable Operating System Interface for Unix）是一个定义了操作系统接口标准的系列规范，包括 shell 接口规范。POSIX shell 规范主要包括以下内容：

1. **命令解释器（Shell）**：规定了一个符合 POSIX 标准的命令解释器应该具备的功能和行为。

2. **命令语法**：POSIX shell 规范定义了一套命令语法，包括命令行参数的解析、命令的执行顺序和控制结构，例如 `if`、`while`、`for` 等。

3. **环境变量**：规定了一组标准的环境变量，例如 `PATH`、`HOME`、`USER` 等，以及它们的作用。

4. **内置命令**：定义了一些内置命令，这些命令不需要通过外部程序来执行，而是由 shell 自身实现。

5. **退出状态**：规定了命令的退出状态码，通常在执行成功时返回 0，失败时返回非零值。

6. **输入/输出重定向**：描述了如何在 shell 中进行输入和输出的重定向，包括 `>`、`>>`、`<`、`<<` 等。

7. **管道（Pipe）**：规定了如何使用管道将一个命令的输出连接到另一个命令的输入，以实现数据流的传递。

8. **命令替换**：定义了如何使用反引号（``）或 `$()` 来执行命令并将其输出嵌入到另一个命令中。

9. **通配符扩展**：规定了文件名通配符的使用方式，如 `*`、`?` 等。

10. **变量扩展**：定义了如何展开变量，并支持参数替换、命令替换等。

11. **退出和信号处理**：规定了如何处理退出信号以及如何在脚本中捕获和处理信号。

12. **文件描述符**：描述了标准输入、标准输出和标准错误输出文件描述符的使用。

13. **控制结构**：定义了条件语句（`if`）、循环结构（`for`、`while`）、选择结构（`case`）等控制结构的使用方式。

14. **函数定义**：规定了如何定义和调用函数。

15. **文件测试运算符**：定义了用于测试文件属性的运算符，如 `-e`、`-f`、`-d` 等。

16. **作业控制**：描述了如何在 shell 中控制和管理作业，如 `bg`、`fg`、`jobs` 等。

17. **Shell 变体**：POSIX shell 规范也定义了不同的 shell 变体，例如 `/bin/sh`、`/bin/bash` 等。

这些规范旨在确保不同 Unix 系统上的 shell 行为和脚本可以在不同平台上进行移植和执行，以提高交互性和可移植性。然而，需要注意的是，并非所有 shell 都完全符合 POSIX 规范，某些 shell 可能会包含额外的扩展功能或不支持所有 POSIX 功能。

## ash的sleep有没有单独创建进程

在 `ash`（Almquist Shell）中，`sleep` 命令通常不会创建单独的子进程。相反，`sleep` 命令会在当前 shell 进程中实现等待的功能。

`sleep` 命令的目的是使当前 shell 进程休眠指定的时间，而不会为此目的而启动一个新的子进程。当您运行 `sleep` 命令时，shell 会在执行过程中暂停指定的时间长度，然后继续执行后续的命令。这可以用于在脚本中创建暂停或等待的效果。

例如：

```sh
echo "Start"
sleep 5  # 休眠5秒
echo "End"
```

在上述示例中，`sleep` 命令会让当前的 `ash` shell 进程休眠 5 秒，然后继续执行后续的 `echo` 命令。`sleep` 命令不会创建额外的进程，而是在当前 shell 进程中等待指定的时间。

请注意，`sleep` 命令的具体行为可能因 `ash` 的实现版本而异。不过，大多数 `ash` 实现都不会创建单独的进程来执行 `sleep`。这使得 `sleep` 成为一种有效的等待或延迟执行的工具。

## BUILTIN_NOSPEC这些宏的作用是什么

```

#define BUILTIN_NOSPEC          "0"
#define BUILTIN_SPECIAL         "1"
#define BUILTIN_REGULAR         "2"
#define BUILTIN_SPEC_REG        "3"
#define BUILTIN_ASSIGN          "4"
#define BUILTIN_SPEC_ASSG       "5"
#define BUILTIN_REG_ASSG        "6"
#define BUILTIN_SPEC_REG_ASSG   "7"
```

这一系列宏定义是用于表示不同类型的内置命令（built-in command）的标识符。在 Almquist Shell (`ash`) 或其他 shell 解释器的代码中，这些标识符用于区分和分类不同的内置命令类型。以下是这些宏定义的解释：

1. **`BUILTIN_NOSPEC` (标识符 "0")**：这表示一种没有特殊属性的内置命令。这可能包括一些普通的内置命令，如变量赋值等。

2. **`BUILTIN_SPECIAL` (标识符 "1")**：这表示一种特殊内置命令。特殊内置命令通常包含一些高级功能，例如 I/O 重定向或管道处理。它们可能需要特殊处理，以支持 shell 的高级功能。

3. **`BUILTIN_REGULAR` (标识符 "2")**：这表示一种常规内置命令。常规内置命令通常是执行常见 shell 操作的命令，例如目录切换、输出控制等。

4. **`BUILTIN_SPEC_REG` (标识符 "3")**：这表示一种既有特殊属性又是常规内置命令的命令。这些内置命令可能具有特殊功能，但也具有常规内置命令的特性。

5. **`BUILTIN_ASSIGN` (标识符 "4")**：这表示一种赋值内置命令。赋值内置命令通常用于设置或修改 shell 变量的值。

6. **`BUILTIN_SPEC_ASSG` (标识符 "5")**：这表示一种具有特殊属性的赋值内置命令。这些内置命令可能在赋值方面具有特殊行为。

7. **`BUILTIN_REG_ASSG` (标识符 "6")**：这表示一种常规赋值内置命令。这些内置命令执行通常的变量赋值操作。

8. **`BUILTIN_SPEC_REG_ASSG` (标识符 "7")**：这表示一种既有特殊属性又是赋值内置命令的命令。这些内置命令可能具有特殊的赋值属性，同时也有其他特殊属性。

这些标识符通常用于 shell 解释器内部，以便正确处理和分类不同类型的内置命令。这使得解释器能够根据命令的属性执行适当的操作。

## shell的PS1 PS2这些是什么

`PS1`、`PS2`、`PS3` 和 `PS4` 是环境变量，用于自定义 Unix/Linux shell 提示符（prompt）和命令行交互。这些变量允许用户在命令行界面中配置和美化他们的Shell提示符。

1. **PS1**：`PS1` 是主提示符的环境变量。它定义了命令行中每个命令行输入的提示，通常包括用户名、主机名、当前工作目录等信息。用户可以根据自己的需求自定义 `PS1` 变量以创建个性化的提示符。

   例如，以下是一个自定义的 `PS1`：

   ```bash
   export PS1="\u@\h:\w$ "
   ```

   上述示例中，`\u` 表示用户名，`\h` 表示主机名，`\w` 表示当前工作目录，`$` 表示命令提示符。

2. **PS2**：`PS2` 是辅助提示符的环境变量。当您在交互式Shell中输入多行命令且某一行不完整时，Shell将使用 `PS2` 来提示您输入下一行。通常，`PS2` 设置为 `>`，表示继续输入。

   例如，当您在Shell中输入多行循环或条件语句时，`PS2` 将用于提示您输入下一行，以完成命令。

3. **PS3**：`PS3` 是用于 `select` 命令的提示符环境变量。`select` 是一种用于创建菜单选择器的Shell控制结构。`PS3` 设置了 `select` 命令显示的选项提示符。

   例如：

   ```bash
   PS3="Select an option: "
   select option in A B C
   do
       case $option in
           A) echo "You selected A";;
           B) echo "You selected B";;
           C) echo "You selected C";;
           *) echo "Invalid option";;
       esac
   done
   ```

4. **PS4**：`PS4` 是用于跟踪执行脚本中各个命令的提示符环境变量。它用于调试脚本，通常在脚本中使用 `set -x` 启用跟踪时显示。

   例如，如果您在脚本中设置 `PS4`，它将在每个执行的命令前显示，以帮助您跟踪脚本的执行过程。

   ```bash
   PS4='+ '  # 设置PS4
   set -x    # 启用跟踪
   ```

这些环境变量允许用户自定义Shell提示符和交互式Shell的行为，以使Shell更符合其需求。通过适当配置这些变量，您可以改进Shell的可读性和交互性。

## SHLVL环境变量

`SHLVL`（Shell Level）是一个环境变量，它用于跟踪当前shell进程所处的嵌套层次。

当您启动一个新shell进程时，`SHLVL` 的值会递增，用于指示当前shell进程的嵌套级别。

嵌套级别是指在一个shell中启动了另一个shell的情况。

这通常发生在以下情况下：

1. 从当前shell中启动新的shell，例如通过运行 `bash` 或 `sh` 命令。

2. 在脚本中调用其他脚本，其中每个脚本都会增加 `SHLVL` 的值。

3. 当使用某些shell命令，如命令替代或子shell（使用圆括号包围的命令），也会导致 `SHLVL` 的增加。

例如，如果 `SHLVL` 的值为2，那么表示当前shell是在另一个shell内启动的。`SHLVL` 的值可以用来识别当前shell是否处于嵌套状态，**并在shell脚本中根据嵌套级别采取不同的行动。**

`SHLVL` 环境变量通常用于shell脚本中，以便根据脚本的执行方式和嵌套级别采取不同的操作。例如，脚本可以检查 `SHLVL` 的值，以确保它在特定的嵌套级别上执行，或者根据嵌套级别决定是否执行某些操作。这对于编写具有复杂逻辑的shell脚本非常有用。

## /etc/shells文件的作用

`/etc/shells` 文件是一个用于指定合法登录Shell的配置文件，通常存在于Unix/Linux操作系统中。该文件列出了可以分配给系统用户的Shell解释器的路径，**即哪些Shell可以用作用户的登录Shell**。系统管理员使用 `/etc/shells` 文件来限制可用的Shell选项。

这个文件的作用包括：

1. **限制可用Shell选项**：通过编辑 `/etc/shells` 文件，系统管理员可以定义一组可用的Shell选项，这有助于限制用户登录时可以选择的Shell。这是一种安全性措施，可以防止用户使用不受信任的或可能有安全问题的Shell。

2. **为用户选择登录Shell提供清晰的选择**：通过列出可用的Shell选项，`/etc/shells` 文件提供了一种为用户选择登录Shell提供清晰和明确的方式。用户通常可以通过将其登录Shell更改为 `/etc/shells` 文件中列出的任何Shell之一，来更改其默认Shell。

3. **维护系统一致性**：`/etc/shells` 文件有助于维护系统的一致性。它确保了系统中的不同用户都可以使用相同的Shell选项。这在管理多个用户帐户的系统上非常有用。

通常，`/etc/shells` 文件包含了各种Shell的路径，例如 `/bin/bash`、`/bin/sh`、`/bin/zsh` 等。用户和系统管理员可以根据系统的要求进行编辑，以适应特定的Shell配置。

需要注意的是，`/etc/shells` 文件对系统的安全性有重要影响，因此只有具有管理员权限的用户才能编辑该文件。编辑时应格外谨慎，以确保不允许不安全或未经授权的Shell选项。

## memstat.conf 文件作用

`memstat.conf` 文件通常用于配置和控制内存统计（memory statistics）工具或守护进程的行为。

这个文件包含了有关内存统计工具的配置选项，

允许用户或管理员定义哪些内存统计信息应该被监控、如何显示监控信息、以及其他相关的配置设置。

具体的作用和格式可能会因工具和环境而异。

以下是 `memstat.conf` 文件的一些典型作用：

1. **定义监控的内存指标**：`memstat.conf` 文件通常允许您指定要监控的内存指标，例如物理内存使用、虚拟内存使用、交换空间使用等。通过配置，您可以选择监控您关心的内存方面，而不必收集所有可能的信息。

2. **设置监控间隔**：您可以配置 `memstat.conf` 文件来定义内存统计工具的监控间隔。这决定了多频繁采集内存统计数据。较短的间隔可能提供更详细的数据，但也可能增加系统开销。

3. **选择输出格式**：`memstat.conf` 可能允许您选择输出数据的格式。您可以配置输出为文本、CSV、JSON 等格式，以便将数据存储到文件或其他工具进行后续处理。

4. **设置告警阈值**：一些内存统计工具允许您在特定条件下触发告警。 `memstat.conf` 可能包含配置选项，以定义何时触发告警，例如当物理内存使用率超过某个阈值时。

5. **配置日志文件**：您可以指定数据日志的位置和格式，以便存储监控数据以供后续分析。

6. **其他定制选项**：`memstat.conf` 可能还包含其他与内存统计工具或守护进程相关的配置选项，根据工具的特定需求而有所不同。

具体的 `memstat.conf` 文件内容和格式取决于所使用的内存统计工具和系统的需求。常见的内存统计工具包括 `vmstat`、`sar`、`top` 等。通常，您可以在相关工具的文档或手册中找到有关如何配置和使用 `memstat.conf` 文件的详细信息。