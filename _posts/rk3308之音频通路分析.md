---
title: rk3308之音频通路分析
date: 2020-04-11 11:59:51
tags:
	- Linux

---

1

这个是一个复杂的题目，从驱动到应用层，把相关流程理清楚。

以arecord和aplay命令的执行为分析入口。

先看aplay。播放通路相对来说还简单点。

```
aplay 1.wav
```

涉及的代码：alsa-utils、alsa-lib、Linux驱动。

先看aplay.c的代码，在alsa-utils里。

实际是，arecord和aplay都是在aplay.c里，二者共用了参数，不同在于，看argv[0]是什么，就运行对应的分支。

这种技巧比较少见。

涉及的第一个数据结构是：snd_pcm_info_t。

这个结构体在alsa-lib下面的include/sound/asound.h里。

这个结构体表示的是：一个pcm流的信息，这个pcm来自于那个设备，方向是输入还是输出。

默认格式是U8的，采样率是8K。通道数是1 。

-l：这个参数表示列出device list。

-L：这个表示列出pcm list。

看看怎样列出device list的。

```
static void device_list(void)
	snd_card_next//这个就是去看/dev/snd/下面的pcm设置来查询的。
	while (card >= 0) {
		snd_ctl_open
		snd_ctl_card_info
		while (1) {
			snd_pcm_info_get_subdevices_count
		}
	}
```

SNDRV_CTL_IOCTL_CARD_INFO

这个就是ioctl的操作命令，在内核头文件里也有。

看看这个是在哪里进行实现。

在kernel/sound目录下，是这里：

```
./core/control_compat.c:462:    case SNDRV_CTL_IOCTL_CARD_INFO:
./core/control.c:1478:  case SNDRV_CTL_IOCTL_CARD_INFO:
```

当前内核里，音频修改配置这样。

oss相关的都是关闭的。

```
CONFIG_SOUND=y
# CONFIG_SOUND_OSS_CORE is not set
CONFIG_SND=y
CONFIG_SND_TIMER=y
CONFIG_SND_PCM=y
CONFIG_SND_DMAENGINE_PCM=y
CONFIG_SND_JACK=y
# CONFIG_SND_SEQUENCER is not set
# CONFIG_SND_MIXER_OSS is not set
# CONFIG_SND_PCM_OSS is not set
CONFIG_SND_PCM_TIMER=y
CONFIG_SND_HRTIMER=y

CONFIG_SND_PROC_FS=y
CONFIG_SND_VERBOSE_PROCFS=y

CONFIG_SND_DRIVERS=y
# CONFIG_SND_DUMMY is not set
CONFIG_SND_ALOOP=y
```

CONFIG_SND_ALOOP 这个就是loopback。这个值得分析一下。

对应的platform节点在这里：

```
/sys/devices/platform/snd_aloop.0
```

```
/dev/snd/by-path # ls -lh                                                                     
lrwxrwxrwx    1 root     root          12 Jan  1 08:00 platform-acodec-sound -> ../controlC0  
lrwxrwxrwx    1 root     root          12 Jan  1 08:00 platform-snd_aloop.0 -> ../controlC7   
```

播放也没有什么特别的，就是open之后，进行write操作就好了。

需要看看amixer的那些配置项是怎样出来的。

分别起什么租用。

看看amixer scontrols怎样执行的。

```
} else if (!strcmp(argv[optind], "scontrols") || !strcmp(argv[optind], "simple")) {
		return selems(level) ? 1 : 0;
```

是通过`snd_mixer_open`来操作的。

这个是打开哪个设备节点？

没有设备，就是一个软件上的东西。

open之后，得到一个handle。

然后用attach函数把handle和硬件声卡关联起来。card是一个字符串，默认是”default“。

```
snd_mixer_attach(handle, card)
```

当前列出有这些字符串：

```
/ # amixer scontrols                            
Simple mixer control 'Master',0                 
Simple mixer control 'Speaker hard mute',0      
Simple mixer control 'ADC ALC Group 0 Left',0   
Simple mixer control 'ADC ALC Group 0 Right',0  
Simple mixer control 'ADC ALC Group 1 Left',0   
Simple mixer control 'ADC ALC Group 1 Right',0  
```

Speaker hard mute 这种字符串是在哪里写的？内核驱动里吗？

是的，在这里：

```
./sound/soc/codecs/rk3308_codec.c:830:  SOC_ENUM_EXT("Speaker hard mute", rk3308_hpf_enum_array[0],
```



# asound.conf里的配置对通路的影响







