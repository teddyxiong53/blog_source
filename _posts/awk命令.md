---
title: awk命令
date: 2020-12-12 15:06:30
tags:
	- Linux
---

--

觉得有必要把awk这个命令仔细学习一下，因为经常有一些小的字符处理需求。

感觉用awk就足以解决了。不用去弄正则表达式。



AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。

基本语法：

```
awk [选项] -f scriptfile -v var=value file
```

-f后面跟一个脚本文件。

var=value表示给变量赋值。

file表示要处理的目标文件。

常用选项：

```
-F 分隔符。默认是空格。例如可以改成-F:  -F, -F#

```

行匹配语句

```
awk '{[pattern] action}' {filenames}
```

行匹配语句，只能使用单引号。

后面可以跟多个文件。

action就是print这一类的操作。

pattern可以没有。

例如：

```
awk '{print $1}' 1.txt
```

1.txt里内容放这些，作为测试材料。

```
2 this is a test
3 Are you like awk
This's a test
10 There are orange,apple,mongo
```

# awk和sed对比

`awk`和`sed`都是用于文本处理的强大工具，但它们在设计和功能上有一些区别。以下是`awk`和`sed`之间的一些对比：

1. **设计目的：**
   - **`awk`：** 设计用于处理结构化文本数据，支持字段（列）的概念，可以进行更复杂的文本分析和处理，适用于数据提取和报告生成。
   - **`sed`：** 主要用于流编辑，它是一种简化的文本流处理工具，适合于搜索、替换、删除等基本文本转换任务。

2. **数据处理：**
   - **`awk`：** 支持按字段分隔、条件语句、循环等，对于表格形式的数据处理更为方便。可以通过变量和内置函数实现更复杂的逻辑。
   - **`sed`：** 主要用于基本的文本流编辑，通常用于单一的模式匹配和替换。

3. **字段处理：**
   - **`awk`：** 内置了字段分隔符的概念，可以轻松处理每一行中的不同字段。`$1`表示第一个字段，`$2`表示第二个字段，以此类推。
   - **`sed`：** 不直接支持字段的概念，它更专注于整个行的操作。

4. **语法和功能：**
   - **`awk`：** 具有更丰富的语法和功能，支持变量、数组、条件语句、循环等。适用于更复杂的文本处理任务。
   - **`sed`：** 语法相对较简单，主要用于基本的文本流编辑。功能上不如`awk`强大。

5. **应用场景：**
   - **`awk`：** 适用于需要更复杂文本分析、数据提取、统计和报告生成的场景，特别是对结构化数据的处理。
   - **`sed`：** 适用于简单的文本替换、搜索和基本的文本流编辑，常用于一次性的文本转换任务。

6. **脚本文件：**
   - **`awk`：** 通常用于编写脚本文件，可以包含多行的`awk`代码。
   - **`sed`：** 通常以行命令的形式直接在命令行中执行，也可以通过脚本文件进行批量处理。

总体而言，`awk`和`sed`在文本处理中有着不同的定位和优势，根据任务的复杂性和要求选择合适的工具是很重要的。有时候也可以将它们结合使用，根据实际需求选用最合适的工具。

# 多个分隔符

可以使用多个分隔符。

例如先用空格分割，在此基础上，再用逗号分割。

```
awk -F '[ ,]' '{print $1, $2, $5}' 1.txt
```

# 变量

```
awk -v a=1 '{print $1,$1+a}' 1.txt
```

输出是这样：

```
2 3
3 4
This's 1
10 11
```

可以看到，字符串的加1，是在后面拼接字符1。

# 使用脚本

```
awk -f {script} {filename}
```

例如：

```
awk -f cal.awk 1.txt
```

# 运算符

过滤第一列大于2的行。

```
awk '$1 > 2' 1.txt
```

过滤第一列等于2，然后打印这样的行的第一个和第三个字符。

```
awk '$1==2 {print $1,$3}' 1.txt
```

多个条件与。

```
awk '$1>2 && $2=="Are" {print $1,$2,$3}' 1.txt
```

# 内建变量

```
$n 当前行的第几个字段。由FS分割。
$0 当前行的所有数据。

```

# 使用正则

```
awk '$2 ~ /th/ {print $2,$2}' 1.txt
```

~表示后面是正则表达式。

//  2个斜杠包裹的就是正则表达式。



# 忽略大小写

```
awk 'BEGIN{IGNORECASE=1} /this/' 1.txt
awk 'begin{ignorecase=1} /this/' 1.txt
```

这2个的输出为什么不同？

因为关键词大小写敏感？

```
teddy@VM-0-17-ubuntu:~/work$ awk 'BEGIN{IGNORECASE=1} /this/' 1.txt
2 this is a test
This's a test
```

```
teddy@VM-0-17-ubuntu:~/work$ awk 'begin{ignorecase=1} /this/' 1.txt
2 this is a test
```

# 思维导图

https://blog.csdn.net/yexiangCSDN/article/details/79801082





# 参考资料

https://www.runoob.com/linux/linux-comm-awk.html

